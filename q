warning: in the working copy of 'README.md', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'code/Jupyter/imod_python_conversion/imod_python_init_NBr32.ipynb', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/Mng/Mdl_Ipvs.xlsx b/Mng/Mdl_Ipvs.xlsx[m
[1mindex 69cdddc..8a83ed0 100644[m
Binary files a/Mng/Mdl_Ipvs.xlsx and b/Mng/Mdl_Ipvs.xlsx differ
[1mdiff --git a/Mng/RunLog.xlsx b/Mng/RunLog.xlsx[m
[1mindex 5d1e0df..8eb14b9 100644[m
Binary files a/Mng/RunLog.xlsx and b/Mng/RunLog.xlsx differ
[1mdiff --git a/Mng/log.csv b/Mng/log.csv[m
[1mindex 4b14102..8e5222c 100644[m
[1m--- a/Mng/log.csv[m
[1m+++ b/Mng/log.csv[m
[36m@@ -29,3 +29,4 @@[m [mNBr27,PoPed,2025-07-04 08:52:16,2025-07-04 08:53:24,2025-07-04 08:56:58,2025-07-[m
 NBr28,Completed,2025-07-07 14:45:27,2025-07-07 14:46:15,2025-07-07 14:46:54,,00:00:39,UU120516,C:/OD/WS_Mdl\models/NBr\Sim,2010-01-01,2010-01-05,v0.7.4,667ea282c3ba93f68d858ab1dc6b22956191035f,,,[m
 NBr29,PoPed,2025-07-10 16:24:04,2025-07-10 16:25:21,2025-07-10 16:43:29,2025-07-10 16:44:15,00:18:07,UU120516,C:/OD/WS_Mdl\models/NBr\Sim,2010-01-01,2010-01-05,0.7.7,62f48f8ff352a96f963d6c1e6bc2c2e71b0de4b1,1.0,(L == 1),1.0[m
 NBr30,PoPed,2025-07-11 13:45:57,2025-07-11 13:49:32,2025-07-11 13:53:43,2025-07-11 13:54:29,00:04:10,UU120516,C:/OD/WS_Mdl\models/NBr\Sim,2010-01-01,2010-01-05,0.7.8,bc939be1b30e4d76a90a9590d35e4ad04f3abda1,1.0,(L == 1),1.0[m
[32m+[m[32mNBr32,Running,2025-08-07 16:12:38,,,,,UU120516,C:/OD/WS_Mdl\models/NBr\Sim,2010-01-01,2010-01-03,-,a6cd6187fde268ed029f089ddc22346719c7eb4b,,,[m
[1mdiff --git a/README.md b/README.md[m
[1mindex 283b095..032f80d 100644[m
[1m--- a/README.md[m
[1m+++ b/README.md[m
[36m@@ -10,7 +10,7 @@[m [mmklink /D C:\OD "C:\Users\<User>\OneDrive - Universiteit Utrecht"<br>[m
 The symbolic link can be deleted using:<br>[m
 rmdir C:\OD[m
 [m
[31m-The model files are shared only upon request. You can get the public files by cloning the repo:[m
[32m+[m[32mThe model files are shared only upon request. **Clone** the repo to get the publicly avaialble files:[m
 git clone https://github.com/Ydrolog/WS_Mdl[m
 ---[m
 [m
[36m@@ -22,6 +22,11 @@[m [mgit clone https://github.com/Ydrolog/WS_Mdl[m
 ---[m
 [m
 [m
[32m+[m[32m# Knowledge requirements[m
[32m+[m[32mYou need to be familiar with Groundwater Modelling concepts, version control/GitHub... TBC[m
[32m+[m[32m---[m
[32m+[m
[32m+[m
 # Folder structure/description[m
 Files that are specific to one of the **models** will be contained withing the folder of that model. The rest of the folders in this directory should contain files that are (or will be) used by/for multiple models.<br>[m
 Below is a brief description of the contents of each main folder in this directory.<br>[m
[36m@@ -36,7 +41,7 @@[m [mthe models folder structure is described in more detail below because it is comp[m
 ---[m
 [m
 [m
[31m-## Models[m
[32m+[m[32m## Model(s)[m
 All model sub-folders contain the same folder structure for consistency. Files in those folders are only relevant to this Mdl. The Fo Str is described below:[m
 - **code**:	Contains code specific to each Mdl. e.g. Mdl_Prep contains the .bat & .ini file to prepare a Mdl run.[m
 - **doc**:	self-explanatory[m
[36m@@ -63,10 +68,10 @@[m [mcd "C:\Users\mkarampasi\OneDrive - Universiteit Utrecht\Software\InstalledOutsid[m
 .\doublecmd-1.1.22.x86_64-win64.exe <br>[m
 Opt: replace files in C:\Users\<User>\AppData\Roaming\doublecmd\ with files in C:\OD\Software\Settings\Double Commander\ (might need to enable view Hidden files)[m
 [m
[31m-2. **Python Env** (with snakmake)[m
[31m-Install the **Python** env necessary for this project following this guide:[m
[32m+[m[32m2. **pixi Env** (with snakmake)[m
[32m+[m[32mInstall the pixi env, necessary for this project, following this guide:[m
 ./code/Env/how_to_make_Env.md[m
[31m-(C:\OD\WS_Mdl\**code**\Env\How_to_make_env.md)[m
[32m+[m[32m(C:\OD\WS_Mdl\code\Env\How_to_make_env.md)[m
 [m
 3. (Opt: **PS7** - #666 I should make a guide later)[m
 [m
[36m@@ -79,4 +84,5 @@[m [mInstall the **Python** env necessary for this project following this guide:[m
 There is a list of **terminal tools** that facilitate common tasks for this project. Those are listed in C:/OD/WS_Mdl/code/setup.py, with a brief description.<br>[m
 To add another terminal command, you need to add it to the setup file (similar to the other commands), and make a script. Then you need to install WS_Mdl (as explained in the Python Env installation guide above).<br>[m
 It's also possible to run Python functions from C:\OD\WS_Mdl\code\WS_Mdl\ modules via "`WS_Mdl.module` <function> <arg1> <arg2> ...".[m
[31m----[m
\ No newline at end of file[m
[32m+[m
[32m+[m[32m---[m
[1mdiff --git a/code/Env/freeze_pixi_env.py b/code/Env/freeze_pixi_env.py[m
[1mdeleted file mode 100644[m
[1mindex 0cbd9a9..0000000[m
[1m--- a/code/Env/freeze_pixi_env.py[m
[1m+++ /dev/null[m
[36m@@ -1,52 +0,0 @@[m
[31m-#!/usr/bin/env python3[m
[31m-import subprocess[m
[31m-import sys[m
[31m-from datetime import datetime as DT[m
[31m-from pathlib import Path[m
[31m-[m
[31m-# from WS_Mdl import utils as U[m
[31m-[m
[31m-# Pa_toml, Pa_lock, Pa_WS_Mdl = U.[m
[31m-[m
[31m-# Paths relative to repo root[m
[31m-FILES_TO_TRACK = ['pixi.toml', 'pixi.lock', 'WS_Mdl/'][m
[31m-[m
[31m-[m
[31m-def run_cmd(cmd, check=True, capture=False):[m
[31m-    return subprocess.run(cmd, check=check, capture_output=capture, text=True)[m
[31m-[m
[31m-[m
[31m-def main():[m
[31m-    try:[m
[31m-        # Ensure we are in repo root[m
[31m-        repo_root = run_cmd(['git', 'rev-parse', '--show-toplevel'], capture=True).stdout.strip()[m
[31m-        print(f'Repo root: {repo_root}')[m
[31m-        Path(repo_root)  # not really needed but keeps structure[m
[31m-[m
[31m-        # Check for changes in the relevant files[m
[31m-        diff_cmd = ['git', 'status', '--porcelain'] + FILES_TO_TRACK[m
[31m-        changes = run_cmd(diff_cmd, capture=True).stdout.strip()[m
[31m-[m
[31m-        if not changes:[m
[31m-            print('No changes to tracked env/code files. Nothing to commit.')[m
[31m-            return[m
[31m-[m
[31m-        print('Changes detected:\n' + changes)[m
[31m-[m
[31m-        # Stage changes[m
[31m-        run_cmd(['git', 'add'] + FILES_TO_TRACK)[m
[31m-        print('Staged changes.')[m
[31m-[m
[31m-        # Commit with timestamp[m
[31m-        now = DT.now().strftime('%Y-%m-%d %H:%M:%S')[m
[31m-        commit_msg = f'Model run prep â€“ {now}'[m
[31m-        run_cmd(['git', 'commit', '-m', commit_msg])[m
[31m-        print(f"Committed changes with message: '{commit_msg}'")[m
[31m-[m
[31m-    except subprocess.CalledProcessError as e:[m
[31m-        print(f'Error running command: {e}', file=sys.stderr)[m
[31m-        sys.exit(1)[m
[31m-[m
[31m-[m
[31m-if __name__ == '__main__':[m
[31m-    main()[m
[1mdiff --git a/code/Env/how_to_make_Env.md b/code/Env/how_to_make_Env.md[m
[1mindex 0901ba5..f787909 100644[m
[1m--- a/code/Env/how_to_make_Env.md[m
[1m+++ b/code/Env/how_to_make_Env.md[m
[36m@@ -1,35 +1,46 @@[m
[31m-# NEW GUIDE - env managemet py pixi ##########[m
[32m+[m[32m# pixi Env guide[m
 -----------------------------------------[m
[31m-This project uses pixi for managing dependencies. Why? Cause it's more robust/secure and fast than conda or any other package manager. [m
[32m+[m[32mThis project uses **pixi** for managing dependencies. Why? So that Sims are reproducible and old code works.[m
[32m+[m[32mPixi is also more robust/secure and fast than conda or any other package manager that I know, hence it was chosen.[m
 For more details check: https://pixi.sh/latest/[m
 [m
[31m-This guide explains how we use **Pixi** to create, reproduce, and share the software environment for the *WS_Mdl* project.[m
[32m+[m[32mThis guide explains how to use **pixi** to create, reproduce, and share the software environment for the *WS_Mdl* project.[m
 [m
 ## 1. Download and install pixi.[m
 - either follow their instructions on the website (https://pixi.sh/latest/installation/).[m
 - or if you have/prefer conda (I haven't tried this, but it should work):[m
[31m-	install -c conda-forge pixi [m
[32m+[m	[32minstall -c conda-forge pixi[m
 [m
[31m-## 2. To re-create the env that was used for Sim.[m
[31m-1. If you don't have the files for this project, you'll need to **clone** the repo.[m
[32m+[m[32m## 2. Clone env.[m
[32m+[m[32mIf you don't have the files for this project, you'll need to **clone** the repo.[m
 git clone https://github.com/Ydrolog/WS_Mdl C:\OD\WS_Mdl[m
 C:\OD\WS_Mdl is the default location. If you want it somewhere else, feel free to change the path, but that may make things more complicated later.[m
 Not all files are public, you'll need to request the rest from the project owner(s).[m
 [m
[31m-2. The pixi env is installed in C:\OD\WS_Mdl\code, as there is no code in the other folders that need to use it. Make it your active dir if you're not already there.[m
[31m-cd C:\OD\WS_Mdl\code[m
[32m+[m[32m## 3. (re)create previous pixi env.[m
[32m+[m[32m(This can be replaced by a script that only requires the Run to reproduce as input)[m
[32m+[m[32mThe main reason to recreate a pixi env is to reproduce an older Sim.[m
[32m+[m[32mMost of the time, a Sim should run on most versions of the repo. But recreating the env ensures identical results, so you're advised to do so.[m
 [m
[31m-3. **Copy** tag or hash.[m
[32m+[m[32m1. Ensure you've committed any work before doing this. (git add, git commit etc.)[m
[32m+[m
[32m+[m[32m2. Register new/repeat Sims in the RunLog. It's safer and simpler to have more Sims than to remove the old ones. "Sim numbers are free, the pain of Sim confusion is priceless"[m
[32m+[m[32mMake sure you write in the descriptio which Sims you're repeating and how you're recreating them (could be a reference to this file...)[m
[32m+[m
[32m+[m[32m3. **Copy** tag or hash of the Sim you want to recreate.[m
    *Open* `./Mng/RunLog.xlsx` and copy the *Tag* or *Hash* column for the Sim you want to re-run.[m
 [m
[31m-4. **Checkout** that commit:[m
[31m-git checkout <hash/tag>[m
[32m+[m[32m4. **Restore** env defining files:[m
[32m+[m[32mgit restore --source <sha_or_tag> --pathspec-from-file=C:\WS_Mdl\code\Env\pixi_env_Fis.txt[m
[32m+[m
[32m+[m[32m5. Change directory[m
[32m+[m[32mcd C:\WS_Mdl\code[m
 [m
[31m-5. **Re-build** env:[m
[31m-pixi run install --frozen # This uses both the pixi.lock and pixi.toml files to ensure reinstallation of locked package versions.[m
[31m-pixi run install # This only requires the pixi.toml file. It should work, but it's less secure.[m
[32m+[m[32m6. **Re-build** env:[m
[32m+[m[32mpixi install --frozen # This uses both the pixi.lock and pixi.toml files to ensure reinstallation of locked package versions.[m
[32m+[m[32mpixi install # This only requires the pixi.toml file. It should work, but it's less secure.[m
 [m
[31m-6. Optional: **WS_Mdl** lib:[m
[32m+[m[32m7. Optional: **WS_Mdl refresh**:[m
 pixi run --no-lockfile-update pip install -e C:\OD\WS_Mdl\code # (pip install -e C:\OD\WS_Mdl\code (--use-pep517 --no-build-isolation) could also work)[m
 Run this whenever you want to update WS_Mdl. It's in edit mode, so any small changes (e.g. code in exiting files) are updated automatically. I use this when I make a new terminal tool and I want to add it to path.[m
 [m
[36m@@ -48,13 +59,13 @@[m [mpixi add --pypi "rasterio>=1.3"[m
 3. **Solve & lock**[m
    pixi install          # updates pixi.lock[m
 [m
[31m-3. **Freeze**. Don't forget to add the changes to your next commit, e.g.:[m
[32m+[m[32m4. **Freeze**. Don't forget to add the changes to your next commit, e.g.:[m
    git add pixi.toml pixi.lock[m
    git commit -m "Add rasterio 1.3+"[m
 -----------------------------------------[m
 [m
 [m
[31m-# THE GUIDE BELOW IS THE OLD ONE. That way of env management applies from 04/08, NBr32, hash b5dfc2b backwards.[m
[32m+[m[32m# THE GUIDE BELOW IS THE OLD ONE. That way of env management was used for the last time on 04/08, NBr32, hash b5dfc2b.[m
 -----------------------------------------[m
 --- To freeze/export: ---[m
 The WS env should be frozen on every change. If no Env is present for a run/Sim you want to repeat, assume that the previous one will do the job.[m
[1mdiff --git a/code/Jupyter/imod_python_conversion/imod_python_init_NBr32.ipynb b/code/Jupyter/imod_python_conversion/imod_python_init_NBr32.ipynb[m
[1mindex 508eb1d..873a580 100644[m
[1m--- a/code/Jupyter/imod_python_conversion/imod_python_init_NBr32.ipynb[m
[1m+++ b/code/Jupyter/imod_python_conversion/imod_python_init_NBr32.ipynb[m
[36m@@ -1,5 +1,13 @@[m
 {[m
  "cells": [[m
[32m+[m[32m  {[m
[32m+[m[32m   "cell_type": "markdown",[m
[32m+[m[32m   "id": "1030510d",[m
[32m+[m[32m   "metadata": {},[m
[32m+[m[32m   "source": [[m
[32m+[m[32m    "# Execution Time monitoring"[m
[32m+[m[32m   ][m
[32m+[m[32m  },[m
   {[m
    "cell_type": "code",[m
    "execution_count": 1,[m
[36m@@ -187,7 +195,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 50,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "2db71674",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -197,7 +205,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 11,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f43af1a6",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -215,7 +223,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 12,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "1cc7e265",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -225,7 +233,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 13,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "48c0976f",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -235,18 +243,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 14,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "c8598a0a",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "âœ… Boundary conditions set successfully!\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Set outer boundaries to -1 (for CHD)\n",[m
     "\n",[m
[36m@@ -269,31 +269,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 15,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "b1ba325d",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "<matplotlib.image.AxesImage at 0x2ac9f4f8ec0>"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 15,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    },[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAlIAAAHFCAYAAAA5VBcVAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjUsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvWftoOwAAAAlwSFlzAAAPYQAAD2EBqD+naQAAYmtJREFUeJzt3Xlc1VX+P/DXFeGyxRVkVwRTQ5FUBJWLY7ixlYZN4xKFUopLOi5YM6GWiuNSmum42+RWjjhGjJVKoEnmT1AwMLRUcsOFC+VyUb+yCOf3h/EZr5f1XhDs83o+Hufx6J7P+ZzP+Rxu3XfnnM/5KIQQAkRERERUby2augFERERETyoGUkREREQGYiBFREREZCAGUkREREQGYiBFREREZCAGUkREREQGYiBFREREZCAGUkREREQGYiBFREREZCAGUtSszJs3DwqFoqmbUaV//etfGDZsGDw8PGBhYYGOHTti0qRJyM/P1yvr4eEBhUKhlyZOnFjn661atQqdO3eGUqlE+/btMX/+fJSVlTXkLQEAFAoF5s2b1+D1Npb8/HzMmTMHarUa9vb2sLGxga+vLzZu3Ijy8nKdsqmpqVX+HRQKBdLT0+t0vcLCQkRFRcHe3h6WlpZQq9U4cOCAwe2vbFNqaqrBdfxRfP311xg9ejSeffZZmJqaNtt/94lq0rKpG0D0pJg7dy4GDBiARYsWoU2bNjhz5gwWLFiA3bt3IysrC05OTjrl+/bti2XLlunkPVqmOgsXLsS7776Ld955B8HBwcjIyMCcOXNw9epVbNy4scHu6Ul0/PhxbNu2DaNHj8a7774LU1NT7Nu3D5MmTUJ6ejo2bdqkd86iRYswYMAAnTxvb+9ar1VSUoJBgwbh1q1bWLlyJRwdHbFmzRqEhoZi//79CAwMbLD7kqPExESkp6fDx8cHSqUSx48fb+omEdWfIGpG5s6dK5rr17KgoEAvLyMjQwAQCxYs0Ml3d3cXL7zwgkHX+e2334S5ubkYP368Tv7ChQuFQqEQp06dMqje6gAQc+fObdA6G9ONGzdEaWmpXv7kyZMFAJGXlyflHTx4UAAQu3btMuhaa9asEQDEkSNHpLyysjLh5eUlevfubVCdlW06ePCgQec3ttLSUlFWVvZYrlVeXi79c+Xfj+hJw6k9ajJ79uxBjx49pKmrR0dvACA+Ph4KhQKrV6/WyZ87dy5MTEyQkpLyuJoLR0dHvTxfX1+YmJjg8uXLDXadpKQkFBcX4/XXX9fJf/311yGEwH//+1+D6i0qKkJ0dDRat24Na2trhIaG4uzZszplvv/+eygUCuzYsUPv/G3btkGhUCAjI8Og6zcUW1tbmJqa6uX37t0bAHDlypUGu1ZiYiI8PT2hVqulvJYtW+K1117DsWPHcPXq1Qa5TmZmJkaNGiVNG3t4eOCVV17BpUuXpDIXL15Ey5YtsXjxYr3zDx06BIVCgV27dkl5ubm5iIiIgKOjI5RKJbp06YI1a9bonFc5zfjpp59i5syZaNOmDZRKJX755ZcGua/atGjBnyB68vFbTE3iwIEDCA8Px1NPPYX4+HgsXboU//nPf7B582adcqNGjcLEiRMxc+ZMZGZmAgC+/fZb/OMf/8CsWbMQFBRU43UqKipw//79WtOja2vq6rvvvkN5eTm6du2qd+zQoUN46qmnYGpqCi8vL3z44Yd1us7JkycBAM8++6xOvouLC+zt7aXj9SGEwLBhw6QfzMTERPj7+yMsLEynXL9+/eDj46P3gwsAq1evRq9evdCrV68ar1WX/r5//z6EEPW+j5p8++23aNmyJZ555hm9Y5MnT0bLli1hY2ODkJAQHD58uE51njx5Et26ddPLr8w7deqUcY3+3cWLF+Hp6YkVK1bgm2++wfvvv4/8/Hz06tULv/32G4AH6+5efPFFrF+/Xu97tHr1ari6uuKll14CAPz000/o1asXTp48iQ8//BBff/01XnjhBUydOhXz58/Xu35sbCzy8vKwfv16fPXVV1X+T0Ol8vLyOv19KyoqGqRviJq9Jh4RI5nq06ePcHV1Fffu3ZPyioqKhJ2dnd7wfnFxsfDx8RHt27cXP/30k3BychKBgYHi/v37tV5nzJgxAkCtKTAwsN73UFRUJLp06SLc3NzE7du3dY69+eabYtOmTeK7774T//3vf8Wrr74qAIjXXnut1nqjo6OFUqms8tgzzzwjgoOD693Wffv2CQBi5cqVOvkLFy7Um9rbvHmzACCysrKkvGPHjgkAYuvWrTVe58KFC3XqbzTw1NY333wjWrRoIWbMmKGT/8MPP4hp06aJxMREcejQIbFp0ybRpUsXYWJiIpKSkmqt19TUVEyYMEEv/8iRIwKA+Pe//13vttZlau/+/fvizp07wsrKSudvVnluYmKilHf16lXRsmVLMX/+fCkvJCREtG3bVmi1Wp16p0yZIszNzcWNGzd06nvuuefq3H53d/c6/X3rO13MqT16UnGxOT12d+/eRUZGBt58802Ym5tL+U899RSGDh2KrVu36pRXKpX4z3/+A19fX/Ts2RM2NjbYsWMHTExMar3WvHnzMGXKlFrLPfXUU/W6h+LiYvz5z3/GpUuX8O2338La2lrn+KMjOuHh4bC1tcXq1asRExMDHx+fGuuv6eklQ55sOnjwIADg1Vdf1cmPiIjA7NmzdfJeeeUV/P3vf8eaNWvw8ccfA3jwBKGDgwNGjhxZ43VcXV3rPPXn6elZ4/Hy8nKdUasWLVpUORX0ww8/YMSIEfD399eb9vLx8dHp6379+uGll17Cs88+i7/97W8ICQmptZ0N/beoyp07d7BgwQIkJCTg4sWLOiNOP//8s/TP/fv3R/fu3bFmzRoMGzYMALB+/XooFAqMHz8ewIPv5oEDBzBp0iRYWlri/v370vnPP/88Vq9ejfT0dJ3RyJdffrnObf3qq69QUlJSazlXV9c610n0JGMgRY/dzZs3UVFRAWdnZ71jVeUBQMeOHdGvXz/s2bMHkyZNgouLS52u1a5dO7Rt27bWcvX5QSwpKcFLL72Ew4cP4+uvv0afPn3qdN5rr70m/YjVFEi1bt0axcXF+L//+z9YWlrqHLtx4wZ8fX3r3NZK169fR8uWLdG6dWud/Kr6W6lUYsKECfjwww+xdOlSlJWV4T//+Q9iYmKgVCprvI6ZmRl69OhRpzbVFgh36NBBZ43Q3Llz9bZpyMrKQlBQEDp16oS9e/fW2j4AaNWqFYYMGYL169fj3r17sLCwqLZs69atcf36db38GzduAADs7OxqvV5dRERE4MCBA3j33XfRq1cv2NjYQKFQ4Pnnn8e9e/d0yk6dOhXjxo3DmTNn8PTTT+Pjjz/GX/7yF+lvef36ddy/fx+rVq3CqlWrqrxe5XRhpbr++wQAXl5edZqW5fonkgsGUvTY2draQqFQQKPR6B2rKg94sIfTnj170Lt3b6xevRojR46sUwDzxhtv6I1wVSUwMLBO+/qUlJRg2LBhOHjwIHbv3o1BgwbVek6lyh+f2n5gKtdG5eTk6NyjRqPBb7/9VqfH9h/VunVr3L9/H9evX9cJpqrr70mTJmHJkiXYtGkTiouLcf/+/TrtgXXx4kW0b9++Tm06ePAg+vfvX+3xR0c+Hh3hyMrKwuDBg+Hu7o7k5GSoVKo6XRf439+itgD62WefRU5Ojl5+ZZ4hf4tHabVafP3115g7dy7eeecdKb+kpEQK2B4WEREhjRj6+/tDo9Fg8uTJ0nFbW1uYmJggMjJSJ/9hj/6N6vM/Eo8GuNWpKvAl+iNiIEWPnZWVFXr37o0vvvgCS5culab3bt++ja+++kqvfE5ODqZOnYrRo0fj448/RkBAAEaOHImsrCzY2trWeK2GnNqrHIn69ttv8cUXX9RpWuhh27ZtAwD4+/vXWC40NBTm5ubYsmWLTiC1ZcsWKBQKaUqnPgYMGIAPPvgA27dvx9SpU6X8f//731WWd3FxwfDhw7F27VqUlpZi6NChaNeuXa3XacipvUcX2z8sOzsbgwcPRtu2bZGSklLr9+BhN2/exNdff40ePXroTC1X5aWXXsKbb76Jo0ePSn+L+/fv47PPPkOfPn0aZPpKoVBACKE3mvavf/2ryocTzM3NMX78eKxevRpHjhxBjx490LdvX+m4paUlBgwYgKysLHTr1g1mZmZGt/FhnNojekSTrtAi2UpOThYtWrQQf/rTn0RiYqL4/PPPRa9evYSbm5vOgtM7d+6Izp07Cy8vL3Hnzh0hhBDnzp0TKpVKhIeHP9Y2DxkyRAAQs2fPFmlpaTrp4b2dtm/fLl5++WWxadMmceDAAZGQkCBGjRolAIioqCidOlNTU4WJiYnOQmEhhPjHP/4hFAqFmDVrlkhNTRVLly4VSqVSREdH65SrXNw9ZsyYGtteXl4unnvuOaFUKsWiRYtEcnKymDt3rnj66aerXRh89OhRaeHw/v3769dZjej06dOidevWws7OTnz11Vd6f4vCwkKp7CuvvCL+/ve/i127domDBw+KjRs3Ck9PT9GyZUuRkpKiU+8bb7whTExMxMWLF6W84uJi0bVrV+Hm5ia2b98uUlJSxEsvvSRatmwpUlNTdc6v3AOttkX0VS02f+6554SdnZ34+OOPRUpKipgzZ45wcXERrVq1qvJve+XKFdGyZUsBQPzrX//SO37q1Clha2srevfuLTZv3iwOHjwovvzyS7F8+XIxYMAAvbYYus+WsS5evCh27doldu3aJUJDQ6W27Nq1S2RkZDRJm4jqi4EUNZkvv/xSdOvWTZiZmYl27dqJJUuW6G3I+dprrwlLS0u9TSh37dolAIiPPvrosbUXNTyh9PBTf2lpaWLQoEHC2dlZmJqaCktLS9GrVy+xdu1anQ0IhfjfD1lVgczKlSvFM888I/XP3Llz9TaizMnJEQDEO++8U2v7b926Jd544w3RqlUrYWlpKYKCgsTp06drfMLKw8NDdOnSpda6H6fKpwqrS5s3b5bKLl68WPTo0UOoVCphYmIiHBwcxEsvvSSOHTumV2/lE54XLlzQyddoNGL06NHCzs5OmJubC39/f70gTAghZs6cKRQKhfj5559rbH9VgdSVK1fEyy+/LGxtbcVTTz0lQkNDxcmTJ4W7u3u1QXL//v2FnZ2d+L//+78qj1+4cEG88cYbok2bNsLU1FQ4ODiIgIAA8Y9//EOvLU0VSNX0t6ztfw6ImguFEA28mQsRPTZr167F3/72N5w7d67Or5+pqx9//FF6QuzNN99s0Lr/iHr37g13d3edTTEbS2FhIdzd3fHXv/4VH3zwQaNfj4iqx0CK6Ak2fPhwdOrUCYsWLWqwOs+dO4dLly5h1qxZyMvLwy+//KL39CDpKioqgoODA7Kzs9GlS5dGu86VK1dw/vx5LF26FN9++y3Onj2LNm3aNNr1iKh2XGxO9ARrjNGPBQsW4NNPP0WXLl2wa9cuBlF1YGNjU6cF2Mb617/+hbi4OHh4eGD79u0MooiaAY5IERERERmoSXdMW7duHbp16wYbGxvY2NhArVZj37590vGCggJERUXB1dUVlpaWCA0NRW5url49aWlpGDhwIKysrNCqVSv0799f2sTu4sWLGDt2LNq3bw8LCwt06NABc+fORWlpqU4deXl5GDp0KKysrGBvb4+pU6fqlcnJyUFgYCAsLCzQpk0bxMXFNfj7woiIiOTg0KFDGDp0KFxdXaFQKOr0QvbvvvsOvr6+MDc3x9NPP43169frlUlISICXlxeUSiW8vLyQmJjYCK3/nyYNpNq2bYslS5YgMzMTmZmZGDhwIMLDw3Hq1CnpJavnz5/H7t27kZWVBXd3dwwePBh3796V6khLS0NoaCiCg4Nx7NgxZGRkYMqUKdKmh6dPn0ZFRQU2bNiAU6dO4aOPPsL69esxa9YsqY7y8nK88MILuHv3Lg4fPoz4+HgkJCRg5syZUpmioiIEBQVJ++SsWrUKy5Ytw/Llyx9fhxEREf1B3L17F927d8fq1avrVP7ChQt4/vnn0a9fP2RlZWHWrFmYOnUqEhISpDJpaWkYOXIkIiMjceLECURGRmLEiBE4evRoY91G89tHytbWVvzrX/8SZ86cEQDEyZMnpWP379+X9lqp1KdPHzFnzpx6XeODDz4Q7du3lz7v3btXtGjRQly9elXK27Fjh1AqldJLP9euXStUKpUoLi6WyixevFi4urqKioqKet8nERERPYBHXsZdlb/97W+ic+fOOnkTJkwQ/v7+0ucRI0aI0NBQnTIhISFi1KhRDdbWRzWbxebl5eXYtWsX7t69C7VaLS3cfHjnYRMTE5iZmeHw4cMYN24cCgsLcfToUbz66qsICAjAuXPn0LlzZyxcuBB/+tOfqr2WVqvVeUdWWloavL29dXbiDQkJQUlJCY4fP44BAwYgLS0NgYGBOrsPh4SEIDY2tsbXYpSUlOgsQq2oqMCNGzfQunXrBnvhKRER/fEIIXD79m24uro26rsLi4uL9ZayGEoIoffbplQq6/QezNqkpaUhODhYJy8kJASffPIJysrKYGpqirS0NMyYMUOvzIoVK4y+fnWaPJDKycmBWq1GcXExrK2tkZiYCC8vL5SVlcHd3R2xsbHYsGEDrKyssHz5cmg0GuTn5wMAzp8/D+DBa0CWLVuGHj16YNu2bRg0aBBOnjyJTp066V3v3LlzWLVqFT788EMpT6PR6O3BY2trCzMzM+ldZBqNBh4eHjplKs/RaDTVBlKLFy/G/PnzDescIiKSvcuXL9fp5euGKC4uRnt3a2gK9V9HZAhra2vcuXNHJ6+h3rtY1W+1k5MT7t+/j99++w0uLi7VlqnuvaINockDKU9PT2RnZ+PWrVtISEjAmDFj8N1338HLywsJCQkYO3Ys7OzsYGJigsGDByMsLEw6t6KiAgAwYcIEvP766wAAHx8fHDhwAJs2bcLixYt1rnXt2jWEhoZi+PDhGDdunM6xqkaHHo2sHy0j6vDi09jYWMTExEiftVot2rVrhz/hebSEaY19Q0RE8nUfZTiMvXV6F6ihSktLoSksx6XjHrB5yrhRr6LbFXD3vYjLly/DxsZGym+I0ahKdfkdrqpMY84ANXkgZWZmho4dOwIA/Pz8kJGRgZUrV2LDhg3w9fVFdnY2tFotSktL4eDggD59+sDPzw/AgxerAoCXl5dOnV26dEFeXp5O3rVr1zBgwACo1Wps3LhR55izs7PeQrSbN2+irKxMimydnZ31ItrCwkIAqHFH6eqGNFvCFC0VDKSIiKgavz8U/jiWgVg/pYD1U8ZdpwIPzq98Er+hVfc73LJlS7Ru3brGMg395oeHNelTe1URQuhtbKdSqeDg4IDc3FxkZmYiPDwcAODh4QFXV1ecOXNGp/zZs2fh7u4ufb569Sr69++Pnj17YvPmzXpzzWq1GidPnpSmDAEgOTkZSqUSvr6+UplDhw7pzCMnJyfD1dVVb8qPiIjoSVIuKhokNSa1Wo2UlBSdvOTkZPj5+cHU1LTGMgEBAY3WriYdkZo1axbCwsLg5uaG27dvIz4+HqmpqUhKSgLwYNdmBwcHtGvXDjk5OZg2bRqGDRsmLTZTKBR4++23MXfuXHTv3h09evTA1q1bcfr0aXz++ecAHoxE9e/fH+3atcOyZcvw66+/Std3dnYGAAQHB8PLywuRkZFYunQpbty4gbfeegvR0dFSVB0REYH58+cjKioKs2bNQm5uLhYtWoT33nuPi8aJiOiJVgGBChi3L2J9z79z5w5++eUX6fOFCxeQnZ0NOzs7tGvXDrGxsbh69Sq2bdsGAJg4cSJWr16NmJgYREdHIy0tDZ988gl27Ngh1TFt2jQ899xzeP/99xEeHo7du3dj//79OHz4sFH3VpMmDaQKCgoQGRmJ/Px8qFQqdOvWDUlJSQgKCgIA5OfnIyYmBgUFBXBxccHo0aPx7rvv6tQxffp0FBcXY8aMGbhx4wa6d++OlJQUdOjQAcCDSPSXX37BL7/8ordYr3Ju1cTEBHv27MGbb76Jvn37wsLCAhEREVi2bJlUVqVSISUlBZMnT4afnx9sbW0RExOjs/6JiIiI6iYzMxMDBgyQPlf+no4ZMwZbtmxBfn6+zjKd9u3bY+/evZgxYwbWrFkDV1dX/POf/8TLL78slQkICEB8fDzmzJmDd999Fx06dMDOnTvRp0+fRrsPviLmMSsqKoJKpUJ/hHONFBERVeu+KEMqdkOr1TbKmiPgf79J1860bZDF5q6eVxq1vc1Rky82JyIioqZVLgTKjRxXMfb8J1WzW2xORERE9KTgiBQREZHMNcVi8z8KBlJEREQyVwGBcgZSBuHUHhEREZGBOCJFREQkc5zaMxwDKSIiIpnjU3uG49QeERERkYE4IkVERCRzFb8nY+uQIwZSREREMlfeAE/tGXv+k4qBFBERkcyViwfJ2DrkiGukiIiIiAzEESkiIiKZ4xopwzGQIiIikrkKKFAOhdF1yBGn9oiIiIgMxBEpIiIimasQD5KxdcgRAykiIiKZK2+AqT1jz39ScWqPiIiIyEAckSIiIpI5jkgZjoEUERGRzFUIBSqEkU/tGXn+k4pTe0REREQG4ogUERGRzHFqz3AMpIiIiGSuHC1QbuQkVXkDteVJw0CKiIhI5kQDrJESXCNFRERERPXBESkiIiKZ4xopwzGQIiIikrly0QLlwsg1UjJ9RQyn9oiIiIgMxBEpIiIimauAAhVGjq1UQJ5DUgykiIiIZI5rpAzHQIr0fHMtu6mbQEQke0W3K2D7TFO3gmrDQIqIiEjmGmaxOaf2iIiISIYerJEy8qXFMp3a41N7RERERAbiiBQREZHMVTTAu/bk+tQeR6SIiIhkrnKNlLGpvtauXYv27dvD3Nwcvr6++P7776stGxUVBYVCoZe6du0qldmyZUuVZYqLiw3ql7pgIEVERCRzFWjRIKk+du7cienTp2P27NnIyspCv379EBYWhry8vCrLr1y5Evn5+VK6fPky7OzsMHz4cJ1yNjY2OuXy8/Nhbm5ucN/UhoEUERERPXbLly/H2LFjMW7cOHTp0gUrVqyAm5sb1q1bV2V5lUoFZ2dnKWVmZuLmzZt4/fXXdcopFAqdcs7Ozo16HwykiIiIZK5cKBokAUBRUZFOKikp0bteaWkpjh8/juDgYJ384OBgHDlypE5t/uSTTzB48GC4u7vr5N+5cwfu7u5o27YthgwZgqysLAN7pW4YSBEREclc+e+LzY1NAODm5gaVSiWlxYsX613vt99+Q3l5OZycnHTynZycoNFoam1vfn4+9u3bh3Hjxunkd+7cGVu2bMGXX36JHTt2wNzcHH379kVubq4RvVMzPrVHREREDeby5cuwsbGRPiuVymrLKhS6e08JIfTyqrJlyxa0atUKw4YN08n39/eHv7+/9Llv377o2bMnVq1ahX/+8591vIP6YSBFREQkcxWiBSqM3Nm84vedzW1sbHQCqarY29vDxMREb/SpsLBQb5TqUUIIbNq0CZGRkTAzM6uxbIsWLdCrV69GHZHi1B4REZHMNeTUXl2YmZnB19cXKSkpOvkpKSkICAio8dzvvvsOv/zyC8aOHVvrdYQQyM7OhouLS53bVl8ckSIiIqLHLiYmBpGRkfDz84NarcbGjRuRl5eHiRMnAgBiY2Nx9epVbNu2Tee8Tz75BH369IG3t7denfPnz4e/vz86deqEoqIi/POf/0R2djbWrFnTaPfBQIqIiEjmKgDpqTtj6qiPkSNH4vr164iLi0N+fj68vb2xd+9e6Sm8/Px8vT2ltFotEhISsHLlyirrvHXrFsaPHw+NRgOVSgUfHx8cOnQIvXv3NuSW6kQhhExf19xEioqKoFKp0B/haKkwbermVOmba9lN3QQiItkrul0B22fOQ6vV1rrmyOBr/P6btO6HXrCwNm5s5d6d+5jUM6NR29sccY0UERERkYE4tUdERCRzhr4r79E65IiBFBERkcxVQIEKGLtGyrjzn1QMpIiIiGSOI1KGk+ddExERETUAjkgRERHJXH031KyuDjliIEVERCRzFUKBCmP3kTLy/CeVPMNHIiIiogbAESkiIiKZq2iAqb0KmY7NMJAiIiKSuQrRAhVGPnVn7PlPKnneNREREVED4IgUERGRzJVDgXIjN9Q09vwnFQMpIiIimePUnuHkeddEREREDYAjUkRERDJXDuOn5sobpilPHAZSREREMsepPcMxkCIiIpI5vrTYcE161+vWrUO3bt1gY2MDGxsbqNVq7Nu3TzpeUFCAqKgouLq6wtLSEqGhocjNzdWrJy0tDQMHDoSVlRVatWqF/v374969e9LxhQsXIiAgAJaWlmjVqlWVbVEoFHpp/fr1OmVycnIQGBgICwsLtGnTBnFxcRBCNExnEBER0ROnSUek2rZtiyVLlqBjx44AgK1btyI8PBxZWVnw8vLCsGHDYGpqit27d8PGxgbLly/H4MGD8dNPP8HKygrAgyAqNDQUsbGxWLVqFczMzHDixAm0aPG/GLG0tBTDhw+HWq3GJ598Um17Nm/ejNDQUOmzSqWS/rmoqAhBQUEYMGAAMjIycPbsWURFRcHKygozZ85s6K4hIiJ6bAQUqDByjZTg9geP39ChQ3U+L1y4EOvWrUN6ejpMTU2Rnp6OkydPomvXrgCAtWvXwtHRETt27MC4ceMAADNmzMDUqVPxzjvvSPV06tRJp9758+cDALZs2VJje1q1agVnZ+cqj23fvh3FxcXYsmULlEolvL29cfbsWSxfvhwxMTFQKOT5BSIioicfp/YM12zuury8HPHx8bh79y7UajVKSkoAAObm5lIZExMTmJmZ4fDhwwCAwsJCHD16FI6OjggICICTkxMCAwOl4/U1ZcoU2Nvbo1evXli/fj0qKiqkY2lpaQgMDIRSqZTyQkJCcO3aNVy8eLHaOktKSlBUVKSTiIiI6I+hyQOpnJwcWFtbQ6lUYuLEiUhMTISXlxc6d+4Md3d3xMbG4ubNmygtLcWSJUug0WiQn58PADh//jwAYN68eYiOjkZSUhJ69uyJQYMGVbmWqiYLFizArl27sH//fowaNQozZ87EokWLpOMajQZOTk4651R+1mg01da7ePFiqFQqKbm5udWrXURERI2tQigaJMlRkz+15+npiezsbNy6dQsJCQkYM2YMvvvuO3h5eSEhIQFjx46FnZ0dTExMMHjwYISFhUnnVo4YTZgwAa+//joAwMfHBwcOHMCmTZuwePHiOrdjzpw50j/36NEDABAXF6eT/+j0XeVC85qm9WJjYxETEyN9LioqYjBFRETNSjlaoNzIsRVjz39SNXkgZWZmJi029/PzQ0ZGBlauXIkNGzbA19cX2dnZ0Gq1KC0thYODA/r06QM/Pz8AgIuLCwDAy8tLp84uXbogLy/PqHb5+/ujqKgIBQUFcHJygrOzs97IU2FhIQDojVQ9TKlU6kwHEhER0R9HswsfhRDS+qhKKpUKDg4OyM3NRWZmJsLDwwEAHh4ecHV1xZkzZ3TKnz17Fu7u7ka1IysrC+bm5tJ2CWq1GocOHUJpaalUJjk5Ga6urvDw8DDqWkRERE2JU3uGa9IRqVmzZiEsLAxubm64ffs24uPjkZqaiqSkJADArl274ODggHbt2iEnJwfTpk3DsGHDEBwcDODBlNrbb7+NuXPnonv37ujRowe2bt2K06dP4/PPP5euk5eXhxs3biAvLw/l5eXIzs4GAHTs2BHW1tb46quvoNFooFarYWFhgYMHD2L27NkYP368NJoUERGB+fPnIyoqCrNmzUJubi4WLVqE9957j0/sERHRE60CLVBh5NiKsec/qZo0kCooKEBkZCTy8/OhUqnQrVs3JCUlISgoCACQn5+PmJgYFBQUwMXFBaNHj8a7776rU8f06dNRXFyMGTNm4MaNG+jevTtSUlLQoUMHqcx7772HrVu3Sp99fHwAAAcPHkT//v1hamqKtWvXIiYmBhUVFXj66acRFxeHyZMnS+eoVCqkpKRg8uTJ8PPzg62tLWJiYnTWPxEREZG8KAS35n6sioqKoFKp0B/haKkwbermVOmba9lN3QQiItkrul0B22fOQ6vVwsbGpnGu8ftv0qTv/wyltXG/SSV3yrCu3xeN2t7mqMkXmxMREVHTaog1TlwjRURERLIkRAtUGLkzueDO5kRERERUHxyRIiIikrlyKFBu5EuHjT3/ScVAioiISOYqhPFrnCpk+ugap/aIiIiIDMQRKSIiIpmraIDF5sae/6SS510TERGRpAKKBkn1tXbtWrRv3x7m5ubw9fXF999/X23Z1NRUKBQKvXT69GmdcgkJCfDy8oJSqYSXlxcSExPr3a76YCBFREREj93OnTsxffp0zJ49G1lZWejXrx/CwsKQl5dX43lnzpxBfn6+lDp16iQdS0tLw8iRIxEZGYkTJ04gMjISI0aMwNGjRxvtPhhIERERyVy5UDRIqo/ly5dj7NixGDduHLp06YIVK1bAzc0N69atq/E8R0dHODs7S8nExEQ6tmLFCgQFBSE2NhadO3dGbGwsBg0ahBUrVhjSLXXCQIqIiEjmKtdIGZvqqrS0FMePH0dwcLBOfnBwMI4cOVLjuT4+PnBxccGgQYNw8OBBnWNpaWl6dYaEhNRapzG42JyIiIgaTFFRkc5npVIJpVKpk/fbb7+hvLwcTk5OOvlOTk7QaDRV1uvi4oKNGzfC19cXJSUl+PTTTzFo0CCkpqbiueeeAwBoNJp61dkQGEgRERHJXAUa4F17vy82d3Nz08mfO3cu5s2bV+U5CoXuNYUQenmVPD094enpKX1Wq9W4fPkyli1bJgVS9a2zITCQIiIikjlh4FN3j9YBAJcvX4aNjY2U/+hoFADY29vDxMREb6SosLBQb0SpJv7+/vjss8+kz87OzkbXWV9cI0VERCRzFULRIAkAbGxsdFJVgZSZmRl8fX2RkpKik5+SkoKAgIA6tzsrKwsuLi7SZ7VarVdncnJyveqsL45IERER0WMXExODyMhI+Pn5Qa1WY+PGjcjLy8PEiRMBALGxsbh69Sq2bdsG4METeR4eHujatStKS0vx2WefISEhAQkJCVKd06ZNw3PPPYf3338f4eHh2L17N/bv34/Dhw832n0wkCIiIpK5ptjZfOTIkbh+/Tri4uKQn58Pb29v7N27F+7u7gCA/Px8nT2lSktL8dZbb+Hq1auwsLBA165dsWfPHjz//PNSmYCAAMTHx2POnDl499130aFDB+zcuRN9+vQx6t5qohBCyPQ1g02jqKgIKpUK/RGOlgrTpm5Olb65lt3UTSAikr2i2xWwfeY8tFqtzpqjBr3G779J4clvwNTKzKi6yu6WYnfwpkZtb3PENVJEREREBuLUHhERkcwZ+q68R+uQIwZSREREMvfwU3fG1CFHnNojIiIiMhBHpIiIiGSOI1KGYyBFREQkcwykDMepPSIiIiIDcUSKiIhI5jgiZTgGUkRERDInYPz2BXLd3ZuBFBERkcxxRMpwXCNFREREZCCOSBEREckcR6QMx0CKiIhI5hhIGY5Te0REREQG4ogUERGRzHFEynAMpIiIiGROCAWEkYGQsec/qTi1R0RERGQgjkgRERHJXAUURm/Iaez5TyoGUkRERDLHNVKG49QeERERkYE4IkVERCRzXGxuOAZSREREMsepPcMxkCIiIpI5jkgZjmukiIiIiAzEESkiIiKZEw0wtSfXESkGUkRERDInAAhhfB1yxKk9IiIiIgNxRIqIiEjmKqCAgjubG4SBFBERkczxqT3DcWqPiIiIyEAckSIiIpK5CqGAghtyGoSBFBERkcwJ0QBP7cn0sT1O7REREREZiCNSREREMsfF5oZjIEVERCRzDKQMx6k9IiIimav4/RUxxqb6Wrt2Ldq3bw9zc3P4+vri+++/r7bsF198gaCgIDg4OMDGxgZqtRrffPONTpktW7ZAoVDopeLi4nq3ra4YSBEREdFjt3PnTkyfPh2zZ89GVlYW+vXrh7CwMOTl5VVZ/tChQwgKCsLevXtx/PhxDBgwAEOHDkVWVpZOORsbG+Tn5+skc3PzRrsPTu0RERHJXFM8tbd8+XKMHTsW48aNAwCsWLEC33zzDdatW4fFixfrlV+xYoXO50WLFmH37t346quv4OPjI+UrFAo4OzvXu/2G4ogUERGRzD0IpBRGprpfr7S0FMePH0dwcLBOfnBwMI4cOVKnOioqKnD79m3Y2dnp5N+5cwfu7u5o27YthgwZojdi1dAYSBEREVGDKSoq0kklJSV6ZX777TeUl5fDyclJJ9/JyQkajaZO1/nwww9x9+5djBgxQsrr3LkztmzZgi+//BI7duyAubk5+vbti9zcXONuqgYMpIiIiGTO+NGo/z315+bmBpVKJaWqpukqKRS6C9SFEHp5VdmxYwfmzZuHnTt3wtHRUcr39/fHa6+9hu7du6Nfv374z3/+g2eeeQarVq0ysGdqxzVSREREMid+T8bWAQCXL1+GjY2NlK9UKvXK2tvbw8TERG/0qbCwUG+U6lE7d+7E2LFjsWvXLgwePLjGsi1atECvXr04IkVERERPBhsbG51UVSBlZmYGX19fpKSk6OSnpKQgICCg2rp37NiBqKgo/Pvf/8YLL7xQa1uEEMjOzoaLi0v9b6SOOCJFREQkc02xIWdMTAwiIyPh5+cHtVqNjRs3Ii8vDxMnTgQAxMbG4urVq9i2bRuAB0HU6NGjsXLlSvj7+0ujWRYWFlCpVACA+fPnw9/fH506dUJRURH++c9/Ijs7G2vWrDHq3mrCQIqIiEjuGnJur45GjhyJ69evIy4uDvn5+fD29sbevXvh7u4OAMjPz9fZU2rDhg24f/8+Jk+ejMmTJ0v5Y8aMwZYtWwAAt27dwvjx46HRaKBSqeDj44NDhw6hd+/eRt5c9Zp0am/dunXo1q2bNPynVquxb98+6XhBQQGioqLg6uoKS0tLhIaGVjnPmZaWhoEDB8LKygqtWrVC//79ce/ePen4woULERAQAEtLS7Rq1arKtuTl5WHo0KGwsrKCvb09pk6ditLSUp0yOTk5CAwMhIWFBdq0aYO4uDgIub7umoiI/jgaYqG5ASNab775Ji5evIiSkhIcP34czz33nHRsy5YtSE1NlT6npqZCCKGXKoMoAPjoo49w6dIllJSUoLCwEN988w3UarUxPVOrJg2k2rZtiyVLliAzMxOZmZkYOHAgwsPDcerUKQghMGzYMJw/fx67d+9GVlYW3N3dMXjwYNy9e1eqIy0tDaGhoQgODsaxY8eQkZGBKVOmoEWL/91aaWkphg8fjkmTJlXZjvLycrzwwgu4e/cuDh8+jPj4eCQkJGDmzJlSmaKiIgQFBcHV1RUZGRlYtWoVli1bhuXLlzdeBxEREVGzphDNbEjFzs4OS5cuRb9+/eDp6YmTJ0+ia9euAB4EPI6Ojnj//felnVD9/f0RFBSEBQsW1Fr3li1bMH36dNy6dUsnf9++fRgyZAguX74MV1dXAEB8fDyioqJQWFgIGxsbrFu3DrGxsSgoKJAWzi1ZsgSrVq3ClStX6vS4JvAgIFOpVOiPcLRUmNa1Wx6rb65lN3UTiIhkr+h2BWyfOQ+tVqvzFFyDXuP336T2m2ejhaVxr1Gp+L9iXHh9YaO2tzlqNk/tlZeXIz4+Hnfv3oVarZY28Hr4/TgmJiYwMzPD4cOHATx4TPLo0aNwdHREQEAAnJycEBgYKB2vq7S0NHh7e0tBFACEhIRIQ42VZQIDA3WePggJCcG1a9dw8eLFausuKSnR25yMiIioOWnIfaTkpskDqZycHFhbW0OpVGLixIlITEyEl5cXOnfuDHd3d8TGxuLmzZsoLS3FkiVLoNFokJ+fDwA4f/48AGDevHmIjo5GUlISevbsiUGDBtVrzwiNRqO3b4WtrS3MzMykpwKqKlP5uaZdWBcvXqyzMZmbm1ud20VERETNW5MHUp6ensjOzkZ6ejomTZqEMWPG4KeffoKpqSkSEhJw9uxZ2NnZwdLSEqmpqQgLC4OJiQmAB+/ZAYAJEybg9ddfh4+PDz766CN4enpi06ZN9WpHVVNzj+6wWtUOrNWdWyk2NhZarVZKly9frle7iIiIGl3lYnFjkww1+fYHZmZm6NixIwDAz88PGRkZWLlyJTZs2ABfX19kZ2dDq9WitLQUDg4O6NOnD/z8/ABA2mDLy8tLp84uXbroPDJZG2dnZxw9elQn7+bNmygrK5NGnZydnavcgRVAjbuwKpXKKjcjIyIiai4evLTY+DrkqMlHpB4lhNB7waFKpYKDgwNyc3ORmZmJ8PBwAICHhwdcXV1x5swZnfJnz56V9qGoC7VajZMnT0pThgCQnJwMpVIJX19fqcyhQ4d0tkRITk6Gq6srPDw86nubRERE9AfQpCNSs2bNQlhYGNzc3HD79m3Ex8cjNTUVSUlJAIBdu3bBwcEB7dq1Q05ODqZNm4Zhw4YhODgYwIMptbfffhtz585F9+7d0aNHD2zduhWnT5/G559/Ll0nLy8PN27cQF5eHsrLy5GdnQ0A6NixI6ytrREcHAwvLy9ERkZi6dKluHHjBt566y1ER0dLTx5ERERg/vz5iIqKwqxZs5Cbm4tFixbhvffeq/MTe0RERM1SE2zI+UfRpIFUQUEBIiMjkZ+fD5VKhW7duiEpKQlBQUEAHuxqGhMTg4KCAri4uGD06NF49913deqYPn06iouLMWPGDNy4cQPdu3dHSkoKOnToIJV57733sHXrVumzj48PAODgwYPo378/TExMsGfPHrz55pvo27cvLCwsEBERgWXLlknnqFQqpKSkYPLkyfDz84OtrS1iYmIQExPTmF1ERETU6JriFTF/FM1uH6k/Ou4jRUREdfE495Fqt/G9BtlHKm98nOz2kWryxeZERETUDHBYxSAMpIiIiGSOU3uGYyBFREQkd1xsbrBmt/0BERER0ZOCI1JERESyp/g9GVuH/DCQIiIikjtO7RmMU3tEREREBuKIFBERkdxxRMpgDKSIiIjkTigeJGPrkCFO7REREREZiCNSREREMifEg2RsHXLEQIqIiEjuuEbKYJzaIyIiIjIQR6SIiIjkjovNDcZAioiISOYU4kEytg45YiBFREQkd1wjZTCukSIiIiIyEEekiIiI5I5rpAzGQIqIiEjuOLVnME7tERERERmII1JERERyxxEpgzGQIiIikjsGUgbj1B4RERGRgTgiRUREJHd8as9gDKSIiIhkjjubG45Te0REREQGYiBFREQkd6KBUj2tXbsW7du3h7m5OXx9ffH999/XWP67776Dr68vzM3N8fTTT2P9+vV6ZRISEuDl5QWlUgkvLy8kJibWv2H1UO9AKioqCocOHWqMthAREZFM7Ny5E9OnT8fs2bORlZWFfv36ISwsDHl5eVWWv3DhAp5//nn069cPWVlZmDVrFqZOnYqEhASpTFpaGkaOHInIyEicOHECkZGRGDFiBI4ePdpo96EQQtQrhnz55ZexZ88euLm54fXXX8eYMWPQpk2bxmrfH05RURFUKhX6IxwtFaZN3ZwqfXMtu6mbQEQke0W3K2D7zHlotVrY2Ng0zjV+/01yf/8faGFublRdFcXFuPT3OXVub58+fdCzZ0+sW7dOyuvSpQuGDRuGxYsX65X/+9//ji+//BI///yzlDdx4kScOHECaWlpAICRI0eiqKgI+/btk8qEhobC1tYWO3bsMOb2qlXvEamEhARcvXoVU6ZMwa5du+Dh4YGwsDB8/vnnKCsra4w2EhER0ROiqKhIJ5WUlOiVKS0txfHjxxEcHKyTHxwcjCNHjlRZb1paml75kJAQZGZmSvFHdWWqq7MhGLRGqnXr1pg2bRqysrJw7NgxdOzYEZGRkXB1dcWMGTOQm5vb0O0kIiKixlK5/YGxCYCbmxtUKpWUqhpd+u2331BeXg4nJyedfCcnJ2g0miqbqNFoqix///59/PbbbzWWqa7OhmDU9gf5+flITk5GcnIyTExM8Pzzz+PUqVPw8vLCBx98gBkzZjRUO4mIiKixNODO5pcvX9aZ2lMqldWeolDo7j0lhNDLq638o/n1rdNY9Q6kysrK8OWXX2Lz5s1ITk5Gt27dMGPGDLz66qt46qmnAADx8fGYNGkSAykiIiKZsbGxqXWNlL29PUxMTPRGigoLC/VGlCo5OztXWb5ly5Zo3bp1jWWqq7Mh1Htqz8XFBdHR0XB3d8exY8eQmZmJiRMnSkEU8GA+slWrVg3ZTiIiImosj3n7AzMzM/j6+iIlJUUnPyUlBQEBAVWeo1ar9conJyfDz88PpqamNZaprs6GUO8RqY8++gjDhw+HeQ2r+21tbXHhwgWjGkZERESPR1PsbB4TE4PIyEj4+flBrVZj48aNyMvLw8SJEwEAsbGxuHr1KrZt2wbgwRN6q1evRkxMDKKjo5GWloZPPvlE52m8adOm4bnnnsP777+P8PBw7N69G/v378fhw4eNu7ka1DuQioyMbIx2EBERkYyMHDkS169fR1xcHPLz8+Ht7Y29e/fC3d0dwIN12A/vKdW+fXvs3bsXM2bMwJo1a+Dq6op//vOfePnll6UyAQEBiI+Px5w5c/Duu++iQ4cO2LlzJ/r06dNo91HvfaTIONxHioiI6uJx7iPl8Y+FDbKP1MU5sxu1vc0RX1pMREQkdw341J7c8F17RERERAbiiBQREZHMNcVi8z8KBlJERERy99DO5EbVIUMMpIiIiOSOa6QMxjVSRERERAbiiBQREZHMcY2U4RhIERERyR2n9gzGqT0iIiIiA3FEioiISO4aYGpPriNSDKSIiIjkjlN7BuPUHhEREZGBOCJFREQkdxyRMhgDKSIiIpnj9geG49QeERERkYEYSBEREREZiFN7REREcsc1UgZjIEVERCRzXCNlOE7tERERERmII1JEREQk26k5YzGQIiIikjuukTIYp/aIiIiIDMQRKSIiIpnjYnPDMZAiIiKSO07tGYxTe0REREQG4ogUERGRzHFqz3BNOiK1bt06dOvWDTY2NrCxsYFarca+ffuk4wUFBYiKioKrqyssLS0RGhqK3NxcvXrS0tIwcOBAWFlZoVWrVujfvz/u3bsnHb958yYiIyOhUqmgUqkQGRmJW7du6dShUCj00vr163XK5OTkIDAwEBYWFmjTpg3i4uIghEy/OURE9MchGijJUJOOSLVt2xZLlixBx44dAQBbt25FeHg4srKy4OXlhWHDhsHU1BS7d++GjY0Nli9fjsGDB+Onn36ClZUVgAdBVGhoKGJjY7Fq1SqYmZnhxIkTaNHifzFiREQErly5gqSkJADA+PHjERkZia+++kqnPZs3b0ZoaKj0WaVSSf9cVFSEoKAgDBgwABkZGTh79iyioqJgZWWFmTNnNlofERERUfPVpIHU0KFDdT4vXLgQ69atQ3p6OkxNTZGeno6TJ0+ia9euAIC1a9fC0dERO3bswLhx4wAAM2bMwNSpU/HOO+9I9XTq1En6559//hlJSUlIT09Hnz59AAAff/wx1Go1zpw5A09PT6lsq1at4OzsXGVbt2/fjuLiYmzZsgVKpRLe3t44e/Ysli9fjpiYGCgUiobpFCIioseNi80N1mwWm5eXlyM+Ph53796FWq1GSUkJAMDc3FwqY2JiAjMzMxw+fBgAUFhYiKNHj8LR0REBAQFwcnJCYGCgdBx4MGKlUqmkIAoA/P39oVKpcOTIEZ02TJkyBfb29ujVqxfWr1+PiooKnXoCAwOhVCqlvJCQEFy7dg0XL16s9r5KSkpQVFSkk4iIiJqTyjVSxiY5avJAKicnB9bW1lAqlZg4cSISExPh5eWFzp07w93dHbGxsbh58yZKS0uxZMkSaDQa5OfnAwDOnz8PAJg3bx6io6ORlJSEnj17YtCgQdJaKo1GA0dHR73rOjo6QqPRSJ8XLFiAXbt2Yf/+/Rg1ahRmzpyJRYsWScc1Gg2cnJx06qj8/HA9j1q8eLG0NkulUsHNzc3AniIiImokXCNlsCYPpDw9PZGdnY309HRMmjQJY8aMwU8//QRTU1MkJCTg7NmzsLOzg6WlJVJTUxEWFgYTExMAkEaMJkyYgNdffx0+Pj746KOP4OnpiU2bNknXqGraTQihkz9nzhyo1Wr06NEDM2fORFxcHJYuXapzzqP1VC40r2laLzY2FlqtVkqXL1+uZw8RERFRc9Xk2x+YmZlJi839/PyQkZGBlStXYsOGDfD19UV2dja0Wi1KS0vh4OCAPn36wM/PDwDg4uICAPDy8tKps0uXLsjLywMAODs7o6CgQO+6v/76q94I08P8/f1RVFSEgoICODk5wdnZWW/kqbCwEABqrEepVOpMBxIRETU7XCNlsCYfkXqUEEJaH1VJpVLBwcEBubm5yMzMRHh4OADAw8MDrq6uOHPmjE75s2fPwt3dHQCgVquh1Wpx7Ngx6fjRo0eh1WoREBBQbTuysrJgbm6OVq1aSfUcOnQIpaWlUpnk5GS4urrCw8PDmFsmIiJqUlwjZbgmHZGaNWsWwsLC4Obmhtu3byM+Ph6pqanSNgW7du2Cg4MD2rVrh5ycHEybNg3Dhg1DcHAwgAdTam+//Tbmzp2L7t27o0ePHti6dStOnz6Nzz//HMCD0anQ0FBER0djw4YNAB5sfzBkyBDpib2vvvoKGo0GarUaFhYWOHjwIGbPno3x48dLo0kRERGYP38+oqKiMGvWLOTm5mLRokV47733+MQeERGRTDXpiFRBQQEiIyPh6emJQYMG4ejRo0hKSkJQUBAAID8/H5GRkejcuTOmTp2KyMhI7NixQ6eO6dOnIzY2FjNmzED37t1x4MABpKSkoEOHDlKZ7du349lnn0VwcDCCg4PRrVs3fPrpp9JxU1NTrF27Fmq1Gt26dcPKlSsRFxeHDz/8UCqjUqmQkpKCK1euwM/PD2+++SZiYmIQExPTyL1ERETUyJr5YvO6bKz9sLKyMvz973/Hs88+CysrK7i6umL06NG4du2aTrn+/fvrbcY9atSoerVNIbg192NVVFQElUqF/ghHS4VpUzenSt9cy27qJhARyV7R7QrYPnMeWq0WNjY2jXON33+TukxZBBOlee0n1KC8pBg/r57VKO0NCwvDlStXsHHjRgAPZpY8PDz0NtaupNVq8Ze//AXR0dHo3r07bt68ienTp+P+/fvIzMyUyvXv3x/PPPMM4uLipDwLCwudDblr0+SLzYmIiIiqU5+NtStVziI9bNWqVejduzfy8vLQrl07Kd/S0rLazbjrotktNiciIqLHrAGn9h7dhPrRB8jqqz4ba9dEq9VCoVBID5FV2r59O+zt7dG1a1e89dZbuH37dr3axxEpIiIiuWvA7Q8e3Xh67ty5mDdvnsHV1nVj7ZoUFxfjnXfeQUREhM6046uvvor27dvD2dkZJ0+eRGxsLE6cOKE3mlUTBlJERETUYC5fvqwTrFS3l+K8efMwf/78GuvKyMgAULeNtatTVlaGUaNGoaKiAmvXrtU5Fh0dLf2zt7c3OnXqBD8/P/zwww/o2bNnrXUDDKSIiIhkT/F7MrYOALCxsanTYvMpU6bU+oSch4cHfvzxR4M21gYeBFEjRozAhQsX8O2339barp49e8LU1BS5ubkMpIiIiKiOmmBnc3t7e9jb29da7uGNtXv37g2gbhtrVwZRubm5OHjwIFq3bl3rtU6dOoWysjLpzSl1wcXmREREMtecdzZ/eGPt9PR0pKenIzo6WmdjbQDo3LkzEhMTAQD379/HX/7yF2RmZmL79u0oLy+HRqOBRqOR3lBy7tw5xMXFITMzExcvXsTevXsxfPhw+Pj4oG/fvnVuHwMpIiIiatZq21gbAM6cOQOtVgsAuHLlCr788ktcuXIFPXr0gIuLi5Qqn/QzMzPDgQMHEBISAk9PT0ydOhXBwcHYv38/TExM6tw2Tu0RERHJXTN/abGdnR0+++yzmi//0P7iHh4eqG2/cTc3N3z33XdGt42BFBERETVqIPRHxqk9IiIiIgNxRIqIiEjmGmKxeGMtNm/uGEgRERHJXTNfI9WccWqPiIiIyEAckSIiIpI5Tu0ZjoEUERGR3HFqz2Cc2iMiIiIyEEekiIiIZI5Te4ZjIEVERCR3nNozGAMpIiIiuWMgZTCukSIiIiIyEEekiIiIZI5rpAzHQIqIiEjuOLVnME7tERERERmII1JEREQypxACCmHckJKx5z+pGEgRERHJHaf2DMapPSIiIiIDcUSKiIhI5vjUnuEYSBEREckdp/YMxqk9IiIiIgNxRIqIiEjmOLVnOAZSREREcsepPYMxkCIiIpI5jkgZjmukiIiIiAzEESkiIiK549SewRhIERERkWyn5ozFqT0iIiIiA3FEioiISO6EeJCMrUOGGEgRERHJHJ/aMxyn9oiIiIgMxBEpIiIiueNTewZjIEVERCRziooHydg65IhTe0REREQG4ogUERGR3HFqz2AckSIiIpK5yqf2jE2N5ebNm4iMjIRKpYJKpUJkZCRu3bpV4zlRUVFQKBQ6yd/fX6dMSUkJ/vrXv8Le3h5WVlZ48cUXceXKlXq1jYEUERGR3FXuI2VsaiQRERHIzs5GUlISkpKSkJ2djcjIyFrPCw0NRX5+vpT27t2rc3z69OlITExEfHw8Dh8+jDt37mDIkCEoLy+vc9s4tUdERETN1s8//4ykpCSkp6ejT58+AICPP/4YarUaZ86cgaenZ7XnKpVKODs7V3lMq9Xik08+waefforBgwcDAD777DO4ublh//79CAkJqVP7OCJFREQkcw05tVdUVKSTSkpKjGpbWloaVCqVFEQBgL+/P1QqFY4cOVLjuampqXB0dMQzzzyD6OhoFBYWSseOHz+OsrIyBAcHS3murq7w9vautd6HMZAiIiKSO9FACYCbm5u0lkmlUmHx4sVGNU2j0cDR0VEv39HRERqNptrzwsLCsH37dnz77bf48MMPkZGRgYEDB0qBnUajgZmZGWxtbXXOc3JyqrHeR3Fqj4iIiBrM5cuXYWNjI31WKpVVlps3bx7mz59fY10ZGRkAAIVCoXdMCFFlfqWRI0dK/+zt7Q0/Pz+4u7tjz549+POf/1ztebXV+ygGUkRERDLXkO/as7Gx0QmkqjNlyhSMGjWqxjIeHh748ccfUVBQoHfs119/hZOTU53b5+LiAnd3d+Tm5gIAnJ2dUVpaips3b+qMShUWFiIgIKDO9TKQIiIikruGeOqunufb29vD3t6+1nJqtRparRbHjh1D7969AQBHjx6FVqutV8Bz/fp1XL58GS4uLgAAX19fmJqaIiUlBSNGjAAA5Ofn4+TJk/jggw/qXC/XSBEREVGz1aVLF4SGhiI6Ohrp6elIT09HdHQ0hgwZovPEXufOnZGYmAgAuHPnDt566y2kpaXh4sWLSE1NxdChQ2Fvb4+XXnoJAKBSqTB27FjMnDkTBw4cQFZWFl577TU8++yz0lN8dcERKSIiIplryKm9xrB9+3ZMnTpVesLuxRdfxOrVq3XKnDlzBlqtFgBgYmKCnJwcbNu2Dbdu3YKLiwsGDBiAnTt34qmnnpLO+eijj9CyZUuMGDEC9+7dw6BBg7BlyxaYmJjUuW0MpIiIiOSumb8ixs7ODp999lnNl39oatHCwgLffPNNrfWam5tj1apVWLVqlcFt49QeERERkYE4IkVERCRzzX1qrzljIEVERCR3FeJBMrYOGWIgRUREJHfNfI1Uc8Y1UkREREQG4ogUERGRzCnQAGukGqQlTx4GUkRERHLXBDub/1Fwao+IiIjIQE0aSK1btw7dunWTXnCoVquxb98+6XhBQQGioqLg6uoKS0tLhIaGSi8bfFhaWhoGDhwIKysrtGrVCv3798e9e/ek4zdv3kRkZCRUKhVUKhUiIyNx69YtnTry8vIwdOhQWFlZwd7eHlOnTkVpaalOmZycHAQGBsLCwgJt2rRBXFyczgZgRERET6LK7Q+MTXLUpIFU27ZtsWTJEmRmZiIzMxMDBw5EeHg4Tp06BSEEhg0bhvPnz2P37t3IysqCu7s7Bg8ejLt370p1pKWlITQ0FMHBwTh27BgyMjIwZcoUtGjxv1uLiIhAdnY2kpKSkJSUhOzsbERGRkrHy8vL8cILL+Du3bs4fPgw4uPjkZCQgJkzZ0plioqKEBQUBFdXV2RkZGDVqlVYtmwZli9f/ng6i4iIqLGIBkoypBDNbEjFzs4OS5cuRb9+/eDp6YmTJ0+ia9euAB4EPI6Ojnj//fcxbtw4AIC/vz+CgoKwYMGCKuv7+eef4eXlhfT0dPTp0wcAkJ6eDrVajdOnT8PT0xP79u3DkCFDcPnyZbi6ugIA4uPjERUVhcLCQtjY2GDdunWIjY1FQUEBlEolAGDJkiVYtWoVrly5AoWibsvsioqKoFKp0B/haKkwNaqvGss317KbuglERLJXdLsCts+ch1arhY2NTeNc4/ffpD8NmIeWLc2Nquv+/WIcPjivUdvbHDWbNVLl5eWIj4/H3bt3oVarUVJSAuDBe3AqmZiYwMzMDIcPHwYAFBYW4ujRo3B0dERAQACcnJwQGBgoHQcejFipVCopiAIeBF8qlQpHjhyRynh7e0tBFACEhISgpKQEx48fl8oEBgZKQVRlmWvXruHixYvV3ldJSQmKiop0EhERUXOiEKJBkhw1eSCVk5MDa2trKJVKTJw4EYmJifDy8kLnzp3h7u6O2NhY3Lx5E6WlpViyZAk0Gg3y8/MBAOfPnwcAzJs3D9HR0UhKSkLPnj0xaNAgaS2VRqOBo6Oj3nUdHR2h0WikMk5OTjrHbW1tYWZmVmOZys+VZaqyePFiaW2WSqWCm5ubId1ERETUeCoaKMlQkwdSnp6eyM7ORnp6OiZNmoQxY8bgp59+gqmpKRISEnD27FnY2dnB0tISqampCAsLg4mJCQCgouLBX23ChAl4/fXX4ePjg48++gienp7YtGmTdI2qpt2EEDr5hpSpnBWtaVovNjYWWq1WSpcvX65LtxAREdEToMn3kTIzM0PHjh0BAH5+fsjIyMDKlSuxYcMG+Pr6Ijs7G1qtFqWlpXBwcECfPn3g5+cHAHBxcQEAeHl56dTZpUsX5OXlAQCcnZ1RUFCgd91ff/1VGlFydnbG0aNHdY7fvHkTZWVlOmUeHXkqLCwEAL2RqocplUqd6UAiIqLmpiGm5ji110wIIaT1UZVUKhUcHByQm5uLzMxMhIeHAwA8PDzg6uqKM2fO6JQ/e/Ys3N3dAQBqtRparRbHjh2Tjh89ehRarRYBAQFSmZMnT0pThgCQnJwMpVIJX19fqcyhQ4d0tkRITk6Gq6srPDw8Gq4DiIiIHjc+tWewJh2RmjVrFsLCwuDm5obbt28jPj4eqampSEpKAgDs2rULDg4OaNeuHXJycjBt2jQMGzYMwcHBAB5Mqb399tuYO3cuunfvjh49emDr1q04ffo0Pv/8cwAPRqdCQ0MRHR2NDRs2AADGjx+PIUOGwNPTEwAQHBwMLy8vREZGYunSpbhx4wbeeustREdHS08eREREYP78+YiKisKsWbOQm5uLRYsW4b333qvzE3tERETNEnc2N1iTBlIFBQWIjIxEfn4+VCoVunXrhqSkJAQFBQEA8vPzERMTg4KCAri4uGD06NF49913deqYPn06iouLMWPGDNy4cQPdu3dHSkoKOnToIJXZvn07pk6dKgVgL774IlavXi0dNzExwZ49e/Dmm2+ib9++sLCwQEREBJYtWyaVUalUSElJweTJk+Hn5wdbW1vExMQgJiamMbuIiIiImrFmt4/UHx33kSIiorp4nPtIBQa82yD7SH13ZIHs9pFq8sXmRERE1MQ4tWewZrfYnIiIiOhJwREpIiIimVNUPEjG1iFHDKSIiIjkjlN7BuPUHhEREZGBOCJFREQkdw2xoaY8B6QYSBEREckdXxFjOE7tERERERmII1JERERyx8XmBmMgRUREJHcCgLHbF8gzjmIgRUREJHdcI2U4rpEiIiIiMhBHpIiIiOROoAHWSDVIS544DKSIiIjkjovNDcapPSIiIiIDcUSKiIhI7ioAKBqgDhniiBQREZHMVT61Z2xqLDdv3kRkZCRUKhVUKhUiIyNx69atmu9JoagyLV26VCrTv39/veOjRo2qV9s4IkVERETNWkREBK5cuYKkpCQAwPjx4xEZGYmvvvqq2nPy8/N1Pu/btw9jx47Fyy+/rJMfHR2NuLg46bOFhUW92sZAioiISO6a8WLzn3/+GUlJSUhPT0efPn0AAB9//DHUajXOnDkDT0/PKs9zdnbW+bx7924MGDAATz/9tE6+paWlXtn64NQeERGR3FUGUsamRpCWlgaVSiUFUQDg7+8PlUqFI0eO1KmOgoIC7NmzB2PHjtU7tn37dtjb26Nr16546623cPv27Xq1jyNSRERE1GCKiop0PiuVSiiVSoPr02g0cHR01Mt3dHSERqOpUx1bt27FU089hT//+c86+a+++irat28PZ2dnnDx5ErGxsThx4gRSUlLq3D6OSBEREcldA45Iubm5SYvCVSoVFi9eXOUl582bV+2C8MqUmZkJ4MHCcf0miyrzq7Jp0ya8+uqrMDc318mPjo7G4MGD4e3tjVGjRuHzzz/H/v378cMPP9S56zgiRUREJHcNuP3B5cuXYWNjI2VXNxo1ZcqUWp+Q8/DwwI8//oiCggK9Y7/++iucnJxqbdb333+PM2fOYOfOnbWW7dmzJ0xNTZGbm4uePXvWWh5gIEVERCR7DfnSYhsbG51Aqjr29vawt7evtZxarYZWq8WxY8fQu3dvAMDRo0eh1WoREBBQ6/mffPIJfH190b1791rLnjp1CmVlZXBxcam1bCVO7REREVGz1aVLF4SGhiI6Ohrp6elIT09HdHQ0hgwZovPEXufOnZGYmKhzblFREXbt2oVx48bp1Xvu3DnExcUhMzMTFy9exN69ezF8+HD4+Pigb9++dW4fAykiIiK5a8ZP7QEPnqx79tlnERwcjODgYHTr1g2ffvqpTpkzZ85Aq9Xq5MXHx0MIgVdeeUWvTjMzMxw4cAAhISHw9PTE1KlTERwcjP3798PExKTObVMIIdO3DDaRoqIiqFQq9Ec4WipMm7o5VfrmWnZTN4GISPaKblfA9pnz0Gq1dZoqM+gav/8mDe4wHS1NDH+yDgDul5dg/7kVjdre5ogjUkREREQG4mJzIiIiuWvGO5s3dwykiIiIZK8h1jjJM5Di1B4RERGRgTgiRUREJHec2jMYAykiIiK5qxAwemquQp6BFKf2iIiIiAzEESkiIiK5ExUPkrF1yBADKSIiIrnjGimDMZAiIiKSO66RMhjXSBEREREZiCNSREREcsepPYMxkCIiIpI7gQYIpBqkJU8cTu0RERERGYgjUkRERHLHqT2DMZAiIiKSu4oKAEbuA1Uhz32kOLVHREREZCCOSBEREckdp/YMxkCKiIhI7hhIGYxTe0REREQG4ogUERGR3PEVMQZjIEVERCRzQlRACOOeujP2/CcVAykiIiK5E8L4ESWukSIiIiKi+uCIFBERkdyJBlgjJdMRKQZSREREcldRASiMXOMk0zVSnNojIiIiMhBHpIiIiOSOU3sGYyBFREQkc6KiAsLIqT25bn/AqT0iIiIiA3FEioiISO44tWcwBlJERERyVyEABQMpQ3Bqj4iIiMhAHJEiIiKSOyEAGLuPlDxHpBhIERERyZyoEBBGTu0JmQZSTTq1t27dOnTr1g02NjawsbGBWq3Gvn37pOMFBQWIioqCq6srLC0tERoaitzcXJ06+vfvD4VCoZNGjRqlU+aHH35AUFAQWrVqhdatW2P8+PG4c+eOTplH61AoFFi/fr1OmZycHAQGBsLCwgJt2rRBXFycbL84RET0ByIqGiY1koULFyIgIACWlpZo1apV3W5JCMybNw+urq6wsLBA//79cerUKZ0yJSUl+Otf/wp7e3tYWVnhxRdfxJUrV+rVtiYNpNq2bYslS5YgMzMTmZmZGDhwIMLDw3Hq1CkIITBs2DCcP38eu3fvRlZWFtzd3TF48GDcvXtXp57o6Gjk5+dLacOGDdKxa9euYfDgwejYsSOOHj2KpKQknDp1ClFRUXrt2bx5s049Y8aMkY4VFRUhKCgIrq6uyMjIwKpVq7Bs2TIsX7680fqHiIiIgNLSUgwfPhyTJk2q8zkffPABli9fjtWrVyMjIwPOzs4ICgrC7du3pTLTp09HYmIi4uPjcfjwYdy5cwdDhgxBeXl5na/TpFN7Q4cO1fm8cOFCrFu3Dunp6TA1NUV6ejpOnjyJrl27AgDWrl0LR0dH7NixA+PGjZPOs7S0hLOzc5XX+Prrr2Fqaoo1a9agRYsHceOaNWvg4+ODX375BR07dpTKtmrVqtp6tm/fjuLiYmzZsgVKpRLe3t44e/Ysli9fjpiYGCgUCqP6goiIqKk096m9+fPnAwC2bNlS57asWLECs2fPxp///GcAwNatW+Hk5IR///vfmDBhArRaLT755BN8+umnGDx4MADgs88+g5ubG/bv34+QkJA6XavZPLVXXl6O+Ph43L17F2q1GiUlJQAAc3NzqYyJiQnMzMxw+PBhnXO3b98Oe3t7dO3aFW+99ZZOtFlSUgIzMzMpiAIACwsLANCrZ8qUKbC3t0evXr2wfv16VFT8b5gyLS0NgYGBUCqVUl5ISAiuXbuGixcvGt8BRERETaWZT+3V14ULF6DRaBAcHCzlKZVKBAYG4siRIwCA48ePo6ysTKeMq6srvL29pTJ10eSLzXNycqBWq1FcXAxra2skJibCy8sLZWVlcHd3R2xsLDZs2AArKyssX74cGo0G+fn50vmvvvoq2rdvD2dnZ5w8eRKxsbE4ceIEUlJSAAADBw5ETEwMli5dimnTpuHu3buYNWsWAOjUs2DBAgwaNAgWFhY4cOAAZs6cid9++w1z5swBAGg0Gnh4eOi03cnJSTrWvn37Ku+vpKRECgoBQKvVAgDuo8zovc8aS9Ht5vMvAxGRXBXdefDf4sexFrchfpPuowzAg6UwD1MqlTqDEI+DRqMB8L/f6UpOTk64dOmSVMbMzAy2trZ6ZSrPrxPRxEpKSkRubq7IyMgQ77zzjrC3txenTp0SQgiRmZkpunfvLgAIExMTERISIsLCwkRYWFi19WVmZgoA4vjx41Le9u3bhZOTkzAxMRFmZmbirbfeEk5OTuL999+vtp5ly5YJGxsb6XNQUJAYP368TpkrV64IACItLa3aeubOnVu5XSwTExMTE1O907lz52r9LTXUvXv3hLOzc4O11draWi9v7ty5Bv8+ZmRk6JyzefNmoVKpar2v//f//p8AIK5du6aTP27cOBESEiKEeBAbmJmZ6Z07ePBgMWHChLp1oBCiyUekzMzMpHVKfn5+yMjIwMqVK7Fhwwb4+voiOzsbWq0WpaWlcHBwQJ8+feDn51dtfT179oSpqSlyc3PRs2dPAEBERAQiIiJQUFAAKysrKBQKLF++vNpRJADw9/dHUVERCgoK4OTkBGdnZ70ItbCwEIB+xPuw2NhYxMTESJ9v3boFd3d35OXlQaVS1d5BJCkqKoKbmxsuX74MGxubpm7OE4V9Zxz2n+HYd4bTarVo164d7OzsGu0a5ubmuHDhAkpLSxukPiGE3prh6kajpkyZoveU/aMenQmqq8r1zhqNBi4uLlJ+YWGh9Jvt7OyM0tJS3Lx5U2dUqrCwEAEBAXW+VpMHUo8SQuhMhQGQAo7c3FxkZmZiwYIF1Z5/6tQplJWV6XRcpcrO27RpE8zNzREUFFRtPVlZWTA3N5ces1Sr1Zg1axZKS0thZmYGAEhOToarq2uNf+jqhjRVKhX/o2Kgyu0yqP7Yd8Zh/xmOfWe4h9f4NgZzc3Od9ciPi729Pezt7Rul7solPykpKfDx8QHw4Mm/7777Du+//z4AwNfXF6ampkhJScGIESMAPFjyc/LkSXzwwQd1vlaTBlKzZs1CWFgY3NzccPv2bcTHxyM1NRVJSUkAgF27dsHBwQHt2rVDTk4Opk2bhmHDhkkLw86dO4ft27fj+eefh729PX766SfMnDkTPj4+6Nu3r3Sd1atXIyAgANbW1khJScHbb7+NJUuWSEHSV199BY1GA7VaDQsLCxw8eBCzZ8/G+PHjpSAoIiIC8+fPR1RUFGbNmoXc3FwsWrQI7733Hp/YIyIiakR5eXm4ceMG8vLyUF5ejuzsbABAx44dYW1tDQDo3LkzFi9ejJdeegkKhQLTp0/HokWL0KlTJ3Tq1AmLFi2CpaUlIiIiADwY0Bg7dixmzpyJ1q1bw87ODm+99RaeffZZ6Sm+OqnzJGAjeOONN4S7u7swMzMTDg4OYtCgQSI5OVk6vnLlStG2bVthamoq2rVrJ+bMmSNKSkqk43l5eeK5554TdnZ2wszMTHTo0EFMnTpVXL9+Xec6kZGRUplu3bqJbdu26Rzft2+f6NGjh7C2thaWlpbC29tbrFixQpSVlemU+/HHH0W/fv2EUqkUzs7OYt68eaKioqJe96zVagUAodVq63Uese+Mwb4zDvvPcOw7w7Hv/mfMmDFVrqE6ePCgVAaA2Lx5s/S5oqJCzJ07Vzg7OwulUimee+45kZOTo1PvvXv3xJQpU4SdnZ2wsLAQQ4YMEXl5efVqm+L3i9NjUlJSgsWLFyM2NvaxP8XwpGPfGY59Zxz2n+HYd4Zj3z0ZGEgRERERGajZbMhJRERE9KRhIEVERERkIAZSRERERAZiIEVERERkIAZSDzl06BCGDh0KV1dXKBQK/Pe//9U5/sUXXyAkJAT29vZQKBTSPhYPmzBhAjp06AALCws4ODggPDwcp0+f1imzcOFCBAQEwNLSUtrL6lF5eXkYOnQorKysYG9vj6lTp+rtPJuTk4PAwEBYWFigTZs2iIuLeyzvZKpOc+o/hUKhl9avX69Tpjn13+Pou4sXL2Ls2LFo3749LCws0KFDB8ydO1fve8XvnnH9x+9e1f/evvjii2jXrh3Mzc3h4uKCyMhIXLt2TafMk/bda05996R97/5IGEg95O7du+jevTtWr15d7fG+fftiyZIl1dbh6+uLzZs34+eff8Y333wDIQSCg4NRXl4ulSktLcXw4cMxadKkKusoLy/HCy+8gLt37+Lw4cOIj49HQkICZs6cKZUpKipCUFAQXF1dkZGRgVWrVmHZsmVYvny5gXdvvObSf5U2b96M/Px8KY0ZM0Y61tz673H03enTp1FRUYENGzbg1KlT+Oijj7B+/XrpJd4Av3vG9l8lfvf0/70dMGAA/vOf/+DMmTNISEjAuXPn8Je//EU6/iR+95pL31V6kr53fyj12nVKRgCIxMTEKo9duHBBABBZWVm11nPixAkBQPzyyy96x6p7+eLevXtFixYtxNWrV6W8HTt2CKVSKW3MtnbtWqFSqURxcbFUZvHixcLV1bXem4Q2hqbsv9quL0Tz7r/H0XeVPvjgA9G+fXvpM797/2NI/9V2fSGad/89zr7bvXu3UCgUorS0VAjx5H/3mrLvaru+EM277550HJFqRHfv3sXmzZvRvn17uLm51fm8tLQ0eHt7w9XVVcoLCQlBSUkJjh8/LpUJDAzU2aQtJCQE165dw8WLFxvsHpqSof1XacqUKbC3t0evXr2wfv16VFRUSMf+6P1X177TarU6L0Tld+8BQ/uvEr97NffdjRs3sH37dgQEBMDU1BQAv3uA4X1XSc7fu6bEQKoRrF27FtbW1rC2tkZSUhJSUlKkFx3XhUajkV6wXMnW1hZmZmbQaDTVlqn8XFnmSWVs/wHAggULsGvXLuzfvx+jRo3CzJkzsWjRIun4H7X/6tN3586dw6pVqzBx4kQpj9894/oP4Hevpr77+9//DisrK7Ru3Rp5eXnYvXu3dEzO3z1j+w6Q7/euOWAg1QheffVVZGVl4bvvvkOnTp0wYsQIFBcX16uOql6ELITQyX+0jPh90eCT/hLlhui/OXPmQK1Wo0ePHpg5cybi4uKwdOlSnTJ/xP6ra99du3YNoaGhGD58OMaNG6dzjN894/qP373q++7tt99GVlYWkpOTYWJigtGjR+ssdpbrd68h+k6u37vmoGVTN+CPSKVSQaVSoVOnTvD394etrS0SExPxyiuv1Ol8Z2dnHD16VCfv5s2bKCsrk/4PwtnZWe//IgoLCwFA7/86njTG9l9V/P39UVRUhIKCAjg5Of1h+68ufXft2jUMGDAAarUaGzdu1Dmf3z3j+q8q/O79r+/s7e1hb2+PZ555Bl26dIGbmxvS09OhVqtl/d0ztu+qIpfvXXPAEanHQAiBkpKSOpdXq9U4efIk8vPzpbzk5GQolUr4+vpKZQ4dOqTzaHBycjJcXV3h4eHRYG1vDurbf1XJysqCubm5tF2CXPrv0b67evUq+vfvj549e2Lz5s1o0UL3PwH87umqb/9Vhd+96o8DkMrwu/c/9e27qsj1e9ckHvPi9mbt9u3bIisrS2RlZQkAYvny5SIrK0tcunRJCCHE9evXRVZWltizZ48AIOLj40VWVpbIz88XQghx7tw5sWjRIpGZmSkuXbokjhw5IsLDw4WdnZ0oKCiQrnPp0iWRlZUl5s+fL6ytraVr3r59WwghxP3794W3t7cYNGiQ+OGHH8T+/ftF27ZtxZQpU6Q6bt26JZycnMQrr7wicnJyxBdffCFsbGzEsmXLHmOP6Wou/ffll1+KjRs3ipycHPHLL7+Ijz/+WNjY2IipU6dKdTS3/nscfXf16lXRsWNHMXDgQHHlyhWRn58vpUr87hnXf/zuVd13R48eFatWrRJZWVni4sWL4ttvvxV/+tOfRIcOHaSnyJ7E715z6bsn8Xv3R8JA6iEHDx4UAPTSmDFjhBAPHrev6vjcuXOFEA/+QxsWFiYcHR2FqampaNu2rYiIiBCnT5/Wuc6YMWOqrOfgwYNSmUuXLokXXnhBWFhYCDs7OzFlyhSdx1aFEOLHH38U/fr1E0qlUjg7O4t58+Y16WOszaX/9u3bJ3r06CGsra2FpaWl8Pb2FitWrBBlZWU69TSn/nscfVddHY/+/xS/e4b3H797Vffdjz/+KAYMGCDs7OyEUqkUHh4eYuLEieLKlSs6bXnSvnvNpe+exO/dH4lCCG5rSkRERGQIrpEiIiIiMhADKSIiIiIDMZAiIiIiMhADKSIiIiIDMZAiIiIiMhADKSIiIiIDMZAiIiIiMhADKSIiIiIDMZAiIiIiMhADKSIiIiIDMZAioibx66+/wtnZGYsWLZLyjh49CjMzMyQnJzdhy4iI6o7v2iOiJrN3714MGzYMR44cQefOneHj44MXXngBK1asaOqmERHVCQMpImpSkydPxv79+9GrVy+cOHECGRkZMDc3b+pmERHVCQMpImpS9+7dg7e3Ny5fvozMzEx069atqZtERFRnXCNFRE3q/PnzuHbtGioqKnDp0qWmbg4RUb1wRIqImkxpaSl69+6NHj16oHPnzli+fDlycnLg5OTU1E0jIqoTBlJE1GTefvttfP755zhx4gSsra0xYMAAPPXUU/j666+bumlERHXCqT0iahKpqalYsWIFPv30U9jY2KBFixb49NNPcfjwYaxbt66pm0dEVCcckSIiIiIyEEekiIiIiAzEQIqIiIjIQAykiIiIiAzEQIqIiIjIQAykiIiIiAzEQIqIiIjIQAykiIiIiAzEQIqIiIjIQAykiIiIiAzEQIqIiIjIQAykiIiIiAzEQIqIiIjIQP8fK3nJqzp+gccAAAAASUVORK5CYII=",[m
[31m-      "text/plain": [[m
[31m-       "<Figure size 640x480 with 2 Axes>"[m
[31m-      ][m
[31m-     },[m
[31m-     "metadata": {},[m
[31m-     "output_type": "display_data"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "BND.isel(layer=0, x=range(0,10), y=range(0,10)).plot.imshow(cmap='viridis')"[m
    ][m
[36m@@ -308,7 +287,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 16,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "aa7236f9",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -326,27592 +305,17 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 17,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f749ccb3",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stderr",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n",[m
[31m-      "You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n",[m
[31m-      "A typical example is when you are setting values in a column of a DataFrame, like:\n",[m
[31m-      "\n",[m
[31m-      "df[\"col\"][row_indexer] = value\n",[m
[31m-      "\n",[m
[31m-      "Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n",[m
[31m-      "c:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\code\\.pixi\\envs\\default\\Lib\\site-packages\\imod\\util\\expand_repetitions.py:89: SettingWithCopyWarning: \n",[m
[31m-      "A value is trying to be set on a copy of a slice from a DataFrame\n",[m
[31m-      "\n",[m
[31m-      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",[m
[31m-      "  well_rate[\"time\"].iloc[-1:] = well_rate[\"time\"].iloc[-1:].fillna(pd.Timestamp.max)\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "Sim_MF6 = mf6.Modflow6Simulation.from_imod5_data(PRJ_regrid, period_data, times)"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 18,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "234ead8b",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -27929,7 +333,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 19,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "3e51ba58",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -27957,7 +361,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 20,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "02af4484",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -27967,7 +371,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 21,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "eae098c4",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -27994,20 +398,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 22,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "1ed6fe49",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "Error creating MetaSwap model: \n",[m
[31m-      "Did not find parsable path to existing .ASC file in column 2. Got\n",[m
[31m-      "values (printing first 10): ['..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100101_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100102_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100103_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100104_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100105_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100106_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100107_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100108_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100109_NBr1.asc', '..\\\\..\\\\In\\\\CAP\\\\P\\\\NBr1\\\\P_20100110_NBr1.asc'].\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "try:\n",[m
     "    MSW_Mdl = msw.MetaSwapModel.from_imod5_data(PRJ_MSW, MF6_DIS, times)\n",[m
[36m@@ -28036,18 +430,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 23,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "90bd32c3",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "Created corrected mete_grid.inp: C:\\Users\\Karam014\\OneDrive - Universiteit Utrecht\\WS_Mdl\\models\\NBr\\In\\CAP\\mete_grid\\NBr5\\temp\\mete_grid.inp\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Replace the mete_grid.inp path in the PRJ_MSW_for_MSW dictionary\n",[m
     "PRJ['extra']['paths'][2][0] = UIM.mete_grid_Cvt_to_AbsPa(Pa_PRJ, PRJ)"[m
[36m@@ -28063,18 +449,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 24,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "d5005945",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "ðŸŽ‰ MetaSwap model loaded successfully!\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Create the MetaSwap model\n",[m
     "MSW_Mdl = msw.MetaSwapModel.from_imod5_data(PRJ_MSW, MF6_DIS, times)\n",[m
[36m@@ -28099,7 +477,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 25,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "06f90a7f",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28109,7 +487,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 26,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "e6be0c8a",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28119,7 +497,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 27,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f76d1d24",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28129,20 +507,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 28,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "1c685aa5",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "MF6 Model AoI DIS shape: Frozen({'layer': 37, 'y': 344, 'x': 480})\n",[m
[31m-      "MSW Model AoI grid shape: Frozen({'x': 480, 'y': 344, 'subunit': 2})\n",[m
[31m-      "âœ… Both models successfully clipped to Area of Interest with compatible discretization!\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "print(f\"MF6 Model AoI DIS shape: {MF6_Mdl_AoI['dis'].dataset.sizes}\")\n",[m
     "print(f\"MSW Model AoI grid shape: {MSW_Mdl_AoI['grid'].dataset.sizes}\")\n",[m
[36m@@ -28151,21 +519,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 29,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "045b4d51",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "True"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 29,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "MF6_Mdl_AoI['dis'].dataset.equals(MF6_Mdl['dis'].dataset)"[m
    ][m
[36m@@ -28188,42 +545,20 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 30,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "8979c992",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "(113100.0, 125100.0, 387600.0, 396200.0)"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 30,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "Xmin, Xmax, Ymin, Ymax"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 31,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "44f2727b",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "(array(113112.5), array(125087.5), array(387612.5), array(396187.5))"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 31,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "MF6_Mdl_AoI['dis']['x'].min().values, MF6_Mdl_AoI['dis']['x'].max().values, \\\n",[m
     "MF6_Mdl_AoI['dis']['y'].min().values, MF6_Mdl_AoI['dis']['y'].max().values"[m
[36m@@ -28247,7 +582,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 32,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "e260be4c",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28277,7 +612,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 33,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "75111d78",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28288,7 +623,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 34,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f0e555af",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28307,7 +642,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 35,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "bc22c182",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -28317,518 +652,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 36,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "cb3e3ad0",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "Are the keys identical? False\n",[m
[31m-      "\n",[m
[31m-      "=== DETAILED KEY COMPARISON ===\n",[m
[31m-      "Original model has 165 packages:\n",[m
[31m-      "  - chd_merged\n",[m
[31m-      "  - dis\n",[m
[31m-      "  - drn-1\n",[m
[31m-      "  - drn-2\n",[m
[31m-      "  - drn-3\n",[m
[31m-      "  - hfb-1\n",[m
[31m-      "  - hfb-10\n",[m
[31m-      "  - hfb-100\n",[m
[31m-      "  - hfb-101\n",[m
[31m-      "  - hfb-102\n",[m
[31m-      "  - hfb-103\n",[m
[31m-      "  - hfb-104\n",[m
[31m-      "  - hfb-105\n",[m
[31m-      "  - hfb-106\n",[m
[31m-      "  - hfb-107\n",[m
[31m-      "  - hfb-108\n",[m
[31m-      "  - hfb-109\n",[m
[31m-      "  - hfb-11\n",[m
[31m-      "  - hfb-110\n",[m
[31m-      "  - hfb-111\n",[m
[31m-      "  - hfb-112\n",[m
[31m-      "  - hfb-113\n",[m
[31m-      "  - hfb-114\n",[m
[31m-      "  - hfb-115\n",[m
[31m-      "  - hfb-116\n",[m
[31m-      "  - hfb-117\n",[m
[31m-      "  - hfb-118\n",[m
[31m-      "  - hfb-119\n",[m
[31m-      "  - hfb-12\n",[m
[31m-      "  - hfb-120\n",[m
[31m-      "  - hfb-121\n",[m
[31m-      "  - hfb-122\n",[m
[31m-      "  - hfb-123\n",[m
[31m-      "  - hfb-124\n",[m
[31m-      "  - hfb-125\n",[m
[31m-      "  - hfb-126\n",[m
[31m-      "  - hfb-127\n",[m
[31m-      "  - hfb-128\n",[m
[31m-      "  - hfb-129\n",[m
[31m-      "  - hfb-13\n",[m
[31m-      "  - hfb-130\n",[m
[31m-      "  - hfb-131\n",[m
[31m-      "  - hfb-132\n",[m
[31m-      "  - hfb-133\n",[m
[31m-      "  - hfb-134\n",[m
[31m-      "  - hfb-135\n",[m
[31m-      "  - hfb-136\n",[m
[31m-      "  - hfb-137\n",[m
[31m-      "  - hfb-138\n",[m
[31m-      "  - hfb-139\n",[m
[31m-      "  - hfb-14\n",[m
[31m-      "  - hfb-140\n",[m
[31m-      "  - hfb-141\n",[m
[31m-      "  - hfb-142\n",[m
[31m-      "  - hfb-143\n",[m
[31m-      "  - hfb-144\n",[m
[31m-      "  - hfb-145\n",[m
[31m-      "  - hfb-146\n",[m
[31m-      "  - hfb-147\n",[m
[31m-      "  - hfb-148\n",[m
[31m-      "  - hfb-149\n",[m
[31m-      "  - hfb-15\n",[m
[31m-      "  - hfb-150\n",[m
[31m-      "  - hfb-16\n",[m
[31m-      "  - hfb-17\n",[m
[31m-      "  - hfb-18\n",[m
[31m-      "  - hfb-19\n",[m
[31m-      "  - hfb-2\n",[m
[31m-      "  - hfb-20\n",[m
[31m-      "  - hfb-21\n",[m
[31m-      "  - hfb-22\n",[m
[31m-      "  - hfb-23\n",[m
[31m-      "  - hfb-24\n",[m
[31m-      "  - hfb-25\n",[m
[31m-      "  - hfb-26\n",[m
[31m-      "  - hfb-27\n",[m
[31m-      "  - hfb-28\n",[m
[31m-      "  - hfb-29\n",[m
[31m-      "  - hfb-3\n",[m
[31m-      "  - hfb-30\n",[m
[31m-      "  - hfb-31\n",[m
[31m-      "  - hfb-32\n",[m
[31m-      "  - hfb-33\n",[m
[31m-      "  - hfb-34\n",[m
[31m-      "  - hfb-35\n",[m
[31m-      "  - hfb-36\n",[m
[31m-      "  - hfb-37\n",[m
[31m-      "  - hfb-38\n",[m
[31m-      "  - hfb-39\n",[m
[31m-      "  - hfb-4\n",[m
[31m-      "  - hfb-40\n",[m
[31m-      "  - hfb-41\n",[m
[31m-      "  - hfb-42\n",[m
[31m-      "  - hfb-43\n",[m
[31m-      "  - hfb-44\n",[m
[31m-      "  - hfb-45\n",[m
[31m-      "  - hfb-46\n",[m
[31m-      "  - hfb-47\n",[m
[31m-      "  - hfb-48\n",[m
[31m-      "  - hfb-49\n",[m
[31m-      "  - hfb-5\n",[m
[31m-      "  - hfb-50\n",[m
[31m-      "  - hfb-51\n",[m
[31m-      "  - hfb-52\n",[m
[31m-      "  - hfb-53\n",[m
[31m-      "  - hfb-54\n",[m
[31m-      "  - hfb-55\n",[m
[31m-      "  - hfb-56\n",[m
[31m-      "  - hfb-57\n",[m
[31m-      "  - hfb-58\n",[m
[31m-      "  - hfb-59\n",[m
[31m-      "  - hfb-6\n",[m
[31m-      "  - hfb-60\n",[m
[31m-      "  - hfb-61\n",[m
[31m-      "  - hfb-62\n",[m
[31m-      "  - hfb-63\n",[m
[31m-      "  - hfb-64\n",[m
[31m-      "  - hfb-65\n",[m
[31m-      "  - hfb-66\n",[m
[31m-      "  - hfb-67\n",[m
[31m-      "  - hfb-68\n",[m
[31m-      "  - hfb-69\n",[m
[31m-      "  - hfb-7\n",[m
[31m-      "  - hfb-70\n",[m
[31m-      "  - hfb-71\n",[m
[31m-      "  - hfb-72\n",[m
[31m-      "  - hfb-73\n",[m
[31m-      "  - hfb-74\n",[m
[31m-      "  - hfb-75\n",[m
[31m-      "  - hfb-76\n",[m
[31m-      "  - hfb-77\n",[m
[31m-      "  - hfb-78\n",[m
[31m-      "  - hfb-79\n",[m
[31m-      "  - hfb-8\n",[m
[31m-      "  - hfb-80\n",[m
[31m-      "  - hfb-81\n",[m
[31m-      "  - hfb-82\n",[m
[31m-      "  - hfb-83\n",[m
[31m-      "  - hfb-84\n",[m
[31m-      "  - hfb-85\n",[m
[31m-      "  - hfb-86\n",[m
[31m-      "  - hfb-87\n",[m
[31m-      "  - hfb-88\n",[m
[31m-      "  - hfb-89\n",[m
[31m-      "  - hfb-9\n",[m
[31m-      "  - hfb-90\n",[m
[31m-      "  - hfb-91\n",[m
[31m-      "  - hfb-92\n",[m
[31m-      "  - hfb-93\n",[m
[31m-      "  - hfb-94\n",[m
[31m-      "  - hfb-95\n",[m
[31m-      "  - hfb-96\n",[m
[31m-      "  - hfb-97\n",[m
[31m-      "  - hfb-98\n",[m
[31m-      "  - hfb-99\n",[m
[31m-      "  - ic\n",[m
[31m-      "  - msw-rch\n",[m
[31m-      "  - msw-sprinkling\n",[m
[31m-      "  - npf\n",[m
[31m-      "  - oc\n",[m
[31m-      "  - riv-1riv\n",[m
[31m-      "  - sto\n",[m
[31m-      "  - wel-WEL_Br_Wa_T_\n",[m
[31m-      "  - wel-WEL_Ind_Aa_a\n",[m
[31m-      "  - wel-WEL_Ind_Br_T\n",[m
[31m-      "\n",[m
[31m-      "AoI model has 14 packages:\n",[m
[31m-      "  - chd_merged\n",[m
[31m-      "  - dis\n",[m
[31m-      "  - drn-1\n",[m
[31m-      "  - drn-2\n",[m
[31m-      "  - drn-3\n",[m
[31m-      "  - ic\n",[m
[31m-      "  - msw-rch\n",[m
[31m-      "  - msw-sprinkling\n",[m
[31m-      "  - npf\n",[m
[31m-      "  - oc\n",[m
[31m-      "  - riv-1riv\n",[m
[31m-      "  - sto\n",[m
[31m-      "  - wel-WEL_Br_Wa_T_\n",[m
[31m-      "  - wel-WEL_Ind_Br_T\n",[m
[31m-      "\n",[m
[31m-      "=== DIFFERENCES ===\n",[m
[31m-      "Packages REMOVED in AoI model (151):\n",[m
[31m-      "  âŒ hfb-1\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-10\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-100\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-101\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-102\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-103\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-104\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-105\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-106\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-107\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-108\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-109\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-11\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-110\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-111\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-112\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-113\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-114\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-115\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-116\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-117\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-118\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-119\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-12\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-120\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-121\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-122\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-123\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-124\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-125\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-126\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-127\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-128\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-129\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-13\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-130\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-131\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-132\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-133\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-134\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-135\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-136\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-137\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-138\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-139\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-14\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-140\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-141\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-142\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-143\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-144\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-145\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-146\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-147\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-148\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-149\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-15\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-150\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-16\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-17\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-18\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-19\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-2\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-20\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-21\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-22\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-23\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-24\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-25\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-26\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-27\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-28\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-29\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-3\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-30\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-31\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-32\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-33\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-34\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-35\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-36\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-37\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-38\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-39\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-4\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-40\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-41\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-42\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-43\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-44\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-45\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-46\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-47\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-48\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-49\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-5\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-50\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-51\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-52\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-53\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-54\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-55\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-56\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-57\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-58\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-59\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-6\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-60\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-61\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-62\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-63\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-64\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-65\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-66\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-67\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-68\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-69\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-7\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-70\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-71\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-72\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-73\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-74\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-75\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-76\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-77\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-78\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-79\n",[m
[31m-      "     Size in original: {'index': 1}\n",[m
[31m-      "  âŒ hfb-8\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-80\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-81\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-82\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-83\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-84\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-85\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-86\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-87\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-88\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-89\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-9\n",[m
[31m-      "     Size in original: {'index': 3}\n",[m
[31m-      "  âŒ hfb-90\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-91\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-92\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-93\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-94\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-95\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-96\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-97\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-98\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ hfb-99\n",[m
[31m-      "     Size in original: {'index': 2}\n",[m
[31m-      "  âŒ wel-WEL_Ind_Aa_a\n",[m
[31m-      "     Size in original: {'index': 17, 'time': 2}\n",[m
[31m-      "âœ… No packages added in AoI model\n",[m
[31m-      "\n",[m
[31m-      "Common packages: 14/165 (8.5%)\n",[m
[31m-      "\n",[m
[31m-      "=== WHY PACKAGES WERE REMOVED ===\n",[m
[31m-      "Packages are typically removed from AoI models when:\n",[m
[31m-      "1. They have no data within the clipped boundary\n",[m
[31m-      "2. All their stress points/cells fall outside the AoI\n",[m
[31m-      "3. The clip_box() method filters out empty packages\n",[m
[31m-      "\n",[m
[31m-      "This is normal behavior and indicates successful spatial filtering!\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Compare the keys of both models\n",[m
     "keys_equal = MF6_Mdl.keys() == MF6_Mdl_AoI.keys()\n",[m
[36m@@ -28890,110 +717,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 37,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "588b72e6",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "=== PACKAGE DATA COMPARISON ===\n",[m
[31m-      "Comparing spatial dimensions and data ranges for common packages:\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ chd_merged:\n",[m
[31m-      "   Original sizes: {'time': 1, 'layer': 19, 'y': 344, 'x': 480}\n",[m
[31m-      "   AoI sizes:      {'layer': 19, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ dis:\n",[m
[31m-      "   Original sizes: {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   AoI sizes:      {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'idomain': Data appears to be spatially clipped âœ“\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ drn-1:\n",[m
[31m-      "   Original sizes: {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   AoI sizes:      {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ drn-2:\n",[m
[31m-      "   Original sizes: {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   AoI sizes:      {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ drn-3:\n",[m
[31m-      "   Original sizes: {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   AoI sizes:      {'layer': 1, 'y': 344, 'x': 480, 'time': 1}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ ic:\n",[m
[31m-      "   Original sizes: {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   AoI sizes:      {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'start': Data appears to be spatially clipped âœ“\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ msw-rch:\n",[m
[31m-      "   Original sizes: {'x': 480, 'y': 344}\n",[m
[31m-      "   AoI sizes:      {'x': 480, 'y': 344}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ msw-sprinkling:\n",[m
[31m-      "   Original sizes: {'index': 26263}\n",[m
[31m-      "   AoI sizes:      {'index': 26263}\n",[m
[31m-      "   Variable 'x': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ npf:\n",[m
[31m-      "   Original sizes: {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   AoI sizes:      {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'k33': Data appears to be spatially clipped âœ“\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ oc:\n",[m
[31m-      "   Original sizes: {}\n",[m
[31m-      "   AoI sizes:      {}\n",[m
[31m-      "   Variable 'save_concentration': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ riv-1riv:\n",[m
[31m-      "   Original sizes: {'y': 344, 'x': 480, 'layer': 37, 'time': 1}\n",[m
[31m-      "   AoI sizes:      {'y': 344, 'x': 480, 'layer': 37, 'time': 1}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'print_input': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ sto:\n",[m
[31m-      "   Original sizes: {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   AoI sizes:      {'layer': 37, 'y': 344, 'x': 480}\n",[m
[31m-      "   x reduction: 1.000 (480/480 cells)\n",[m
[31m-      "   y reduction: 1.000 (344/344 cells)\n",[m
[31m-      "   Variable 'convertible': Data appears to be spatially clipped âœ“\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ wel-WEL_Br_Wa_T_:\n",[m
[31m-      "   Original sizes: {'index': 846, 'time': 2}\n",[m
[31m-      "   AoI sizes:      {'index': 23, 'time': 2}\n",[m
[31m-      "   Variable 'x': Non-spatial data\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“¦ wel-WEL_Ind_Br_T:\n",[m
[31m-      "   Original sizes: {'index': 860, 'time': 2}\n",[m
[31m-      "   AoI sizes:      {'index': 8, 'time': 2}\n",[m
[31m-      "   Variable 'x': Non-spatial data\n",[m
[31m-      "\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Analyze the data content of common packages\n",[m
     "print(\"=== PACKAGE DATA COMPARISON ===\")\n",[m
[36m@@ -29043,37 +770,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 38,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "ce53d047",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "=== COORDINATE BOUNDS COMPARISON ===\n",[m
[31m-      "Target clipping bounds: X(113100.0, 125100.0), Y(387600.0, 396200.0)\n",[m
[31m-      "\n",[m
[31m-      "Original model bounds:\n",[m
[31m-      "   X: 113112.5 to 125087.5 (range: 11975.0)\n",[m
[31m-      "   Y: 387612.5 to 396187.5 (range: 8575.0)\n",[m
[31m-      "\n",[m
[31m-      "AoI model bounds:\n",[m
[31m-      "   X: 113112.5 to 125087.5 (range: 11975.0)\n",[m
[31m-      "   Y: 387612.5 to 396187.5 (range: 8575.0)\n",[m
[31m-      "\n",[m
[31m-      "Clipping verification:\n",[m
[31m-      "   X bounds within target: âœ“\n",[m
[31m-      "   Y bounds within target: âœ“\n",[m
[31m-      "   ðŸŽ‰ Clipping successful!\n",[m
[31m-      "\n",[m
[31m-      "Area reduction:\n",[m
[31m-      "   Original area: 102,685,625 mÂ²\n",[m
[31m-      "   AoI area: 102,685,625 mÂ²\n",[m
[31m-      "   Ratio: 1.0000 (100.00%)\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Compare coordinate bounds to verify clipping worked correctly\n",[m
     "print(\"=== COORDINATE BOUNDS COMPARISON ===\")\n",[m
[36m@@ -29133,33 +833,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 39,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "91717a4d",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "=== COMMON PACKAGES ===\n",[m
[31m-      "These 14 packages are present in both models:\n",[m
[31m-      " 1. chd_merged\n",[m
[31m-      " 2. dis\n",[m
[31m-      " 3. drn-1\n",[m
[31m-      " 4. drn-2\n",[m
[31m-      " 5. drn-3\n",[m
[31m-      " 6. ic\n",[m
[31m-      " 7. msw-rch\n",[m
[31m-      " 8. msw-sprinkling\n",[m
[31m-      " 9. npf\n",[m
[31m-      "10. oc\n",[m
[31m-      "11. riv-1riv\n",[m
[31m-      "12. sto\n",[m
[31m-      "13. wel-WEL_Br_Wa_T_\n",[m
[31m-      "14. wel-WEL_Ind_Br_T\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Print the names of common packages\n",[m
     "print(\"=== COMMON PACKAGES ===\")\n",[m
[36m@@ -29170,105 +847,30 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 40,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "cb5891a3",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "KeysView(GroundwaterFlowModel(\n",[m
[31m-       "    listing_file=None,\n",[m
[31m-       "    print_input=False,\n",[m
[31m-       "    print_flows=False,\n",[m
[31m-       "    save_flows=False,\n",[m
[31m-       "    newton=False,\n",[m
[31m-       "    under_relaxation=False,\n",[m
[31m-       "){\n",[m
[31m-       "    'dis': StructuredDiscretization,\n",[m
[31m-       "    'npf': NodePropertyFlow,\n",[m
[31m-       "    'sto': StorageCoefficient,\n",[m
[31m-       "    'ic': InitialConditions,\n",[m
[31m-       "    'wel-WEL_Ind_Br_T': Well,\n",[m
[31m-       "    'wel-WEL_Br_Wa_T_': Well,\n",[m
[31m-       "    'msw-sprinkling': LayeredWell,\n",[m
[31m-       "    'msw-rch': Recharge,\n",[m
[31m-       "    'drn-1': Drainage,\n",[m
[31m-       "    'drn-2': Drainage,\n",[m
[31m-       "    'drn-3': Drainage,\n",[m
[31m-       "    'riv-1riv': River,\n",[m
[31m-       "    'chd_merged': ConstantHead,\n",[m
[31m-       "    'oc': OutputControl,\n",[m
[31m-       "})"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 40,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "MF6_Mdl_AoI.keys()"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 41,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "ae1b8e50",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "<matplotlib.image.AxesImage at 0x2ac9ffe1d10>"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 41,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    },[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAlIAAAHFCAYAAAA5VBcVAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjUsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvWftoOwAAAAlwSFlzAAAPYQAAD2EBqD+naQAAW8dJREFUeJzt3XlclNX+B/DPgDBsziCyjiKYFopeAcV0tC5uKGSmLbboZbE0M0wTtcJyvy6VUV1zq3td6qqUmtmiXLBAfxYoGBjuuOLCUqGgJKDM+f3h5blOgMIzgwM+n3ev83o1z3Oe85w58wzz9ZzznEclhBAgIiIiogazsnQFiIiIiJorBlJEREREMjGQIiIiIpKJgRQRERGRTAykiIiIiGRiIEVEREQkEwMpIiIiIpkYSBERERHJxECKiIiISCYGUma2du1aqFQqnDlzxtJVsbhPP/0Uzz77LPz8/GBlZQVfX99GO5evry+io6MbrXy58vPz8dZbb0Gv18PV1RUajQY9evTAxx9/jKqqKqO8qampUKlUtab09PR6na+oqAjR0dFwdXWFg4MD9Ho9vv/+e7O/r+Z4nf/www94/vnn0alTJzg6OqJNmzYYPnw49u/fXyNvdHR0rZ9Dp06d6n2+nTt3Qq/Xw8HBAa6uroiOjkZRUZHs+m/YsAEffPBBrftUKhXmzJkju+ymrCGfGwD8/PPPGDRoEJycnODs7IwnnngCp06dqpHvgw8+wBNPPIH27dtDpVKhX79+ddbBHN+r+taLmp8Wlq4A3bs+++wzFBQU4MEHH4TBYMD169ctXaW7bv/+/fj0008RGRmJmTNnwsbGBjt27MCECROQnp6O1atX1zhm4cKF6N+/v9G2rl273vFcFRUVGDhwIC5fvowPP/wQ7u7uWLZsGcLCwrBz506EhISY7X01RytWrMDvv/+OyZMnw9/fH7/++ivee+899O7dG//5z38wYMAAo/z29vb44Ycfamyrj127diE8PBxDhw7Ftm3bUFRUhNdffx0DBw5EZmYm1Gp1g+u/YcMGHDx4EK+++mqNfWlpaWjbtm2Dy2wOGvK5HT16FP369UNgYCC++OILlJeXY9asWXj44YeRnZ0NNzc3Ke/KlSvh6OiIAQMG4Jtvvqnz/Ob4XjWkXtQMCTKrNWvWCADi9OnTlq5Krf744w9hMBjuyrmqqqqk/x86dKjw8fFptHP5+PiIqKioRitfruLiYlFZWVlje0xMjAAg8vLypG0pKSkCgNi0aZOscy1btkwAED/99JO07fr168Lf3188+OCDssqsS1O/zmtTWFhYY9uVK1eEh4eHGDhwoNH2qKgo4ejoKPtcPXv2FP7+/uL69evSth9//FEAEMuXL5dVZmN/h5qqhnxuI0eOFK6urqKkpETadubMGWFjYyNee+01o7y3/n3q0qWLCAkJqfX85vheNaRe1PxwaO8uSE5OxvDhw9G2bVvY2dmhY8eOGD9+PH777Tcpz//93/9BpVJh48aNNY7/9NNPoVKpkJGRIW3LzMzEY489BhcXF9jZ2SEoKAhffPGF0XHVwy9JSUl4/vnn4ebmBgcHB1RUVDTem72FlZX5L6/r16/jtddeg6enJxwcHPDQQw9h3759RnmEEHjkkUfQunVr5OXlSdv/+OMPdOnSBZ07d0ZZWZnZ61abVq1awcbGpsb2Bx98EABw/vx5s51r69at8PPzg16vl7a1aNECf/vb37Bv3z5cuHBBVrnp6eno27cv7OzsoNPpEBcXV6N38YUXXoCLiwv++OOPGscPGDAAXbp0kXVuc3J3d6+xzcnJCf7+/jh37pzZznPhwgVkZGQgIiICLVr8r9O/T58+eOCBB7B169YGl9mvXz989913OHv2rNFQY7U/D+1Vf/d/+OEHjBs3Dq1bt4ZGo0FkZCTKyspQUFCAp59+Gs7OzvDy8sK0adNqfKaVlZX4+9//jk6dOkGtVsPNzQ1jxozBr7/+2vBGMUF9P7cbN27g22+/xZNPPgmNRiNt9/HxQf/+/Wu0e33/Ppn6vWpovaj5YSB1F5w8eRJ6vR4rVqxAUlISZs2ahb179+Khhx6S/ng9/PDDCAoKwrJly2oc/9FHH6Fnz57o2bMnACAlJQV9+/bF5cuXsXLlSmzbtg2BgYF45plnsHbt2hrHP//887CxscFnn32GzZs31/rDXu3GjRv1SkII8zROA40bNw5LlixBZGQktm3bhieffBJPPPEELl26JOVRqVT47LPP4ODggKefflpq45dffhmnT5/GF198AUdHx9uep7Hb4YcffkCLFi3wwAMP1NgXExODFi1aQKPRYMiQIdizZ0+9yjx48CC6detWY3v1tkOHDjW4nocPH5aGNdauXYuVK1ciKysLf//7343yTZ48GZcuXcKGDRtqHJ+SkoKYmJjbnsdgMNSrvf88r8xUJSUl+Pnnn2sN9K5duwZPT09YW1ujbdu2mDhxIoqLi+9Y5sGDBwGgzs+ien9DLF++HH379oWnpyfS0tKkdCdjx46FVqtFQkIC3nrrLWzYsAHjxo3D0KFDERAQgM2bNyMqKgrvvfceli5dKh1nMBgwfPhwLF68GKNGjcJ3332HxYsXIzk5Gf369cO1a9due14hRL2/Q3LU9rmdPHkS165dq7PdT5w4gfLy8gafy9TvVWPVi5oQy3aI3XvuNORhMBjE9evXxdmzZwUAsW3bthrHZmVlSdv27dsnAIh169ZJ2zp16iSCgoKMhg2EEOLRRx8VXl5eUpd1dXmRkZH1rj+AeqU1a9bUu0whzDMsceTIEQFATJkyxWj7+vXrBYAaQ3t79uwRLVq0EK+++qpYvXq1ACD++c9/1utcjdUOQgjxn//8R1hZWdV4Hz///LOYPHmy2Lp1q9i9e7dYvXq16Ny5s7C2thaJiYl3LNfGxkaMHz++xvaffvpJABAbNmxocF2feeYZYW9vLwoKCqRtN27cEJ06dapxnYeEhIjAwECj4ydMmCA0Go24cuXKbc8ze/bserW3uYe2Ro8eLVq0aCEyMzONtsfHx4v4+HiRlJQkkpKSxJtvvikcHBxEp06d7vheqq/HtLS0GvtefPFFYWtrK6uut/sOARCzZ8+WXld/91955RWjfCNGjBAARHx8vNH2wMBA0b17d+n1xo0bBQCxZcsWo3wZGRn1Gp6sPn99khy1fW7VQ6cbN26skX/hwoUCgLh48WKt5d1uaM/U75Up9aLmgZPN74KioiLMmjUL3333HS5evAiDwSDtO3LkCB577DEAwHPPPYfXX38dy5YtwyeffAIAWLp0Kdzc3PDMM88AAE6cOIGjR49iyZIlAGD0L7pHHnkE3377LY4dO4bOnTtL25988sl61/XW4cPbad++fb3LNJeUlBQAwOjRo422P/3004iKiqqRv2/fvliwYAFef/11qNVq/O1vf8MLL7xQr3M1Vjv8/PPPePrpp9G7d28sWrTIaF9QUBCCgoKk1w8//DAef/xx/OUvf8Frr72GIUOG3LH8W4d7GrKvLikpKRg4cCA8PDykbdbW1njmmWcwd+5co7yTJ0/GE088gR9//BF9+/ZFaWkpPvvsM4wZMwZOTk63Pc+LL76IRx999I71udMkbSFEjV6rW4fXbjVz5kysX78eS5cuRY8ePYz2TZkyxeh1aGgogoKC8NRTT+GTTz6psb82dbW3nM9Brj+3aefOnfHVV19h6NChNbYnJSVJr7/99ls4Oztj2LBhRn9jAgMD4enpidTUVEyYMKHO8w4bNqze36GGut3nBpj/O1DfMg0Gg9HfdpVKBWtr60atFzUNDKQamcFgwODBg3Hx4kXMnDkTf/nLX+Do6AiDwYDevXsbdZGr1WqMHz8e7733Ht59911cv34dX3zxBWJjY6UfkMLCQgDAtGnTMG3atFrPeevcKwDw8vKqd30DAwPrle/WPxB3y++//w4A8PT0NNreokULtG7dutZjRo8ejZkzZ6KiogLTp0+v97kaox2ysrIQGhqK+++/H9u3b6/XnVvOzs549NFHsXLlSly7du22d421bt1aaqNbVQ9Hubi41Luu1X7//fca7Q3U/AwAYPjw4fD19cWyZcvQt29frF27FmVlZXcc1qsur7a5MH92px+cXbt21bjj8fTp0zWW3pg7dy7+/ve/Y8GCBZg4ceIdzwsAjz/+OBwdHe+4FEX1tVjXZyHnc5Drz+eytbWtc/utw0uFhYW4fPmylP/P/vw3prbzarVaOVW+rdt9bndqd5VKBWdn5wafs77fq+effx7r1q2T9oeEhCA1NbXR6kVNBwOpRnbw4EEcOHAAa9euNeo1OXHiRK35J0yYgMWLF2P16tUoLy/HjRs38NJLL0n7XV1dAQBxcXF44oknai3Dz8/P6HVD/rVzu/lTt1qzZs1dX7ep+g9SQUEB2rRpI22/ceNGrX+kqqqqMHr0aLRq1QpqtRovvPACfvzxxzp/HG5l7nbIysrCoEGD4OPjg6SkpAb9yIj/zsO60+f4l7/8BTk5OTW2V2+rzxIKf9a6dWsUFBTU2F7bNisrK8TExGDGjBl47733sHz5cgwcOLDG9VibefPm1ejhqo2Pj89t167q0aNHjZ4QnU5n9Hru3LmYM2cO5syZgxkzZtzxnLcSQtxxknJ1O+fk5OCRRx4x2peTkyPrc7jbXF1d0bp1ayQmJta6v2XLlrc9ft26dRgzZky9ziXqOc/wTp9bhw4dYG9vX+d3oGPHjrCzs6vXuW5V3+/VnDlzjIK76jZqrHpR08FAqpFV//j9ufdh1apVteb38vLCyJEjsXz5clRWVmLYsGFo166dtN/Pzw/3338/Dhw4gIULF5q9vk15aK96wbz169cbdel/8cUXtU5anT17Nv7v//4PSUlJcHR0xF//+ldMnz4dH3744R3PZc52yM7OxqBBg9C2bVskJyejVatW9SobAC5duoRvv/0WgYGBd/xj+/jjj+Pll1/G3r170atXLwA3g8x///vf6NWrV42Aoj769++Pr7/+GoWFhdLwXlVVFT7//PNa848dOxZz5szB6NGjcezYMbz99tv1Oo+5hvZatmyJ4ODgOvfPnz8fc+bMwVtvvYXZs2fXq27VNm/ejD/++AO9e/e+bb42bdrgwQcfxL///W9MmzZN6rVMT0/HsWPHal0Hqj7UavUdJ3mby6OPPoqEhARUVVVJ11JDmHtorz6fW4sWLTBs2DB8+eWXeOedd6RAJi8vDykpKfUajq1Nfb9Xvr6+tS463Fj1oibEslO07j1/nmxeWVkpOnToIHx8fMSGDRtEYmKiiImJEQ888ECNCaLV9u7dK03E3LlzZ439P/zwg1Cr1WLw4MFiw4YNYteuXWLr1q1i4cKF4qmnnqpRl4yMjMZ6u7d16NAhsWnTJrFp0ybRo0cP4ebmJr0+dOiQUV4AdU72vNXf/vY3oVKpxGuvvSaSkpJEfHy80Ol0QqPRGE02T0pKElZWVkbtu2TJEgFAfPnll2Z6h3d29OhR0bp1a+Hi4iK++eYbkZaWZpSKioqkvM8995x4/fXXxaZNm0RKSor4+OOPhZ+fn2jRooVITk42Kvf5558X1tbW4syZM9K28vJy0aVLF+Ht7S3Wr18vkpOTxeOPPy5atGghUlNTjY6vntydkpJy2/rn5OQIe3t74e/vLxISEsTXX38thgwZIry9veu8qWLChAnSxPBb1+qxtOrPPywsrMbncOvE8DNnzog+ffqIf/zjH2L79u1ix44d4o033hB2dnaiS5cu4urVq0blWltbiwEDBhhtS0lJES1atBCPP/64SE5OFuvXrxfe3t6ia9euory83Civj49PvSbRV39my5cvF3v37jX6Xv/5b0ld3/3qMn799Vej7X9eN+vGjRsiPDxcuLi4iLlz54odO3aInTt3irVr14qoqKi7+h2q7+cmxM0bUpycnMRf//pXsX37dvHll1+Krl27Cp1OZ/RdE+LmxPnqv0fe3t7C399fei33e1WXhtSrtutpwIABwtra2mjb3LlzhbW1db3rQI2HgZSZ1XbX3uHDh0VoaKho2bKlaNWqlRg5cqTIy8urM5ASQghfX1/RuXPnOs9z4MAB8fTTTwt3d3dhY2MjPD09xYABA8TKlStr1MVSgdTt7sS69X1fuXJFABDPPvvsHcusqKgQU6dOFe7u7sLOzk707t1bpKWlGS3IefHiReHu7i4GDBhg9ENuMBjEsGHDhLOz811bSPJOdy/detffokWLRGBgoNBqtcLa2lq4ubmJxx9/XOzbt69GuVFRUbUGMgUFBSIyMlK4uLhI7fPnIEwIIaZOnSpUKpU4cuTIHd/Djz/+KHr37i3UarXw9PQU06dPFx9//HGdgVRqaqoAIBYvXnzHsu+mkJCQet09VlxcLB5//HHh6+sr7O3tha2trbj//vvFa6+9Ji5fvlyj3Lr+EZCUlCR69+4t7OzshIuLi4iMjKx1cUlXV1fRu3fvO9a/uLhYPPXUU8LZ2VmoVCqjOps7kBLi5qKTS5YsEQEBAcLOzk44OTmJTp06ifHjx4vc3Nw71tdc6vu5VcvMzBQDBw4UDg4OQqPRiBEjRogTJ07UyFf9HbrT91KI+n+vbqe+9arteqpug1vV9x9D1PhUQlhoQSCq0y+//IKAgAAsW7YML7/8sqWr0+i2b9+ORx99FAcOHMBf/vIXS1dHER588EH4+Phg06ZNZi976tSpWLFiBc6dO1fnTQB00+HDh9GlSxd8++23Ne6kI6LmgXOkmpCTJ0/i7NmzmDFjBry8vJrkQ3gbQ0pKCp599lkGUXdJaWkpDhw4YHSHkTmkp6fj+PHjWL58OcaPH88gqh5SUlKg1+sZRBE1Y+yRakKio6Px2WefoXPnzli1ahX69u1r6SoR1ZtKpYKDgwMeeeQRrFmz5o5rRxER3QsYSBERERHJZNFn7a1YsQLdunWDRqOBRqOBXq/Hjh07pP2FhYWIjo6GTqeDg4MDwsLCkJubW6OctLQ0DBgwAI6OjnB2djZ6FtSZM2fwwgsvoH379rC3t0eHDh0we/ZsVFZWGpWRl5eHYcOGwdHREa6urpg0aVKNPDk5OQgJCYG9vT3atGmDefPmWeyZc0RERGR5Fp0j1bZtWyxevBgdO3YEcHMRt+HDhyMrKwv+/v4YMWIEbGxssG3bNmg0GsTHx2PQoEE4fPiw9NDZtLQ0hIWFIS4uDkuXLoWtrS0OHDggLZp39OhRGAwGrFq1Ch07dsTBgwcxbtw4lJWVSY9ZqaqqwtChQ+Hm5oY9e/bg999/R1RUFIQQ0oM8S0tLERoaiv79+yMjIwPHjx9HdHQ0HB0dMXXqVAu0HhEREVmc5W4YrF2rVq3EP//5T3Hs2DEBQBw8eFDad+PGDeHi4iI++eQTaVuvXr3EW2+91aBzvPPOO6J9+/bS6+3btwsrKytx4cIFadvGjRuFWq0WJSUlQgghli9fLrRardEaMIsWLRI6nU4YDIYGv08iIiJq/prMXXtVVVXYtGkTysrKoNfrUVFRAQBGqzlbW1vD1tYWe/bswdixY1FUVIS9e/di9OjR6NOnD06ePIlOnTphwYIFeOihh+o8V0lJidGzptLS0tC1a1ejlZ+HDBmCiooK7N+/H/3790daWhpCQkKMVlYeMmQI4uLicObMmTpXuK6oqJDeC3Dz2XvFxcVo3bo1H1RJRER1EkLgypUr0Ol0d3w0kSnKy8trTGWRy9bWVnmPvLF0JPfLL78IR0dHYW1tLbRarfjuu++EEDdXBPfx8REjR44UxcXFoqKiQixatEgAEIMHDxZCCJGWliYACBcXF7F69Wrx888/i1dffVXY2tqK48eP13q+EydOCI1GY9SrNW7cOBEaGlojr62trdiwYYMQQojQ0FAxbtw4o/0XLlwQAMRPP/1U5/u73aKUTExMTExMd0rnzp1r2A9rA1y7dk14ulubra6enp7i2rVrjVbfpsjiPVJ+fn7Izs7G5cuXsWXLFkRFRWHXrl3w9/fHli1b8MILL8DFxQXW1tYYNGgQwsPDpWMNBgMAYPz48dIDMoOCgvD9999j9erVWLRokdG5Ll68iLCwMIwcORJjx4412ldb75AQwmj7n/OIejxMNi4uDrGxsdLrkpIStGvXDr9kuKOlk0Xn+tdpf4XG0lWo066rnS1dhdv6qfDuP4OwIQrP1/85f3eb3YX6PSjaUpwuCEtX4bYcL5qnR6Gx2J29ZOkq1Knq1FlLV6FWN3Ade7D9jg+JNkVlZSUKiqpwdr8vNC1N+00qvWKAT48zqKysVFSvlMUDKVtbW2myeXBwMDIyMvDhhx9i1apV6NGjB7Kzs1FSUoLKykq4ubmhV69e0kNJvby8AAD+/v5GZXbu3Bl5eXlG2y5evIj+/ftDr9fj448/Ntrn6emJvXv3Gm27dOkSrl+/Lj2o1dPTs8YT74uKigBAylMbtVpd64NWWzpZoaWJF21jcbS1tnQV6qRG0/6xtb56+4fqWpqVfdP942atbuKfrW3TDqRatGiaf0+qtbBuut8NlaqJXnv/veTuxjQQp5YqOLU07TwGKHO6SpP75gkhjOYUAYBWq4Wbmxtyc3ORmZmJ4cOHA7j5tG2dTodjx44Z5T9+/Dh8fHyk1xcuXEC/fv3QvXt3rFmzpsZYs16vx8GDB5Gfny9tS0pKglqtRo8ePaQ8u3fvNhpHTkpKgk6nq/WJ30RERM1FlTCYJSmRRXukZsyYgfDwcHh7e+PKlStISEhAamoqEhMTAQCbNm2Cm5sb2rVrh5ycHEyePBkjRozA4MGDAdyM0qdPn47Zs2cjICAAgYGBWLduHY4ePYrNmzcDuNkT1a9fP7Rr1w5LlizBr7/+Kp3f09MTADB48GD4+/sjIiIC7777LoqLizFt2jSMGzcOGs3NYa5Ro0Zh7ty5iI6OxowZM5Cbm4uFCxdi1qxZnDRORETNmgECBpjW62rq8c2VRQOpwsJCREREID8/H1qtFt26dUNiYiJCQ0MBAPn5+YiNjUVhYSG8vLwQGRmJmTNnGpXx6quvory8HFOmTEFxcTECAgKQnJyMDh06ALjZa3TixAmcOHECbdu2NTq2eo6TtbU1vvvuO7z88svo27cv7O3tMWrUKGmdKeBmr1hycjJiYmIQHByMVq1aITY21mj+ExERESkLHxFzl5WWlkKr1eL0Ec8mO0cqo0Jr6SrU6fsrXSxdhdvaXdDB0lW4rYI8lztnshD7c010nsp/OZ1v2n8qnc438cnmZ4otXYU6VZ04bekq1OqGuI5UbENJSYk0OmJu1b9JF4+1Nctkc53f+Uatb1Nk8cnmREREZFlVQqDKxH4VU49vrppmlwgRERFRM8AeKSIiIoXjZHP5GEgREREpnAECVQykZOHQHhEREZFM7JEiIiJSOA7tycdAioiISOF41558HNojIiIikok9UkRERApn+G8ytQwlYiBFRESkcFVmuGvP1OObKwZSREREClclbiZTy1AizpEiIiIikok9UkRERArHOVLyMZAiIiJSOANUqILK5DKUiEN7RERERDIxkCIiIlI4gzBPqq9FixahZ8+eaNmyJdzd3TFixAgcO3bstsd8+eWXCA0NhZubGzQaDfR6Pf7zn/+Y+M5Nx0CKiIhI4ar+O7RnaqqvXbt2ISYmBunp6UhOTsaNGzcwePBglJWV1XnM7t27ERoaiu3bt2P//v3o378/hg0bhqysLHM0gWycI0VERER3VWJiotHrNWvWwN3dHfv378df//rXWo/54IMPjF4vXLgQ27ZtwzfffIOgoKDGquodMZAiIiJSuIb2KNVVBgCUlpYabVer1VCr1bc9tqSkBADg4uJS7/MZDAZcuXKlQcc0Bg7tERERKZxBqMySAMDb2xtarVZKixYtuu25hRCIjY3FQw89hK5du9a7zu+99x7Kysrw9NNPm/TeTcUeKSIiIjKbc+fOQaPRSK/v1Bs1ceJE/PLLL9izZ0+9z7Fx40bMmTMH27Ztg7u7u+y6mgMDKSIiIoUz59CeRqMxCqRu55VXXsHXX3+N3bt3o23btvU65vPPP8cLL7yATZs2YdCgQbLray4MpIiIiBSuClaoMnG2T1UD8goh8Morr2Dr1q1ITU1F+/bt63Xcxo0b8fzzz2Pjxo0YOnSovIqaGQMpIiIihRO3zHEypYz6iomJwYYNG7Bt2za0bNkSBQUFAACtVgt7e3sAQFxcHC5cuIBPP/0UwM0gKjIyEh9++CF69+4tHWNvbw+tVmtS3U3ByeZERER0V61YsQIlJSXo168fvLy8pPT5559LefLz85GXlye9XrVqFW7cuIGYmBijYyZPnmyJtyBhjxQREZHCmXOOVH0Icedl0NeuXWv0OjU1tYE1ujsYSBERESlclbBClTBxjlQDHhFzL+HQHhEREZFM7JEiIiJSOANUMJjYt2KAMrukGEgREREp3N2eI3UvYSBlIbaqFlCrmubIath9hy1dhTqFWboCdxJg6QoQ0b2itLTUorf1U/0wkCIiIlI480w259AeERERKdDNOVKmDc2Zenxz1TTHloiIiIiaAfZIERERKZzBDM/a4117REREpEicIyUfAykiIiKFM8CK60jJxDlSRERERDKxR4qIiEjhqoQKVcLEBTlNPL65YiBFRESkcFVmmGxexaE9IiIiImoI9kgREREpnEFYwWDiXXsG3rVHRERESsShPfk4tEdEREQkE3ukiIiIFM4A0++6M5inKs0OAykiIiKFM8+CnMoc5FLmuyYiIiIyA/ZIERERKZx5nrWnzL4ZBlJEREQKZ4AKBpg6R4ormxMREZECsUdKPmW+ayIiIiIzYI8UERGRwplnQU5l9s0wkCIiIlI4g1DBYOo6UiYe31wpM3wkIiIiMgP2SBERESmcwQxDe0pdkJOBFBERkcIZhBUMJt51Z+rxzZUy3zURERGRGbBHioiISOGqoEKViQtqmnp8c8VAioiISOE4tCefMt81ERERkRmwR4qIiEjhqmD60FyVearS7DCQIiIiUjgO7cnHQIqIiEjh+NBi+Sz6rlesWIFu3bpBo9FAo9FAr9djx44d0v7CwkJER0dDp9PBwcEBYWFhyM3NrVFOWloaBgwYAEdHRzg7O6Nfv364du2atH/BggXo06cPHBwc4OzsXGtdVCpVjbRy5UqjPDk5OQgJCYG9vT3atGmDefPmQQhhnsYgIiKiZseiPVJt27bF4sWL0bFjRwDAunXrMHz4cGRlZcHf3x8jRoyAjY0Ntm3bBo1Gg/j4eAwaNAiHDx+Go6MjgJtBVFhYGOLi4rB06VLY2triwIEDsLL6X4xYWVmJkSNHQq/X41//+led9VmzZg3CwsKk11qtVvr/0tJShIaGon///sjIyMDx48cRHR0NR0dHTJ061dxNQ0REdNcIqGAwcY6U4PIHd9+wYcOMXi9YsAArVqxAeno6bGxskJ6ejoMHD6JLly4AgOXLl8Pd3R0bN27E2LFjAQBTpkzBpEmT8MYbb0jl3H///Ublzp07FwCwdu3a29bH2dkZnp6ete5bv349ysvLsXbtWqjVanTt2hXHjx9HfHw8YmNjoVIp8wIiIqLmj0N78jWZd11VVYWEhASUlZVBr9ejoqICAGBnZyflsba2hq2tLfbs2QMAKCoqwt69e+Hu7o4+ffrAw8MDISEh0v6GmjhxIlxdXdGzZ0+sXLkSBoNB2peWloaQkBCo1Wpp25AhQ3Dx4kWcOXOmzjIrKipQWlpqlIiIiOjeYPFAKicnB05OTlCr1XjppZewdetW+Pv7o1OnTvDx8UFcXBwuXbqEyspKLF68GAUFBcjPzwcAnDp1CgAwZ84cjBs3DomJiejevTsGDhxY61yq25k/fz42bdqEnTt34tlnn8XUqVOxcOFCaX9BQQE8PDyMjql+XVBQUGe5ixYtglarlZK3tzcAwFqlarKJiIiUxSBUZklKZPG79vz8/JCdnY3Lly9jy5YtiIqKwq5du+Dv748tW7bghRdegIuLC6ytrTFo0CCEh4dLx1b3GI0fPx5jxowBAAQFBeH777/H6tWrsWjRonrX46233pL+PzAwEAAwb948o+1/Hr6rnmh+u2G9uLg4xMbGSq9LS0ulYIqIiKgpqIIVqkzsWzH1+ObK4oGUra2tNNk8ODgYGRkZ+PDDD7Fq1Sr06NED2dnZKCkpQWVlJdzc3NCrVy8EBwcDALy8vAAA/v7+RmV27twZeXl5JtWrd+/eKC0tRWFhITw8PODp6Vmj56moqAgAavRU3UqtVhsNBxIREdG9o8mFj0IIaX5UNa1WCzc3N+Tm5iIzMxPDhw8HAPj6+kKn0+HYsWNG+Y8fPw4fHx+T6pGVlQU7OztpuQS9Xo/du3ejsrJSypOUlASdTgdfX1+TzkVERGRJHNqTz6I9UjNmzEB4eDi8vb1x5coVJCQkIDU1FYmJiQCATZs2wc3NDe3atUNOTg4mT56MESNGYPDgwQBuDqlNnz4ds2fPRkBAAAIDA7Fu3TocPXoUmzdvls6Tl5eH4uJi5OXloaqqCtnZ2QCAjh07wsnJCd988w0KCgqg1+thb2+PlJQUvPnmm3jxxRel3qRRo0Zh7ty5iI6OxowZM5Cbm4uFCxdi1qxZvGOPiIiaNQOsYDCxb8XU45sriwZShYWFiIiIQH5+PrRaLbp164bExESEhoYCAPLz8xEbG4vCwkJ4eXkhMjISM2fONCrj1VdfRXl5OaZMmYLi4mIEBAQgOTkZHTp0kPLMmjUL69atk14HBQUBAFJSUtCvXz/Y2Nhg+fLliI2NhcFgwH333Yd58+YhJiZGOkar1SI5ORkxMTEIDg5Gq1atEBsbazT/iYiIiJRFJbg0911VWloKrVaLgmPe0LRsmtG7vdcZS1eBiEjxqn8vSkpKoNFoGvUcE/7vCaidbEwqq+Lqdax4+MtGrW9TZPHJ5kRERGRZ5pjjxDlSREREpEhCWMFg4srkgiubExEREVFDsEeKiIhI4aqgQpWJDx029fjmioEUERGRwhmE6XOcDAq9dY1De0REREQysUeKiIhI4QxmmGxu6vHNFQMpIiIihTNABYOJc5xMPb65Umb4SERERGQG7JEiIiJSuCqhQpWJk81NPb65YiBFRESkcJwjJZ8y3zURERGRGbBHioiISOEMMMOz9jjZnIiIiJRI/PeuPVOSaEAgtWjRIvTs2RMtW7aEu7s7RowYgWPHjt3xuF27dqFHjx6ws7PDfffdh5UrV5ryts2CgRQREZHCGYTKLKm+du3ahZiYGKSnpyM5ORk3btzA4MGDUVZWVucxp0+fxiOPPIKHH34YWVlZmDFjBiZNmoQtW7aYowlk49AeERER3VWJiYlGr9esWQN3d3fs378ff/3rX2s9ZuXKlWjXrh0++OADAEDnzp2RmZmJJUuW4Mknn2zsKteJgRQREZHCmfOuvdLSUqPtarUaarX6tseWlJQAAFxcXOrMk5aWhsGDBxttGzJkCP71r3/h+vXrsLGxkVNtk3Foj4iISOHMObTn7e0NrVYrpUWLFt323EIIxMbG4qGHHkLXrl3rzFdQUAAPDw+jbR4eHrhx4wZ+++030xtBJvZIERERkdmcO3cOGo1Gen2n3qiJEyfil19+wZ49e+5YtkplPA9LCFHr9ruJgRQREZHCmfNZexqNxiiQup1XXnkFX3/9NXbv3o22bdveNq+npycKCgqMthUVFaFFixZo3bq1vEqbAQMpIiIihWvoXXd1lVFfQgi88sor2Lp1K1JTU9G+ffs7HqPX6/HNN98YbUtKSkJwcLDF5kcBnCNFREREd1lMTAz+/e9/Y8OGDWjZsiUKCgpQUFCAa9euSXni4uIQGRkpvX7ppZdw9uxZxMbG4siRI1i9ejX+9a9/Ydq0aZZ4CxIGUkRERAp3t9eRWrFiBUpKStCvXz94eXlJ6fPPP5fy5OfnIy8vT3rdvn17bN++HampqQgMDMT8+fPxj3/8w6JLHwAc2iMiIlI8Swzt3cnatWtrbAsJCcHPP//ckGo1OvZIEREREcnEHikiIiKFu9s9UvcSBlJEREQKJwCTlz+482DdvYmBFBERkcKxR0o+zpEiIiIikok9UkRERArHHin5GEhZiNV//yMiIrI0BlLy8ZeciIiISCb2SBERESkce6TkYyBFRESkcEKoIEwMhEw9vrni0B4RERGRTOyRIiIiUjgDVCYvyGnq8c0VAykiIiKF4xwp+Ti0R0RERCQTe6SIiIgUjpPN5WMgRUREpHAc2pOPgRQREZHCsUdKPs6RIiIiIpKJPVJEREQKJ8wwtKfUHikGUkRERAonAAhhehlKxKE9IiIiIpnYI0VERKRwBqig4srmsjCQIiIiUjjetScfh/aIiIiIZGKPFBERkcIZhAoqLsgpCwMpIiIihRPCDHftKfS2PQ7tEREREcnEHikiIiKF42Rz+RhIERERKRwDKfkYSBERESkcJ5vLxzlSRERERDKxR4qIiEjheNeefAykiIiIFO5mIGXqHCkzVaaZ4dAeERERkUzskSIiIlI43rUnHwMpIiIihRP/TaaWoUQc2iMiIiKSiT1SRERECsehPfkYSBERESkdx/Zks+jQ3ooVK9CtWzdoNBpoNBro9Xrs2LFD2l9YWIjo6GjodDo4ODggLCwMubm5NcpJS0vDgAED4OjoCGdnZ/Tr1w/Xrl2T9i9YsAB9+vSBg4MDnJ2da61LXl4ehg0bBkdHR7i6umLSpEmorKw0ypOTk4OQkBDY29ujTZs2mDdvHoRS7/ckIqJ7x397pExJUGiPlEUDqbZt22Lx4sXIzMxEZmYmBgwYgOHDh+PQoUMQQmDEiBE4deoUtm3bhqysLPj4+GDQoEEoKyuTykhLS0NYWBgGDx6Mffv2ISMjAxMnToSV1f/eWmVlJUaOHIkJEybUWo+qqioMHToUZWVl2LNnDxISErBlyxZMnTpVylNaWorQ0FDodDpkZGRg6dKlWLJkCeLj4xuvgYiIiKhJU4km1qXi4uKCd999Fw8//DD8/Pxw8OBBdOnSBcDNgMfd3R1vv/02xo4dCwDo3bs3QkNDMX/+/DuWvXbtWrz66qu4fPmy0fYdO3bg0Ucfxblz56DT6QAACQkJiI6ORlFRETQaDVasWIG4uDgUFhZCrVYDABYvXoylS5fi/PnzUKnqF4mXlpZCq9Wi6JgPNC2b5lx/tdcpS1eBiEjxqn8vSkpKoNFoGvUc7de8CSsHO5PKMvxRjtNjFjRqfZuiJvNLXlVVhYSEBJSVlUGv16OiogIAYGf3vw/W2toatra22LNnDwCgqKgIe/fuhbu7O/r06QMPDw+EhIRI++srLS0NXbt2lYIoABgyZAgqKiqwf/9+KU9ISIgURFXnuXjxIs6cOVNn2RUVFSgtLTVKRERETYmpw3rmmKzeXFk8kMrJyYGTkxPUajVeeuklbN26Ff7+/ujUqRN8fHwQFxeHS5cuobKyEosXL0ZBQQHy8/MBAKdO3ew5mTNnDsaNG4fExER0794dAwcOrHUuVV0KCgrg4eFhtK1Vq1awtbVFQUFBnXmqX1fnqc2iRYug1Wql5O3tDQCwgqrJJiIiIqofiwdSfn5+yM7ORnp6OiZMmICoqCgcPnwYNjY22LJlC44fPw4XFxc4ODggNTUV4eHhsLa2BgAYDAYAwPjx4zFmzBgEBQXh/fffh5+fH1avXt2getQ2NCeEMNr+5zzVo6K3G9aLi4tDSUmJlM6dO9egehERETW66snipiYFsvjyB7a2tujYsSMAIDg4GBkZGfjwww+xatUq9OjRA9nZ2SgpKUFlZSXc3NzQq1cvBAcHAwC8vLwAAP7+/kZldu7cGXl5efWug6enJ/bu3Wu07dKlS7h+/brU6+Tp6Vmj56moqAgAavRU3UqtVhsNBxIRETU1Nx9abHoZSmTxHqk/E0JI86OqabVauLm5ITc3F5mZmRg+fDgAwNfXFzqdDseOHTPKf/z4cfj4+NT7nHq9HgcPHpSGDAEgKSkJarUaPXr0kPLs3r3baEmEpKQk6HQ6+Pr6NvRtEhER0T3Aoj1SM2bMQHh4OLy9vXHlyhUkJCQgNTUViYmJAIBNmzbBzc0N7dq1Q05ODiZPnowRI0Zg8ODBAG4OqU2fPh2zZ89GQEAAAgMDsW7dOhw9ehSbN2+WzpOXl4fi4mLk5eWhqqoK2dnZAICOHTvCyckJgwcPhr+/PyIiIvDuu++iuLgY06ZNw7hx46Q7D0aNGoW5c+ciOjoaM2bMQG5uLhYuXIhZs2bV+449IiKiJokLcspm0UCqsLAQERERyM/Ph1arRbdu3ZCYmIjQ0FAAQH5+PmJjY1FYWAgvLy9ERkZi5syZRmW8+uqrKC8vx5QpU1BcXIyAgAAkJyejQ4cOUp5Zs2Zh3bp10uugoCAAQEpKCvr16wdra2t89913ePnll9G3b1/Y29tj1KhRWLJkiXSMVqtFcnIyYmJiEBwcjFatWiE2NhaxsbGN2URERESNjo+Ika/JrSN1r6tes+O3Y75Ndh0pG6+Tlq4CEZHi3c11pNp9PMss60jlvThPcetIWXyyORERETUB7FaRhYEUERGRwnFoTz4GUkRERErHyeayNc1JOkRERETNAHukiIiIFE/132RqGcrDQIqIiEjpOLQnG4f2iIiIiGRijxQREZHSsUdKNgZSRERESidUN5OpZSgQh/aIiIiIZGKPFBERkcIJcTOZWoYSsUeKiIhI6YSZUgPs3r0bw4YNg06ng0qlwldffXXHY9avX4+AgAA4ODjAy8sLY8aMwe+//96wE5sZAykiIiK668rKyhAQEICPPvqoXvn37NmDyMhIvPDCCzh06BA2bdqEjIwMjB07tpFrensc2iMiIlI6C0w2Dw8PR3h4eL3zp6enw9fXF5MmTQIAtG/fHuPHj8c777zToPOaG3ukiIiIFE4lzJMaU58+fXD+/Hls374dQggUFhZi8+bNGDp0aOOe+A4YSBERESmdGedIlZaWGqWKigqzVLFPnz5Yv349nnnmGdja2sLT0xPOzs5YunSpWcqXi4EUERERmY23tze0Wq2UFi1aZJZyDx8+jEmTJmHWrFnYv38/EhMTcfr0abz00ktmKV8uzpEiIiJSOjPOkTp37hw0Go20Wa1Wm1bufy1atAh9+/bF9OnTAQDdunWDo6MjHn74Yfz973+Hl5dXrcf94x//qPc5qudfNQQDKSIiIqUz4yNiNBqNUSBlLn/88QdatDAOW6ytrW+e+jaLWL3//vtGr3/99Vf88ccfcHZ2BgBcvnwZDg4OcHd3lxVIcWiPiIiI7rqrV68iOzsb2dnZAIDTp08jOzsbeXl5AIC4uDhERkZK+YcNG4Yvv/wSK1aswKlTp/Djjz9i0qRJePDBB6HT6eo8z+nTp6W0YMECBAYG4siRIyguLkZxcTGOHDmC7t27Y/78+bLeB3ukiIiIlM4CDy3OzMxE//79pdexsbEAgKioKKxduxb5+flSUAUA0dHRuHLlCj766CNMnToVzs7OGDBgAN5+++16n3PmzJnYvHkz/Pz8pG1+fn54//338dRTT2H06NENexNgIEVEREQWCKT69et32yG5tWvX1tj2yiuv4JVXXmlgxf4nPz8f169fr7G9qqoKhYWFssrk0B4REREpwsCBAzFu3DhkZmZKQVxmZibGjx+PQYMGySqTgRQREZHSVd+1Z2pq4lavXo02bdrgwQcfhJ2dHdRqNXr16gUvLy/885//lFUmh/aIiIgUzhwrkzf2yubm4Obmhu3bt+P48eM4evQohBDo3LkzHnjgAdllMpAiIiIiRXnggQdMCp5uxUCKiIhI6Sww2dxSzp8/j6+//hp5eXmorKw02hcfH9/g8hocSEVHR+P555/HX//61wafjIiIiMhSvv/+ezz22GNo3749jh07hq5du+LMmTMQQqB79+6yymzwZPMrV65g8ODBuP/++7Fw4UJcuHBB1omJiIioaVDhf/OkZCdLv4l6iIuLw9SpU3Hw4EHY2dlhy5YtOHfuHEJCQjBy5EhZZTY4kNqyZQsuXLiAiRMnYtOmTfD19UV4eDg2b95c69oMRERERE3BkSNHEBUVBQBo0aIFrl27BicnJ8ybN69BC3veStbyB61bt8bkyZORlZWFffv2oWPHjoiIiIBOp8OUKVOQm5srqzJKYq2yarKJiIgURiHLHzg6OqKiogIAoNPpcPLkSWnfb7/9JqtMk3418/PzkZSUhKSkJFhbW+ORRx7BoUOH4O/vX+MhgURERNRECTOlJq5379748ccfAQBDhw7F1KlTsWDBAjz//PPo3bu3rDIbPNn8+vXr+Prrr7FmzRokJSWhW7dumDJlCkaPHo2WLVsCABISEjBhwgRMmTJFVqWIiIiIzC0+Ph5Xr14FAMyZMwdXr17F559/jo4dO8ruAGpwIOXl5QWDwYDnnnsO+/btQ2BgYI08Q4YMgbOzs6wKERER0V2mkOUP7rvvPun/HRwcsHz5cpPLbHAg9f7772PkyJGws7OrM0+rVq1w+vRpkypGREREd4dSVjYHgMuXL2Pz5s04efIkpk+fDhcXF/z888/w8PBAmzZtGlxegwOpiIiIBp+EiIiIyNJ++eUXDBo0CFqtFmfOnMG4cePg4uKCrVu34uzZs/j0008bXCZv0SIiIlI6hUw2j42NRXR0NHJzc41G1sLDw7F7925ZZfIRMUREREqnkDlSGRkZWLVqVY3tbdq0QUFBgawy2SNFREREimBnZ4fS0tIa248dOwY3NzdZZTKQIiIiUjiTHw9jhsnqd8Pw4cMxb9486UksKpUKeXl5eOONN/Dkk0/KKpOBFBERkdIpZGXzJUuW4Ndff4W7uzuuXbuGkJAQdOzYEU5OTliwYIGsMjlHioiISOkUMkdKo9Fgz549SElJwf79+2EwGNC9e3cMGjRIdpkMpIiIiEgxvv/+e3z//fcoKiqCwWDA0aNHsWHDBgDA6tWrG1weAykiIiKFU8qCnHPnzsW8efMQHBwMLy8vqFSmD0cykCIiIlI6hQztrVy5EmvXrjXr4uKcbE5ERESKUFlZiT59+pi1TAZSRERESmeOpQ+aQY/U2LFjpflQ5sKhPSIiIqW7h4f2YmNjpf83GAz4+OOPsXPnTnTr1g02NjZGeePj4xtcPgMpIiIiumdlZWUZvQ4MDAQAHDx40Gi73InnDKSIiIiU7h7ukUpJSWnU8hlIERERKZxSlj9oDJxsTkRERCQTAykiIiIimTi0R0REpHT38BypxsZAioiISOE4R0o+Du0RERERycQeKSIiIlLs0JypGEgREREpHedIycahPSIiIiKZ2CNFRESkcJxsLh8DKSIiIqXj0J5sHNojIiIikok9UkRERArHoT35LNojtWLFCnTr1g0ajQYajQZ6vR47duyQ9hcWFiI6Oho6nQ4ODg4ICwtDbm5ujXLS0tIwYMAAODo6wtnZGf369cO1a9ek/ZcuXUJERAS0Wi20Wi0iIiJw+fJlozJUKlWNtHLlSqM8OTk5CAkJgb29Pdq0aYN58+ZBCIVeOUREdO8QZkoKZNEeqbZt22Lx4sXo2LEjAGDdunUYPnw4srKy4O/vjxEjRsDGxgbbtm2DRqNBfHw8Bg0ahMOHD8PR0RHAzSAqLCwMcXFxWLp0KWxtbXHgwAFYWf0vRhw1ahTOnz+PxMREAMCLL76IiIgIfPPNN0b1WbNmDcLCwqTXWq1W+v/S0lKEhoaif//+yMjIwPHjxxEdHQ1HR0dMnTq10dqIiIiImi6LBlLDhg0zer1gwQKsWLEC6enpsLGxQXp6Og4ePIguXboAAJYvXw53d3ds3LgRY8eOBQBMmTIFkyZNwhtvvCGVc//990v/f+TIESQmJiI9PR29evUCAHzyySfQ6/U4duwY/Pz8pLzOzs7w9PSsta7r169HeXk51q5dC7Vaja5du+L48eOIj49HbGwsVCqVeRqFiIjobuNkc9mazGTzqqoqJCQkoKysDHq9HhUVFQAAOzs7KY+1tTVsbW2xZ88eAEBRURH27t0Ld3d39OnTBx4eHggJCZH2Azd7rLRarRREAUDv3r2h1Wrx008/GdVh4sSJcHV1Rc+ePbFy5UoYDAajckJCQqBWq6VtQ4YMwcWLF3HmzJk631dFRQVKS0uNEhERUVNSPUfK1KREFg+kcnJy4OTkBLVajZdeeglbt26Fv78/OnXqBB8fH8TFxeHSpUuorKzE4sWLUVBQgPz8fADAqVOnAABz5szBuHHjkJiYiO7du2PgwIHSXKqCggK4u7vXOK+7uzsKCgqk1/Pnz8emTZuwc+dOPPvss5g6dSoWLlwo7S8oKICHh4dRGdWvby3nzxYtWiTNzdJqtfD29pbZUkRERI2Ec6Rks3gg5efnh+zsbKSnp2PChAmIiorC4cOHYWNjgy1btuD48eNwcXGBg4MDUlNTER4eDmtrawCQeozGjx+PMWPGICgoCO+//z78/PywevVq6Ry1DbsJIYy2v/XWW9Dr9QgMDMTUqVMxb948vPvuu0bH/Lmc6onmtxvWi4uLQ0lJiZTOnTvXwBYiIiKipsriyx/Y2tpKk82Dg4ORkZGBDz/8EKtWrUKPHj2QnZ2NkpISVFZWws3NDb169UJwcDAAwMvLCwDg7+9vVGbnzp2Rl5cHAPD09ERhYWGN8/766681ephu1bt3b5SWlqKwsBAeHh7w9PSs0fNUVFQEALctR61WGw0HEhERNTmcIyWbxXuk/kwIIc2PqqbVauHm5obc3FxkZmZi+PDhAABfX1/odDocO3bMKP/x48fh4+MDANDr9SgpKcG+ffuk/Xv37kVJSQn69OlTZz2ysrJgZ2cHZ2dnqZzdu3ejsrJSypOUlASdTgdfX19T3jIREZFFcY6UfBbtkZoxYwbCw8Ph7e2NK1euICEhAampqdIyBZs2bYKbmxvatWuHnJwcTJ48GSNGjMDgwYMB3BxSmz59OmbPno2AgAAEBgZi3bp1OHr0KDZv3gzgZu9UWFgYxo0bh1WrVgG4ufzBo48+Kt2x980336CgoAB6vR729vZISUnBm2++iRdffFHqTRo1ahTmzp2L6OhozJgxA7m5uVi4cCFmzZrFO/aIiIgUyqKBVGFhISIiIpCfnw+tVotu3bohMTERoaGhAID8/HzExsaisLAQXl5eiIyMxMyZM43KePXVV1FeXo4pU6aguLgYAQEBSE5ORocOHaQ869evx6RJk6QA7LHHHsNHH30k7bexscHy5csRGxsLg8GA++67D/PmzUNMTIyUR6vVIjk5GTExMQgODkarVq0QGxuL2NjYxmwiIiKixsehPdlUgktz31WlpaXQarW4dPw+aFo2uZFVAICVZ83V44mI6O6q/r0oKSmBRqNp1HN0nrgQ1mq7Ox9wG1UV5Tjy0YxGrW9T1DR/yYmIiIiaAYvftUdEREQWxqE92RhIERERKR0DKdk4tEdEREQkE3ukiIiIFE7132RqGUrEQIqIiEjpOLQnGwMpIiIihTPHyuRKXdmcc6SIiIiIZGKPFBERkdJxaE82BlJERESk2EDIVBzaIyIiortu9+7dGDZsGHQ6HVQqFb766qs7HlNRUYE333wTPj4+UKvV6NChA1avXt34lb0N9kgREREpnCUmm5eVlSEgIABjxozBk08+Wa9jnn76aRQWFuJf//oXOnbsiKKiIty4cUNGbc2HgRQREZHSWWCOVHh4OMLDw+udPzExEbt27cKpU6fg4uICAPD19W3YSRsBh/aIiIjIbEpLS41SRUWFWcr9+uuvERwcjHfeeQdt2rTBAw88gGnTpuHatWtmKV8u9kgREREpnDmH9ry9vY22z549G3PmzDGtcACnTp3Cnj17YGdnh61bt+K3337Dyy+/jOLiYovOk2IgRUREpHRmHNo7d+4cNBqNtFmtVptY8E0GgwEqlQrr16+HVqsFAMTHx+Opp57CsmXLYG9vb5bzNBSH9oiIiMhsNBqNUTJXIOXl5YU2bdpIQRQAdO7cGUIInD9/3iznkIOBFBERkcJVD+2ZmhpT3759cfHiRVy9elXadvz4cVhZWaFt27aNe/LbYCBFRESkdMJMqQGuXr2K7OxsZGdnAwBOnz6N7Oxs5OXlAQDi4uIQGRkp5R81ahRat26NMWPG4PDhw9i9ezemT5+O559/3mLDegADKSIiIrJAIJWZmYmgoCAEBQUBAGJjYxEUFIRZs2YBAPLz86WgCgCcnJyQnJyMy5cvIzg4GKNHj8awYcPwj3/8Q+67NgtONiciIqK7rl+/fhCi7uhr7dq1NbZ16tQJycnJjVirhmMgRUREpHCWWNn8XsFAioiISOkssLL5vYJzpIiIiIhkYo8UERGRwqmEgOo285XqW4YSMZAiIiJSOg7tycahPSIiIiKZ2CNFRESkcLxrTz4GUkRERErHoT3ZOLRHREREJBN7pIiIiBSOQ3vyMZAiIiJSOg7tycZAioiISOHYIyUf50gRERERycQeKSIiIqXj0J5sDKSIiIhIsUNzpuLQHhEREZFM7JEiIiJSOiFuJlPLUCAGUkRERArHu/bk49AeERERkUzskSIiIlI63rUnGwMpIiIihVMZbiZTy1AiDu0RERERycQeKSIiIqXj0J5sDKSIiIgUjnftycdAioiISOm4jpRsnCNFREREJBN7pIiIiBSOQ3vyMZAiIiJSOk42l41De0REREQysUeKiIhI4Ti0Jx8DKSIiIqXjXXuycWiPiIiISCb2SBERESkch/bkYyBFRESkdLxrTzYO7RERERHJxB4pIiIihePQnnwMpIiIiJTOIG4mU8tQIAZSRERESsc5UrJxjhQRERGRTOyRIiIiUjgVzDBHyiw1aX4YSBERESkdVzaXjUN7RERERDJZNJBasWIFunXrBo1GA41GA71ejx07dkj7CwsLER0dDZ1OBwcHB4SFhSE3N7dGOWlpaRgwYAAcHR3h7OyMfv364dq1a9L+S5cuISIiAlqtFlqtFhEREbh8+bJRGXl5eRg2bBgcHR3h6uqKSZMmobKy0ihPTk4OQkJCYG9vjzZt2mDevHkQCo3AiYjo3lG9/IGpSYksGki1bdsWixcvRmZmJjIzMzFgwAAMHz4chw4dghACI0aMwKlTp7Bt2zZkZWXBx8cHgwYNQllZmVRGWloawsLCMHjwYOzbtw8ZGRmYOHEirKz+99ZGjRqF7OxsJCYmIjExEdnZ2YiIiJD2V1VVYejQoSgrK8OePXuQkJCALVu2YOrUqVKe0tJShIaGQqfTISMjA0uXLsWSJUsQHx9/dxqLiIiosQgzJQVSiSbWpeLi4oJ3330XDz/8MPz8/HDw4EF06dIFwM2Ax93dHW+//TbGjh0LAOjduzdCQ0Mxf/78Wss7cuQI/P39kZ6ejl69egEA0tPTodfrcfToUfj5+WHHjh149NFHce7cOeh0OgBAQkICoqOjUVRUBI1GgxUrViAuLg6FhYVQq9UAgMWLF2Pp0qU4f/48VKr6TbMrLS2FVqvFpeP3QdOyaY6sWnnW7PUjIqK7q/r3oqSkBBqNplHP8VD/OWjRws6ksm7cKMeelDmNWt+mqMn8kldVVSEhIQFlZWXQ6/WoqKgAANjZ/e+Dtba2hq2tLfbs2QMAKCoqwt69e+Hu7o4+ffrAw8MDISEh0n7gZo+VVquVgijgZvCl1Wrx008/SXm6du0qBVEAMGTIEFRUVGD//v1SnpCQECmIqs5z8eJFnDlzps73VVFRgdLSUqNERETUlKiEMEtSIosHUjk5OXBycoJarcZLL72ErVu3wt/fH506dYKPjw/i4uJw6dIlVFZWYvHixSgoKEB+fj4A4NSpUwCAOXPmYNy4cUhMTET37t0xcOBAaS5VQUEB3N3da5zX3d0dBQUFUh4PDw+j/a1atYKtre1t81S/rs5Tm0WLFklzs7RaLby9veU0ExERUeMxmCkpkMUDKT8/P2RnZyM9PR0TJkxAVFQUDh8+DBsbG2zZsgXHjx+Hi4sLHBwckJqaivDwcFhbWwMADIabn9r48eMxZswYBAUF4f3334efnx9Wr14tnaO2YTchhNF2OXmqR0VvN6wXFxeHkpISKZ07d64+zUJERETNgMXXkbK1tUXHjh0BAMHBwcjIyMCHH36IVatWoUePHsjOzkZJSQkqKyvh5uaGXr16ITg4GADg5eUFAPD39zcqs3PnzsjLywMAeHp6orCwsMZ5f/31V6lHydPTE3v37jXaf+nSJVy/ft0oz597noqKigCgRk/VrdRqtdFwIBERUVNjjqE5Du01EUIIaX5UNa1WCzc3N+Tm5iIzMxPDhw8HAPj6+kKn0+HYsWNG+Y8fPw4fHx8AgF6vR0lJCfbt2yft37t3L0pKStCnTx8pz8GDB6UhQwBISkqCWq1Gjx49pDy7d+82WhIhKSkJOp0Ovr6+5msAIiKiu4137clm0R6pGTNmIDw8HN7e3rhy5QoSEhKQmpqKxMREAMCmTZvg5uaGdu3aIScnB5MnT8aIESMwePBgADeH1KZPn47Zs2cjICAAgYGBWLduHY4ePYrNmzcDuNk7FRYWhnHjxmHVqlUAgBdffBGPPvoo/Pz8AACDBw+Gv78/IiIi8O6776K4uBjTpk3DuHHjpDsPRo0ahblz5yI6OhozZsxAbm4uFi5ciFmzZtX7jj0iIqImiSuby2bRQKqwsBARERHIz8+HVqtFt27dkJiYiNDQUABAfn4+YmNjUVhYCC8vL0RGRmLmzJlGZbz66qsoLy/HlClTUFxcjICAACQnJ6NDhw5SnvXr12PSpElSAPbYY4/ho48+kvZbW1vju+++w8svv4y+ffvC3t4eo0aNwpIlS6Q8Wq0WycnJiImJQXBwMFq1aoXY2FjExsY2ZhMRERFRE9bk1pG613EdKSIiqo+7uY5USJ+ZZllHatdP8xW3jpTFJ5sTERGRhXFoT7am2SVCRERE1AywR4qIiEjhVIabydQylIiBFBERkdJxaE82Du0RERERycQeKSIiIqUzx4KayuyQYiBFRESkdHxEjHwc2iMiIiKSiYEUERGR0lVPNjc1NcDu3bsxbNgw6HQ6qFQqfPXVV/U+9scff0SLFi0QGBjYsPfZCBhIERERKZ0AYDAxNXBkr6ysDAEBAUaPbKuPkpISREZGYuDAgQ07YSPhHCkiIiKFs8QcqfDwcISHhzf4POPHj8eoUaNgbW3doF6sxsIeKSIiIjKb0tJSo1RRUWG2stesWYOTJ09i9uzZZivTVAykiIiIlE7ADHOkbhbl7e0NrVYrpUWLFpmlirm5uXjjjTewfv16tGjRdAbUmk5NiIiIyDLMuLL5uXPnoNFopM1qtdq0cgFUVVVh1KhRmDt3Lh544AGTyzMnBlJERERkNhqNxiiQMocrV64gMzMTWVlZmDhxIgDAYDBACIEWLVogKSkJAwYMMOs564uBFBERkdIZAKjMUEYj0Wg0yMnJMdq2fPly/PDDD9i8eTPat2/feCe/AwZSRERECmeJu/auXr2KEydOSK9Pnz6N7OxsuLi4oF27doiLi8OFCxfw6aefwsrKCl27djU63t3dHXZ2djW2320MpIiIiOiuy8zMRP/+/aXXsbGxAICoqCisXbsW+fn5yMvLs1T16k0lhEIfjmMhpaWl0Gq1uHT8PmhaNs2bJq08cy1dBSIixav+vSgpKTH7nKM/n2Ngl+loYW3apPAbVRX4/tC7jVrfpog9UkREREpnxrv2lKZpdokQERERNQPskSIiIlI69kjJxkCKiIhI6Zr48gdNGQMpIiIihbPE8gf3Cs6RIiIiIpKJPVJERERKxzlSsjGQIiIiUjqDAFQmBkIGZQZSHNojIiIikok9UkRERErHoT3ZGEgREREpnhkCKSgzkOLQHhEREZFM7JEiIiJSOg7tycZAioiISOkMAiYPzfGuPSIiIiJqCPZIERERKZ0w3EymlqFADKSIiIiUjnOkZGMgRUREpHScIyUb50gRERERycQeKSIiIqXj0J5sDKSIiIiUTsAMgZRZatLscGiPiIiISCb2SBERESkdh/ZkYyBFRESkdAYDABPXgTIocx0pDu0RERERycQeKSIiIqXj0J5sDKSIiIiUjoGUbBzaIyIiIpKJPVJERERKx0fEyMZAioiISOGEMEAI0+66M/X45oqBFBERkdIJYXqPEudIEREREVFDsEeKiIhI6YQZ5kgptEeKgRQREZHSGQyAysQ5TgqdI8WhPSIiIiKZ2CNFRESkdBzak42BFBERkcIJgwHCxKE9pS5/wKE9IiIiIpnYI0VERKR0HNqTjYEUERGR0hkEoGIgJQeH9oiIiIhkYo8UERGR0gkBwNR1pJTZI8VAioiISOGEQUCYOLQnFBpIWXRob8WKFejWrRs0Gg00Gg30ej127Ngh7S8sLER0dDR0Oh0cHBwQFhaG3NxcozL69esHlUpllJ599lmjPD///DNCQ0Ph7OyM1q1b48UXX8TVq1eN8vy5DJVKhZUrVxrlycnJQUhICOzt7dGmTRvMmzdPsRcOERHdQ4TBPEmBLBpItW3bFosXL0ZmZiYyMzMxYMAADB8+HIcOHYIQAiNGjMCpU6ewbds2ZGVlwcfHB4MGDUJZWZlROePGjUN+fr6UVq1aJe27ePEiBg0ahI4dO2Lv3r1ITEzEoUOHEB0dXaM+a9asMSonKipK2ldaWorQ0FDodDpkZGRg6dKlWLJkCeLj4xutfYiIiKhps+jQ3rBhw4xeL1iwACtWrEB6ejpsbGyQnp6OgwcPokuXLgCA5cuXw93dHRs3bsTYsWOl4xwcHODp6VnrOb799lvY2Nhg2bJlsLK6GTcuW7YMQUFBOHHiBDp27CjldXZ2rrOc9evXo7y8HGvXroVarUbXrl1x/PhxxMfHIzY2FiqVyqS2ICIishQO7cnXZO7aq6qqQkJCAsrKyqDX61FRUQEAsLOzk/JYW1vD1tYWe/bsMTp2/fr1cHV1RZcuXTBt2jRcuXJF2ldRUQFbW1spiAIAe3t7AKhRzsSJE+Hq6oqePXti5cqVMBj+102ZlpaGkJAQqNVqaduQIUNw8eJFnDlzxvQGICIishQO7clm8cnmOTk50Ov1KC8vh5OTE7Zu3Qp/f39cv34dPj4+iIuLw6pVq+Do6Ij4+HgUFBQgPz9fOn706NFo3749PD09cfDgQcTFxeHAgQNITk4GAAwYMACxsbF49913MXnyZJSVlWHGjBkAYFTO/PnzMXDgQNjb2+P777/H1KlT8dtvv+Gtt94CABQUFMDX19eo7h4eHtK+9u3b1/r+KioqpKAQAEpKSgAApVeb7gVn5VBq6SoQESleaenNv8V3o6fnBq6bvB7nDVw3T2WaG2FhFRUVIjc3V2RkZIg33nhDuLq6ikOHDgkhhMjMzBQBAQECgLC2thZDhgwR4eHhIjw8vM7yMjMzBQCxf/9+adv69euFh4eHsLa2Fra2tmLatGnCw8NDvP3223WWs2TJEqHRaKTXoaGh4sUXXzTKc/78eQFApKWl1VnO7Nmzq5eLZWJiYmJianA6efLkHX9L5bp27Zrw9PQ0W109PT3FtWvXGq2+TZFKiKY1qDlo0CB06NDBaMJ4SUkJKisr4ebmhl69eiE4OBjLli2r9XghBNRqNT777DM888wzRvsKCwvh6OgIlUoFjUaDhIQEjBw5stZyfvzxRzz00EMoKCiAh4cHIiMjUVJSgm3btkl5srKy0L17d5w6darePVKXL1+Gj48P8vLyoNVq690udPNfZ97e3jh37hw0Go2lq9OssO1Mw/aTj20nX0lJCdq1a4dLly7B2dm50c5TXl6OyspKs5Rla2trNCVHCSw+tPdnQgijwAOAFHDk5uYiMzMT8+fPr/P4Q4cO4fr16/Dy8qqxr3oobvXq1bCzs0NoaGid5WRlZcHOzk66ePV6PWbMmIHKykrY2toCAJKSkqDT6WoM+d1KrVYbzau69T3xj4o81ctlUMOx7UzD9pOPbSffrXN8G4OdnZ3igh9zsmggNWPGDISHh8Pb2xtXrlxBQkICUlNTkZiYCADYtGkT3Nzc0K5dO+Tk5GDy5MkYMWIEBg8eDAA4efIk1q9fj0ceeQSurq44fPgwpk6diqCgIPTt21c6z0cffYQ+ffrAyckJycnJmD59OhYvXiwFSd988w0KCgqg1+thb2+PlJQUvPnmm3jxxRelIGjUqFGYO3cuoqOjMWPGDOTm5mLhwoWYNWsW79gjIiJSKIsGUoWFhYiIiEB+fj60Wi26deuGxMREqacoPz8fsbGxKCwshJeXFyIjIzFz5kzpeFtbW3z//ff48MMPcfXqVXh7e2Po0KGYPXs2rK2tpXz79u3D7NmzcfXqVXTq1AmrVq1CRESEtN/GxgbLly9HbGwsDAYD7rvvPsybNw8xMTFSHq1Wi+TkZMTExCA4OBitWrVCbGwsYmNj70JLERERUVPU5OZI3esqKiqwaNEixMXF1TrkR3Vj28nHtjMN208+tp18bLvmgYEUERERkUxNZkFOIiIiouaGgRQRERGRTAykiIiIiGRiIEVEREQkEwOpW+zevRvDhg2DTqeDSqXCV199ZbT/yy+/xJAhQ+Dq6gqVSoXs7OwaZYwfPx4dOnSAvb093NzcMHz4cBw9etQoz4IFC9CnTx84ODjUuVptXl4ehg0bBkdHR7i6umLSpEk1Vp7NyclBSEgI7O3t0aZNG8ybN8+iT99uSu2nUqlqpJUrVxrlaUrtdzfa7syZM3jhhRfQvn172Nvbo0OHDpg9e3aN64rXnmntx2uv9u/tY489hnbt2sHOzg5eXl6IiIjAxYsXjfI0t2uvKbVdc7vu7iUMpG5RVlaGgIAAfPTRR3Xu79u3LxYvXlxnGT169MCaNWtw5MgR/Oc//4EQAoMHD0ZVVZWUp7KyEiNHjsSECRNqLaOqqgpDhw5FWVkZ9uzZg4SEBGzZsgVTp06V8pSWliI0NBQ6nQ4ZGRlYunQplixZgvj4eJnv3nRNpf2qrVmzBvn5+VKKioqS9jW19rsbbXf06FEYDAasWrUKhw4dwvvvv4+VK1dKD/EGeO2Z2n7VeO3V/N72798fX3zxBY4dO4YtW7bg5MmTeOqpp6T9zfHaayptV605XXf3lLv7aL/mA4DYunVrrftOnz4tAIisrKw7lnPgwAEBQJw4caLGvjVr1gitVltj+/bt24WVlZW4cOGCtG3jxo1CrVaLkpISIYQQy5cvF1qtVpSXl0t5Fi1aJHQ6nTAYDHesV2OzZPvd6fxCNO32uxttV+2dd94R7du3l17z2vsfOe13p/ML0bTb72623bZt24RKpRKVlZVCiOZ/7Vmy7e50fiGadts1d+yRakRlZWVYs2YN2rdvD29v73ofl5aWhq5du0Kn00nbhgwZgoqKCuzfv1/KExISYrRI25AhQ3Dx4kWcOXPGbO/BkuS2X7WJEyfC1dUVPXv2xMqVK2EwGKR993r71bftSkpK4OLiIr3mtXeT3Parxmvv9m1XXFyM9evXo0+fPrCxsQHAaw+Q33bVlHzdWRIDqUawfPlyODk5wcnJCYmJiUhOTpYedFwfBQUF0gOWq7Vq1Qq2trYoKCioM0/16+o8zZWp7QcA8+fPx6ZNm7Bz5048++yzmDp1KhYuXCjtv1fbryFtd/LkSSxduhQvvfSStI3XnmntB/Dau13bvf7663B0dETr1q2Rl5eHbdu2SfuUfO2Z2naAcq+7poCBVCMYPXo0srKysGvXLtx///14+umnUV5e3qAyansQshDCaPuf84j/Thps7g9RNkf7vfXWW9Dr9QgMDMTUqVMxb948vPvuu0Z57sX2q2/bXbx4EWFhYRg5ciTGjh1rtI/Xnmntx2uv7rabPn06srKykJSUBGtra0RGRhpNdlbqtWeOtlPqddcUWPShxfcqrVYLrVaL+++/H71790arVq2wdetWPPfcc/U63tPTE3v37jXadunSJVy/fl36F4Snp2eNf0UUFRUBQI1/dTQ3prZfbXr37o3S0lIUFhbCw8Pjnm2/+rTdxYsX0b9/f+j1enz88cdGx/PaM639asNr739t5+rqCldXVzzwwAPo3LkzvL29kZ6eDr1er+hrz9S2q41SrrumgD1Sd4EQAhUVFfXOr9frcfDgQeTn50vbkpKSoFar0aNHDynP7t27jW4NTkpKgk6ng6+vr9nq3hQ0tP1qk5WVBTs7O2m5BKW035/b7sKFC+jXrx+6d++ONWvWwMrK+E8Arz1jDW2/2vDaq3s/ACkPr73/aWjb1Uap151F3OXJ7U3alStXRFZWlsjKyhIARHx8vMjKyhJnz54VQgjx+++/i6ysLPHdd98JACIhIUFkZWWJ/Px8IYQQJ0+eFAsXLhSZmZni7Nmz4qeffhLDhw8XLi4uorCwUDrP2bNnRVZWlpg7d65wcnKSznnlyhUhhBA3btwQXbt2FQMHDhQ///yz2Llzp2jbtq2YOHGiVMbly5eFh4eHeO6550ROTo748ssvhUajEUuWLLmLLWasqbTf119/LT7++GORk5MjTpw4IT755BOh0WjEpEmTpDKaWvvdjba7cOGC6NixoxgwYIA4f/68yM/Pl1I1XnumtR+vvdrbbu/evWLp0qUiKytLnDlzRvzwww/ioYceEh06dJDuImuO115TabvmeN3dSxhI3SIlJUUAqJGioqKEEDdvt69t/+zZs4UQN//QhoeHC3d3d2FjYyPatm0rRo0aJY4ePWp0nqioqFrLSUlJkfKcPXtWDB06VNjb2wsXFxcxceJEo9tWhRDil19+EQ8//LBQq9XC09NTzJkzx6K3sTaV9tuxY4cIDAwUTk5OwsHBQXTt2lV88MEH4vr160blNKX2uxttV1cZf/73FK89+e3Ha6/2tvvll19E//79hYuLi1Cr1cLX11e89NJL4vz580Z1aW7XXlNpu+Z43d1LVEJwWVMiIiIiOThHioiIiEgmBlJEREREMjGQIiIiIpKJgRQRERGRTAykiIiIiGRiIEVEREQkEwMpIiIiIpkYSBERERHJxECKiIiISCYGUkREREQyMZAiIov49ddf4enpiYULF0rb9u7dC1tbWyQlJVmwZkRE9cdn7RGRxWzfvh0jRozATz/9hE6dOiEoKAhDhw7FBx98YOmqERHVCwMpIrKomJgY7Ny5Ez179sSBAweQkZEBOzs7S1eLiKheGEgRkUVdu3YNXbt2xblz55CZmYlu3bpZukpERPXGOVJEZFGnTp3CxYsXYTAYcPbsWUtXh4ioQdgjRUQWU1lZiQcffBCBgYHo1KkT4uPjkZOTAw8PD0tXjYioXhhIEZHFTJ8+HZs3b8aBAwfg5OSE/v37o2XLlvj2228tXTUionrh0B4RWURqaio++OADfPbZZ9BoNLCyssJnn32GPXv2YMWKFZauHhFRvbBHioiIiEgm9kgRERERycRAioiIiEgmBlJEREREMjGQIiIiIpKJgRQRERGRTAykiIiIiGRiIEVEREQkEwMpIiIiIpkYSBERERHJxECKiIiISCYGUkREREQyMZAiIiIikun/AVjYfuuO+JyIAAAAAElFTkSuQmCC",[m
[31m-      "text/plain": [[m
[31m-       "<Figure size 640x480 with 2 Axes>"[m
[31m-      ][m
[31m-     },[m
[31m-     "metadata": {},[m
[31m-     "output_type": "display_data"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "MF6_Mdl['chd_merged']['head'].isel(time=0, layer=0).isel(x=range(0,10), y=range(0,10)).plot.imshow(cmap='viridis')"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 42,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "1bc6f585",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/plain": [[m
[31m-       "<matplotlib.image.AxesImage at 0x2acabd787d0>"[m
[31m-      ][m
[31m-     },[m
[31m-     "execution_count": 42,[m
[31m-     "metadata": {},[m
[31m-     "output_type": "execute_result"[m
[31m-    },[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAloAAAHFCAYAAAAqg1fhAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjUsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvWftoOwAAAAlwSFlzAAAPYQAAD2EBqD+naQAAdkNJREFUeJzt3XtYVNX+P/D3gDBclBGU2wihqZGImJfS0QxNuSWK1VELzwhlpKlRkn0Ly1PaL9Eks7TIOqWVJmVIWioHNPFyBBQFA6+kIig3j3JRTEBm/f4gdo4DCDID6rxfz7OfnL3XWnvthTEf11p7LZkQQoCIiIiI9M6kvStAREREdK9ioEVERERkIAy0iIiIiAyEgRYRERGRgTDQIiIiIjIQBlpEREREBsJAi4iIiMhAGGgRERERGQgDLSIiIiIDYaClR2vWrIFMJkNubm57V6Xdffvtt3jmmWfg7u4OExMTdO/evdVlfvbZZ1izZo3O+dzcXMhksgav3Qs2btyIZ599Fr169YKlpSW6d++OKVOmICcnp8H027dvh0qlgpWVFbp27YrQ0FCUlJTopHv77bcRGBiIbt26QSaTITQ0tNE6nD59Gk899RQ6d+6Mjh07wsfHB4cOHWrRcxiiXo0pKSlBaGgounbtCisrK6hUKuzYsUMn3a+//oqpU6eiX79+MDMzg0wma/G9mmvkyJEYOXKkwcq/XRUVFXj//fcxcuRIODk5oWPHjujXrx+WLFmCa9euaaWt/3+toSM2NrZZ97ty5QpeffVVKJVKWFhY4KGHHmp23pZITk6GTCZDcnKy3ssmagkGWmQQ3333HY4cOYJHHnkEPXv21EuZjQVazs7OSElJwdixY/VynzvNkiVLcPXqVbz11ltISEjA//t//w8ZGRkYOHAgjhw5opV2165dCAgIgKOjIzZt2oSPP/4Y27dvx+jRo1FVVaWV9qOPPsLFixcxfvx4mJubN3r/CxcuYMSIETh58iS+/vpr/Pjjj7h27RpGjhyJEydONOsZDFGvxlRVVWH06NHYsWMHPv74Y2zatAmOjo7w9/fHrl27tNLGx8cjNTUVHh4e6N+/f4vvdS/Iy8vD8uXLMXDgQHzxxRfYvHkz/vGPf+Ddd99FYGAgGtql7eWXX0ZKSorW4ePj06z7PfXUU/jmm2/wzjvvYNu2bXj44Yfx7LPP4vvvv9f3oxHdGQTpzerVqwUAcebMmfauSoOuXr0qNBpNm9yrtrZW+vPYsWOFm5tbq8vs27ev8Pb2bnU5d5vi4mKdc+fPnxdmZmZi2rRpWucffvhh4eHhIWpqaqRz//3vfwUA8dlnn2mlvfFnZG1tLUJCQhq8/+uvvy7MzMxEbm6udK68vFx07dpVTJo0qVnPYIh6NebTTz8VAMS+ffukczU1NcLDw0M88sgjjd5r1qxZwpC/Er29ve/Iv79XrlwRV65c0Tm/dOlSAUDs2bNHOnfmzBkBQCxduvS27rVlyxYBQHz//fda5318fIRSqRTXr1+/rXIbsnPnTgFA7Ny5U29lEt0O9mgZWFJSEoKCguDi4gILCwv06tUL06dPx//+9z8pzZ49eyCTybB+/Xqd/N9++y1kMhkOHDggnUtPT8f48eNhZ2cHCwsLDBgwAD/++KNWvvphzMTERDz//POwt7eHlZWVTu+BoZiY6PevVvfu3XHkyBHs2rVLGqqoH45saOjw3XffhUwmw++//46JEydCoVDAzs4OERERuH79Ok6cOAF/f3906tQJ3bt3xwcffKBzz4qKCsydOxc9evSAubk5unXrhldffRWVlZV6fbZbcXBw0DmnVCrh4uKC/Px86dz58+dx4MABqNVqdOjQQTo/bNgwPPDAA4iPj9cqo7k/o/j4eDz++ONwc3OTztnY2OCpp57CL7/8guvXrzeZ31D1aqq+7u7uUKlU0rkOHTrgn//8J/bv34/z58/r7V4NEULggw8+gJubGywsLDBw4EBs27ZNJ92MGTNgYWGBgwcPSuc0Gg1Gjx4NR0dHFBYW6r1uDbG2toa1tbXO+UceeQQAtP6OtVZ8fDw6duyIiRMnap1/7rnnUFBQgLS0tNsq9/jx4/D395eGpWfMmIHLly9rpXnvvffQoUOHBp/n+eefR5cuXXSGSon0gYGWgZ06dQoqlQoxMTFITEzEv/71L6SlpeHRRx9FTU0NAGDEiBEYMGAAPv30U538K1euxMMPP4yHH34YALBz504MHz4cZWVl+Pzzz7Fp0yY89NBDmDx5coPDas8//zzMzMzw3Xff4aeffoKZmVmjdb1+/XqzDtHAUIKhxcfH4/7778eAAQOkoYqbv6AbMmnSJPTv3x9xcXEICwvDRx99hDlz5mDChAkYO3asFES88cYb2Lhxo5Tv6tWr8Pb2xjfffIPw8HBs27YNb7zxBtasWYPx48ffsg00Gk2z2rK2tva22uP06dM4e/Ys+vbtK53Lzs4GAHh5eemk9/Lykq63xJ9//olTp041Wuaff/6J06dPN1mGIep1q/s1di8AOsOt+rZgwQK88cYb8PHxwc8//4yXXnoJYWFhOsOsy5cvR58+fTBp0iSUlZVJeZOTk7F27Vo4Ozs3eZ/a2tpm/R3TaDS39Ry//fYbAGj9Hau3ePFimJubw8rKCo8++ig2b97crDKzs7PRp08frYAb+Ptnczt/F4qLi+Ht7Y3s7Gx89tln+O6773DlyhXMnj1bK9306dPRoUMHrFq1Suv8pUuXEBsbi2nTpsHCwqLR+wghmv07kkhL+3ao3VtuNXSo0WhETU2NOHv2rAAgNm3apJM3IyNDOrd//34BQHzzzTfSuQcffFAMGDBAawhGCCECAwOFs7OzNBRSX97UqVObXX8AzTpWr17d7DKFMPzQYf1wxo31eueddwQA8eGHH2qlfeihhwQAsXHjRulcTU2NsLe3F0899ZR0LioqSpiYmIgDBw5o5f/pp58EALF169Ym61p//1sdt9MuNTU1YuTIkcLGxkbk5eVJ59etWycAiJSUFJ08L774ojA3N2+0zMaG6M6fPy8AiKioKJ1r33//vc4QXUMMUa+mmJmZienTp+uc37dvX4PDVvX0MXRYWloqLCwsxJNPPql1vn6Y9Oa/vzk5OcLGxkZMmDBBbN++XZiYmIi33367Wfdyc3Nr1t+xd955p8XPcfjwYWFpaanzHAUFBSIsLEz8+OOPYs+ePWLdunVi6NChAoD48ssvb1lu7969hZ+fn875goICAUAsWrSoxXV94403hEwmE5mZmVrnfXx8dIYOQ0JChIODg6iqqpLOLVmyRJiYmNxyykf979TmHEQ30v5nBeldSUkJ/vWvf2HLli0oKCjQ+tflsWPHMH78eADAs88+izfeeAOffvopvvzySwDAihUrYG9vj8mTJwMA/vjjDxw/fhzR0dEAoPUvpyeeeAK//vorTpw4gT59+kjnn3766WbX9cbhyab06NGj2WW2t8DAQK3Pffr0weHDhxEQECCd69ChA3r16oWzZ89K53799Vd4enrioYce0mpnPz8/6U2mG8u42Ysvvqhz74bI5fKWPA6EEJg2bRr27NmDuLg4uLq66qRp7M251rxR11Te+mu1tbVaPX0mJiZaQ3P6rJcQQqc38MZekubU1xBSUlJw7do1TJkyRev8sGHDtIZe6/Xq1QtffvklJk+ejISEBIwYMQLvvvtus+71yy+/NGsqgFKpbFZ59XJzcxEYGAhXV1f8+9//1rrm7OyML774QuvcxIkTMWTIELz55psIDQ3V6a26mb5/Njt37kTfvn11XmYIDg5GUlKS1rlXXnkF33zzDTZs2IApU6ZAo9EgJiYGY8eOveWb0ePGjWv278hbubnXy9TU1KB/L6l9MdAyII1GA19fXxQUFGD+/Pno168frK2todFoMHToUPz5559SWrlcjunTp+PDDz/E0qVLUVNTgx9//BERERHSl3FxcTEAYO7cuZg7d26D97xx7heAWw4/3Oihhx5qVjpTU9Nml9ne7OzstD7XD3fcPERgbm6OiooK6XNxcTH++OOPRodab27nmzk5OTU4t+pmLfnlKoTACy+8gLVr1+Kbb75BUFCQ1vUuXboAAC5evKiT99KlSzpt0Ry2traQyWSNlgn83cajR4/WeqsvJCQEa9asMUi9vvnmGzz33HNa5+qDvC5dujSrvoZQf18nJyedaw2dA4CxY8fC0dERxcXFiIiIaPb/Xx4eHs0axm/JPLSzZ89i1KhR6NChA3bs2NGstjIzM8PkyZPx5ptvIicnR+sfejczxM/m4sWLDf7jr6H2HjBgAEaMGIFPP/0UU6ZMwa+//orc3Fyd4cSG2NnZQaFQtLh+N8vNzdWp786dO+/IpT9IPxhoGVB2djYOHz6MNWvWICQkRDr/xx9/NJj+pZdewuLFi/H111/j2rVruH79OmbMmCFd79q1KwAgMjISTz31VINluLu7a31uyRd5U/O3brR69erbWtvobtK1a1dYWlri66+/bvR6UxYuXIgFCxbc8j5ubm7NWnetPshavXo1vvrqK/zzn//USePp6QkAyMrKwhNPPKF1LSsrS7reEpaWlujVqxeysrJ0rmVlZcHS0hL3338/AGDVqlVaE5Dr28gQ9Wqqd6Ffv36N1vfG+hhCfVBZVFSkc62oqKjBXpP6idt9+/ZFeHg4RowYAVtb21veq2fPnlq9sI155513mtVLdvbsWYwcORJCCCQnJ8PFxeWWeerVB3y3Cur69euH9evX4/r161o9X6352XTp0qXR9m5IeHg4Jk6ciEOHDmHlypV44IEHmrU0RUPBfWOaCoCVSqXO392bf2/TvYWBlgHVBzk3Dw819q8nZ2dnTJw4EZ999hmqq6sxbtw43HfffdJ1d3d39O7dG4cPH8aiRYv0Xt87fehQLpdr9QIaUmBgIBYtWoQuXbrc1vPqc+hQCIGwsDCsXr0aq1atavSXfbdu3fDII49g7dq1mDt3rtQzkpqaihMnTuDVV19t0TPUe/LJJ7F8+XLk5+dLQ5WXL1/Gxo0bMX78eOkLs7EvC0PUq0uXLlJQ01B9Z86cibS0NAwZMgRA3VDN2rVrMWTIkBYPpbXE0KFDYWFhgXXr1mkN2+/btw9nz57VCbT+/e9/Y+3atfj666/h7e2NgQMH4rnnnsPPP/98y3vpc+gwLy8PI0eORG1tLZKTkxsc5mxMTU0NfvjhB3Tt2hW9evVqMu2TTz6JL7/8EnFxcdKUCKAuiFEqldLPqyVGjRqFDz74AIcPH9YaPmxsXa4nn3wS9913H1577TXs2rULH330UbP+QaqvoUNzc3MMHjy41eXQXaSd5obdk26eDF9dXS169uwp3NzcxPfffy8SEhLErFmzxAMPPNDoJNW0tDRpQuX27dt1rv/2229CLpcLX19f8f3334tdu3aJ+Ph4sWjRIvGPf/xDpy43T+ZuK0eOHBEbNmwQGzZsEIMGDRL29vbS5yNHjmilRQOThBsSEhIi5HK5iI2NFfv37xe///67EKLpyfAXLlzQKcPa2lqnbG9vb9G3b1/p85UrV8SAAQOEi4uL+PDDD0VSUpL4z3/+I7788ksxceJEkZqa2oLWaJ3Zs2cLAOL5558XKSkpWsehQ4e00u7cuVN06NBBPPnkkyIpKUmsW7dOuLq6Ck9PT3Ht2jWttMnJydLPxMLCQowcOVL6XFJSIqUrKSkRzs7Ool+/fiI+Pl5s3bpVPPbYY6JTp07i2LFjzXoGQ9SrMdeuXRN9+/YVrq6uYt26dSIpKUk8+eSTokOHDiI5OVkrbW5urlS2v7+/ACB9vvn/HTc3t2a9vPD2228LAGLatGkiISFBfPnll6Jbt27CyclJ6+/577//LiwtLbUm+9e/bPHRRx/d8j76UlxcLO6//34hl8vF2rVrdf6O5efnS2nnzJkjZs+eLdavXy927twpvv32W/Hwww83+JLMggULhKmpqU6b+/j4CFtbW/HFF1+I3377TYSFhQkAYu3atVrp6n+H3erlm8LCQmFvby+6desmVq9eLbZu3SqmTJkiXF1dG11Ha8mSJQKAsLa2FmVlZS1qL0PKzc0Vpqam4vnnn9c637NnT9GzZ0+tc88//7wwNTXVWt+O7kwMtPSoobcOjx49Knx8fESnTp2Era2tmDhxosjLy2vybaDu3buLPn36NHqfw4cPi0mTJgkHBwdhZmYmnJycxOOPPy4+//xznbq0V6DV1Ft3Nz735cuXBQDxzDPP3LLM3Nxc4evrKzp16qT1xp4hAi0h6oKtt99+W7i7uwtzc3OhUChEv379xJw5c0RRUVHzG6OVmnq7rKEv/sTERDF06FBhYWEh7OzsxNSpUxtc9NTb27vRcm/+cvrjjz/EhAkThI2NjbCyshKjR48WBw8ebNFzGKJejSkqKhJTp04VdnZ2wsLCQgwdOlQkJSXppGvqTbKb33bs2rWrGDp06C3vrdFoRFRUlHB1dRXm5ubCy8tL/PLLL1oLll65ckU8+OCDwsPDQ1RWVmrlnzVrljAzMxNpaWnNetbWql/Yszn/v3711VfikUceEXZ2dqJDhw7C1tZW+Pn5if/85z865db/P3jzz+zy5csiPDxcODk5Se2zfv16nfwrVqwQAERCQsItn6H+92z9361p06aJTZs2Nfp3Jjc3VwAQM2bMuGXZban+d9nNf/caCvJDQkJ0vm/oziQToh0WRaJG/f777+jfvz8+/fRTzJw5s72rY3Bbt25FYGAgDh8+jH79+rV3dYgadPToUfTt2xe//vrrPbvV051m0qRJOHPmjN7e9LvRihUrEB4ejuzs7AbXCSPSJ87RukOcOnUKZ8+exbx58+Ds7HzPTzavt3PnTjzzzDMMsuiOtnPnTqhUKgZZbUT8NSF/7dq1ei03IyMDZ86cwcKFCxEUFMQgi9oEe7TuEKGhofjuu+/Qp08frFq1CsOHD2/vKhER3VO6d++OoqIijBgxAt99912jS24Q6RMDLSIiIiID4V6HRERERAbCQIuIiIjIQBhoERERERkI3zpsYxqNBgUFBejUqRM3ESUiokYJIXD58mUolcoW7VnZUteuXUN1dbVeyjI3N9fZS9bYMdBqYwUFBdI2JkRERLeSn5/for0nW+LatWvo4dYRRSW1einPyckJZ86cYbB1AwZabaxTp04A6v7HsbGxaefaEBHRnaqiogKurq7S94YhVFdXo6ikFmcPdodNp9b1mlVc1sBtUC6qq6sZaN2AgVYbqx8utLGxYaBFRES31BbTTDp2kqFjp9bdRwNOh2kIAy0iIiIjVys0qG3lqpq1QqOfytxj2vWtw5iYGHh5eUm9OyqVCtu2bZOuFxcXIzQ0FEqlElZWVvD390dOTo5OOSkpKXj88cdhbW2Nzp07Y+TIkfjzzz+l66WlpVCr1VAoFFAoFFCr1SgrK9MqIy8vD+PGjYO1tTW6du2K8PBwncmBWVlZ8Pb2hqWlJbp164aFCxeC670SEdHdTgOhl4N0tWug5eLigsWLFyM9PR3p6el4/PHHERQUhCNHjkAIgQkTJuD06dPYtGkTMjIy4ObmhjFjxqCyslIqIyUlBf7+/vD19cX+/ftx4MABzJ49W+sNjeDgYGRmZiIhIQEJCQnIzMyEWq2WrtfW1mLs2LGorKzE3r17ERsbi7i4OLz22mtSmoqKCvj4+ECpVOLAgQNYsWIFoqOjsWzZsrZpLCIiIrrr3HFb8NjZ2WHp0qUYMWIE3N3dtXZXr62thYODA5YsWYIXXngBADB06FD4+Pjgvffea7C8Y8eOwcPDA6mpqRgyZAgAIDU1FSqVCsePH4e7uzu2bduGwMBA5OfnQ6lUAgBiY2MRGhqKkpIS2NjYICYmBpGRkSguLoZcLgcALF68GCtWrMC5c+eaPYZeUVEBhUKB8vJyztEiIqJGtcX3Rf09Ck646GUyvNL9HL/fbnLHLFhaW1uL2NhYVFZWQqVSoaqqCgC03lwwNTWFubk59u7dCwAoKSlBWloaHBwcMGzYMDg6OsLb21u6DtT1eCkUCinIAuqCM4VCgX379klpPD09pSALAPz8/FBVVYWDBw9Kaby9vaUgqz5NQUEBcnNz9d8gREREbaRWCL0cpKvdA62srCx07NgRcrkcM2bMQHx8PDw8PPDggw/Czc0NkZGRKC0tRXV1NRYvXoyioiIUFhYCAE6fPg0AePfddxEWFoaEhAQMHDgQo0ePluZyFRUVwcHBQee+Dg4OKCoqktI4OjpqXbe1tYW5uXmTaeo/16dpSFVVFSoqKrQOIiIiMg7tHmi5u7sjMzMTqampeOmllxASEoKjR4/CzMwMcXFxOHnyJOzs7GBlZYXk5GQEBATA1NQUQN0q6wAwffp0PPfccxgwYAA++ugjuLu74+uvv5bu0dCwnhBC6/ztpKkfdW1q2DAqKkqahK9QKLhYKRER3XE4Gd5w2j3QMjc3R69evTB48GBERUWhf//++PjjjwEAgwYNQmZmJsrKylBYWIiEhARcvHgRPXr0AAA4OzsDADw8PLTK7NOnD/Ly8gDUrVJbXFysc98LFy5IPVJOTk46vVKlpaWoqalpMk1JSQkA6PR03SgyMhLl5eXSkZ+f37yGISIiaiMaCNS28mCg1bB2D7RuJoSQ5mfVUygUsLe3R05ODtLT0xEUFAQA6N69O5RKJU6cOKGV/uTJk3BzcwMAqFQqlJeXY//+/dL1tLQ0lJeXY9iwYVKa7OxsaUgSABITEyGXyzFo0CApze7du7WWfEhMTIRSqUT37t0bfR65XC4tX8FFSomIiIxLuy5YOm/ePAQEBMDV1RWXL19GbGwskpOTkZCQAADYsGED7O3tcd999yErKwuvvPIKJkyYAF9fXwB1Q3avv/463nnnHfTv3x8PPfQQvvnmGxw/fhw//fQTgLreLX9/f4SFhWHVqlUAgBdffBGBgYFwd3cHAPj6+sLDwwNqtRpLly7FpUuXMHfuXISFhUmBUXBwMBYsWIDQ0FDMmzcPOTk5WLRoEf71r39xc2giIrqr6WPojz1aDWvXQKu4uBhqtRqFhYVQKBTw8vJCQkICfHx8AACFhYWIiIhAcXExnJ2dMXXqVMyfP1+rjFdffRXXrl3DnDlzcOnSJfTv3x9JSUno2bOnlGbdunUIDw+XArTx48dj5cqV0nVTU1Ns2bIFM2fOxPDhw2FpaYng4GBER0dLaRQKBZKSkjBr1iwMHjwYtra2iIiIQEREhCGbiIiIyOD08dYg3zps2B23jta9jutoERFRc7TlOlonjzmiUyvX0bp8WYMH+hTz++0m3OuQiIjIyGn+OlpbBulioEVERGTk6t8cbG0ZpIuBFhERkZGrFXVHa8sgXXfc8g5ERERE9wr2aBERERk5ztEyHAZaRERERk4DGWrRujUhNa3Mf6/i0CERERGRgbBHi4iIyMhpRN3R2jJIFwMtIiIiI1erh6HD1ua/V3HokIiIiMhA2KNFRERk5NijZTgMtIiIiIycRsigEa1867CV+e9VHDokIiIiMhD2aBERERk5Dh0aDgMtIiIiI1cLE9S2cpCrVk91udcw0CIiIjJyQg9ztATnaDWIc7SIiIiIDIQ9WkREREaOc7QMhz1aRERERq5WmOjlaK6oqCg8/PDD6NSpExwcHDBhwgScOHFCK40QAu+++y6USiUsLS0xcuRIHDly5JZlx8XFwcPDA3K5HB4eHoiPj29xe+gTAy0iIiJqU7t27cKsWbOQmpqKpKQkXL9+Hb6+vqisrJTSfPDBB1i2bBlWrlyJAwcOwMnJCT4+Prh8+XKj5aakpGDy5MlQq9U4fPgw1Go1Jk2ahLS0tLZ4rAbJhBDcBrINVVRUQKFQoLy8HDY2Nu1dHSIiukO1xfdF/T22/H4/rDuZtqqsysu1GOt1+rbqe+HCBTg4OGDXrl147LHHIISAUqnEq6++ijfeeAMAUFVVBUdHRyxZsgTTp09vsJzJkyejoqIC27Ztk875+/vD1tYW69evv/2HawX2aBERERm5+jlarT1uV3l5OQDAzs4OAHDmzBkUFRXB19dXSiOXy+Ht7Y19+/Y1Wk5KSopWHgDw8/NrMo+hcTI8ERER6U1FRYXWZ7lcDrlc3mh6IQQiIiLw6KOPwtPTEwBQVFQEAHB0dNRK6+joiLNnzzZaVlFRUYN56strD+zRIiIiMnL6nAzv6uoKhUIhHVFRUU3ee/bs2fj9998bHNqTybR7yYQQOuf0kceQ2KNFRERk5DSQQdPK5Rnq8+fn52vN0WqqN+vll1/G5s2bsXv3bri4uEjnnZycANT1UDk7O0vnS0pKdHqsbuTk5KTTe3WrPIbGHi0iIiLSGxsbG62joUBLCIHZs2dj48aN+O2339CjRw+t6z169ICTkxOSkpKkc9XV1di1axeGDRvW6L1VKpVWHgBITExsMo+hsUeLiIjIyGn0sNehBs1fxGDWrFn4/vvvsWnTJnTq1EnqhVIoFLC0tIRMJsOrr76KRYsWoXfv3ujduzcWLVoEKysrBAcHS+VMnToV3bp1k4YnX3nlFTz22GNYsmQJgoKCsGnTJmzfvh179+5t1bO1BgMtIiIiI9fSBUcbLqP5gVZMTAwAYOTIkVrnV69ejdDQUADA//3f/+HPP//EzJkzUVpaiiFDhiAxMRGdOnWS0ufl5cHE5O96Dxs2DLGxsXj77bcxf/589OzZEz/88AOGDBly+w/WSlxHq41xHS0iImqOtlxH6/tMT1i1ch2tq5drEfxQNr/fbsI5WkREREQGwqFDIiIiI1crZKgVrdxUupX571UMtIiIiIxcrR4mw9e2YDK8MWnXocOYmBh4eXlJr4CqVCqt/YmKi4sRGhoKpVIJKysr+Pv7IycnR6uMkSNHQiaTaR3PPPOMVprS0lKo1Wpp8TS1Wo2ysjKtNHl5eRg3bhysra3RtWtXhIeHo7q6WitNVlYWvL29YWlpiW7dumHhwoXgFDciIiJqTLv2aLm4uGDx4sXo1asXAOCbb75BUFAQMjIy4OHhgQkTJsDMzAybNm2CjY0Nli1bhjFjxuDo0aOwtraWygkLC8PChQulz5aWllr3CQ4Oxrlz55CQkAAAePHFF6FWq/HLL78AAGprazF27FjY29tj7969uHjxIkJCQiCEwIoVKwDUTRj08fHBqFGjcODAAZw8eRKhoaGwtrbGa6+9ZtB2IiIiMiSNMIGmlW8datjx0KB2DbTGjRun9fn9999HTEwMUlNTYWZmhtTUVGRnZ6Nv374AgM8++wwODg5Yv349XnjhBSmflZWVtIrszY4dO4aEhASkpqZKr3d++eWXUKlUOHHiBNzd3ZGYmIijR48iPz8fSqUSAPDhhx8iNDQU77//PmxsbLBu3Tpcu3YNa9asgVwuh6enJ06ePIlly5YhIiKiXZf3JyIiag0OHRrOHfPWYW1tLWJjY1FZWQmVSoWqqioAgIWFhZTG1NQU5ubmOguPrVu3Dl27dkXfvn0xd+5cXL58WbqWkpIChUKhtYbG0KFDoVAopN28U1JS4OnpKQVZQN1u31VVVTh48KCUxtvbW2uFWz8/PxQUFCA3N1d/DUFERET3jHafDJ+VlQWVSoVr166hY8eOiI+Ph4eHB2pqauDm5obIyEisWrUK1tbWWLZsGYqKilBYWCjlnzJlirRUf3Z2NiIjI3H48GFpCf6ioiI4ODjo3NfBwUFaibah3b5tbW1hbm6ulaZ79+5aaerzFBUV6WwfUK+qqkoKGgHdXc2JiIjamwatf2tQo5+q3HPaPdByd3dHZmYmysrKEBcXh5CQEOzatQseHh6Ii4vDtGnTYGdnB1NTU4wZMwYBAQFa+cPCwqQ/e3p6onfv3hg8eDAOHTqEgQMHAtDdyRvQ3c37dtLUT4RvatgwKioKCxYsaKoJiIiI2pUGJtC0egueO2aQ7I7S7q1ibm6OXr16YfDgwYiKikL//v3x8ccfAwAGDRokBWGFhYVISEjAxYsXG+09AoCBAwfCzMxMejvRyckJxcXFOukuXLgg9Ug1tNt3aWkpampqmkxTUlICAE3uCh4ZGYny8nLpyM/Pv1WTEBER0T2i3QOtmwkhtIbagLpNJu3t7ZGTk4P09HQEBQU1mv/IkSOoqamBs7MzgLqdvMvLy7F//34pTVpaGsrLy6XdvFUqFbKzs7WGJBMTEyGXyzFo0CApze7du7WWfEhMTIRSqdQZUryRXC7X2cmciIjoTlK/12FrD9LVrq0yb9487NmzB7m5ucjKysJbb72F5ORkTJkyBQCwYcMGJCcn4/Tp09i0aRN8fHwwYcIE+Pr6AgBOnTqFhQsXIj09Hbm5udi6dSsmTpyIAQMGYPjw4QCAPn36wN/fH2FhYUhNTUVqairCwsIQGBgId3d3AICvry88PDygVquRkZGBHTt2YO7cuQgLC5MCo+DgYMjlcoSGhiI7Oxvx8fFYtGgR3zgkIqK7ngYyvRykq13naBUXF0OtVqOwsBAKhQJeXl5ISEiAj48PAKCwsBAREREoLi6Gs7Mzpk6divnz50v5zc3NsWPHDnz88ce4cuUKXF1dMXbsWLzzzjswNf17c8x169YhPDxcCtDGjx+PlStXStdNTU2xZcsWzJw5E8OHD4elpSWCg4MRHR0tpVEoFEhKSsKsWbMwePBg2NraIiIiAhEREYZuJiIiIoPSR48Ue7QaJhNc2rxNtcVu7EREdPdri++L+nt8lD4Mlh1b1/fy55XrmDN4H7/fbtLubx0SERFR+9LPgqXs0WoIAy0iIiIjpxEyaFq7jlYr89+rGH4SERERGQh7tIiIiIycRg9Dh1ywtGEMtIiIiIycRphA08q3Blub/17FViEiIiIyEPZoERERGblayFDbygVHW5v/XsVAi4iIyMhx6NBw2CpEREREBsIeLSIiIiNXi9YP/dXqpyr3HAZaRERERo5Dh4bDQIuIiMjIcVNpw2GrEBERERkIe7SIiIiMnIAMmlbO0RJc3qFBDLSIiIiMHIcODYetQkRERGQg7NEiIiIychohg0a0buivtfnvVQy0iIiIjFwtTFDbykGu1ua/V7FViIiIiAyEgRYREZGRqx86bO3RErt378a4ceOgVCohk8nw888/a12XyWQNHkuXLm20zDVr1jSY59q1a7fTLHrBoUMiIiIjp4EJNK3se2lp/srKSvTv3x/PPfccnn76aZ3rhYWFWp+3bduGadOmNZj2RjY2Njhx4oTWOQsLixbVTZ8YaBEREVGbCwgIQEBAQKPXnZyctD5v2rQJo0aNwv33399kuTKZTCdve+LQIRERkZGrFTK9HABQUVGhdVRVVbW6fsXFxdiyZQumTZt2y7RXrlyBm5sbXFxcEBgYiIyMjFbfvzUYaBERERk5fc7RcnV1hUKhkI6oqKhW1++bb75Bp06d8NRTTzWZ7sEHH8SaNWuwefNmrF+/HhYWFhg+fDhycnJaXYfbxaFDIiIiIyeECTStXNld/JU/Pz8fNjY20nm5XN6qcgHg66+/xpQpU24512ro0KEYOnSo9Hn48OEYOHAgVqxYgU8++aTV9bgdDLSIiIhIb2xsbLQCrdbas2cPTpw4gR9++KHFeU1MTPDwww+3a48Whw6JiIiMXC1kejkM4auvvsKgQYPQv3//FucVQiAzMxPOzs4GqFnzsEeLiIjIyGlE67fQ0YiWpb9y5Qr++OMP6fOZM2eQmZkJOzs73HfffQDqJtZv2LABH374YYNlTJ06Fd26dZPmgS1YsABDhw5F7969UVFRgU8++QSZmZn49NNPb++h9ICBFhEREbW59PR0jBo1SvocEREBAAgJCcGaNWsAALGxsRBC4Nlnn22wjLy8PJiY/D04V1ZWhhdffBFFRUVQKBQYMGAAdu/ejUceecRwD3ILMiFEC2NQao2KigooFAqUl5frdQybiIjuLW3xfVF/j5Cdz8C8o3mryqq+Uo1vRsXy++0m7NEiIiIychrIoGnlHKvW5r9XcTI8ERERkYG0a6AVExMDLy8v6VVQlUqFbdu2SdeLi4sRGhoKpVIJKysr+Pv7N/qKphACAQEBDW5MWVpaCrVaLS2eplarUVZWppUmLy8P48aNg7W1Nbp27Yrw8HBUV1drpcnKyoK3tzcsLS3RrVs3LFy4EBx5JSKiu50+V4Ynbe06dOji4oLFixejV69eAOpWfg0KCkJGRgY8PDwwYcIEmJmZYdOmTbCxscGyZcswZswYHD16FNbW1lplLV++HDJZwz/k4OBgnDt3DgkJCQCAF198EWq1Gr/88gsAoLa2FmPHjoW9vT327t2LixcvIiQkBEIIrFixAkDdOLaPjw9GjRqFAwcO4OTJkwgNDYW1tTVee+01QzURERGRwWn0sGBpa/Pfq9o10Bo3bpzW5/fffx8xMTFITU2FmZkZUlNTkZ2djb59+wIAPvvsMzg4OGD9+vV44YUXpHyHDx/GsmXLcODAAZ21Mo4dO4aEhASkpqZiyJAhAIAvv/wSKpUKJ06cgLu7OxITE3H06FHk5+dDqVQCAD788EOEhobi/fffh42NDdatW4dr165hzZo1kMvl8PT0xMmTJ7Fs2TJEREQ0GuQRERGR8bpjws/a2lrExsaisrISKpVK2oTyxuX2TU1NYW5ujr1790rnrl69imeffRYrV65scLfulJQUKBQKKcgC6pboVygU2Ldvn5TG09NTCrIAwM/PD1VVVTh48KCUxtvbW2srAT8/PxQUFCA3N1c/jUBERNQONNDDXoecDN+gdn/rMCsrCyqVCteuXUPHjh0RHx8PDw8P1NTUwM3NDZGRkVi1ahWsra2xbNkyFBUVobCwUMo/Z84cDBs2DEFBQQ2WX1RUBAcHB53zDg4OKCoqktI4OjpqXbe1tYW5ublWmu7du2ulqc9TVFSEHj16NHj/qqoqrZ3LKyoqbtEiREREbUvo4a1DwUCrQe3eo+Xu7o7MzEykpqbipZdeQkhICI4ePQozMzPExcXh5MmTsLOzg5WVFZKTkxEQEABTU1MAwObNm/Hbb79h+fLlTd6joWE9IYTW+dtJUz8Rvqlhw6ioKK1dzF1dXZusKxERUVtrdW/WXwfpavdAy9zcHL169cLgwYMRFRWF/v374+OPPwYADBo0CJmZmSgrK0NhYSESEhJw8eJFqffot99+w6lTp9C5c2d06NABHTrUddA9/fTTGDlyJADAyckJxcXFOve9cOGC1CPl5OQk9VzVKy0tRU1NTZNpSkpKAECnN+xGkZGRKC8vl478/PyWNhERERHdpdo90LqZEEJrqA0AFAoF7O3tkZOTg/T0dGmY8M0338Tvv/+OzMxM6QCAjz76CKtXrwYAqFQqlJeXY//+/VJ5aWlpKC8vx7Bhw6Q02dnZWkOSiYmJkMvlGDRokJRm9+7dWks+JCYmQqlU6gwp3kgul0vLV+h7R3MiIiJ9qH/rsLUH6WrXOVrz5s1DQEAAXF1dcfnyZcTGxiI5OVlahmHDhg2wt7fHfffdh6ysLLzyyiuYMGECfH19AdT1MjU0Af6+++6Ter369OkDf39/hIWFYdWqVQDqlncIDAyEu7s7AMDX1xceHh5Qq9VYunQpLl26hLlz5yIsLEwKjIKDg7FgwQKEhoZi3rx5yMnJwaJFi/Cvf/2LbxwSEdFdTR9Dfxw6bFi7BlrFxcVQq9UoLCyEQqGAl5cXEhIS4OPjAwAoLCxEREQEiouL4ezsjKlTp2L+/Pktvs+6desQHh4uBWjjx4/HypUrpeumpqbYsmULZs6cieHDh8PS0hLBwcGIjo6W0igUCiQlJWHWrFkYPHgwbG1tERERIW2CSURERHQzbirdxripNBERNUdbbio9LnEazKxbt6l0TWU1fvH9it9vN2n35R2IiIiofXHo0HA4c42IiIjIQNijRUREZOTYo2U4DLSIiIiMHAMtw+HQIREREZGBsEeLiIjIyLFHy3AYaBERERk5AehhU2lqCAMtIiIiI8ceLcPhHC0iIiIiA2GPFhERkZFjj5bhMNAiIiIycgy0DIdDh0REREQGwh4tIiIiI8ceLcNhoEVERGTkhJBBtDJQam3+exWHDomIiIgMhD1aRERERk4DWasXLG1t/nsVAy0iIiIjxzlahsOhQyIiIiIDYY8WERGRkeNkeMNhjxYREZGRqx86bO3RErt378a4ceOgVCohk8nw888/a10PDQ2FTCbTOoYOHXrLcuPi4uDh4QG5XA4PDw/Ex8e3qF76xkCLiIjIyNX3aLX2aInKykr0798fK1eubDSNv78/CgsLpWPr1q1NlpmSkoLJkydDrVbj8OHDUKvVmDRpEtLS0lpUN33i0CERERG1uYCAAAQEBDSZRi6Xw8nJqdllLl++HD4+PoiMjAQAREZGYteuXVi+fDnWr1/fqvreLvZoERERGTmhh2HD+h6tiooKraOqquq265WcnAwHBwc88MADCAsLQ0lJSZPpU1JS4Ovrq3XOz88P+/btu+06tBYDLSIiIiMnAAjRyuOvslxdXaFQKKQjKirqtuoUEBCAdevW4bfffsOHH36IAwcO4PHHH28ycCsqKoKjo6PWOUdHRxQVFd1WHfSBQ4dERESkN/n5+bCxsZE+y+Xy2ypn8uTJ0p89PT0xePBguLm5YcuWLXjqqacazSeTac8VE0LonGtLDLSIiIiMnAYyyPS0MryNjY1WoKUvzs7OcHNzQ05OTqNpnJycdHqvSkpKdHq52hKHDomIiIxce7x12FIXL15Efn4+nJ2dG02jUqmQlJSkdS4xMRHDhg0zaN2awh4tIiIianNXrlzBH3/8IX0+c+YMMjMzYWdnBzs7O7z77rt4+umn4ezsjNzcXMybNw9du3bFk08+KeWZOnUqunXrJs0De+WVV/DYY49hyZIlCAoKwqZNm7B9+3bs3bu3zZ+vHgMtIiIiI6cRMsjaeK/D9PR0jBo1SvocEREBAAgJCUFMTAyysrLw7bffoqysDM7Ozhg1ahR++OEHdOrUScqTl5cHE5O/B+eGDRuG2NhYvP3225g/fz569uyJH374AUOGDGnVs7WGTAghbp2M9KWiogIKhQLl5eUGGcMmIqJ7Q1t8X9Tfo+8Pr8PU6vYmrdervVqFI5OX8vvtJpyjRURERGQgHDokIiIyctxU2nDatUcrJiYGXl5e0qugKpUK27Ztk64XFxcjNDQUSqUSVlZW8Pf313mtc/r06ejZsycsLS1hb2+PoKAgHD9+XCtNaWkp1Gq1tHiaWq1GWVmZVpq8vDyMGzcO1tbW6Nq1K8LDw1FdXa2VJisrC97e3rC0tES3bt2wcOFCcOSViIjudnfDW4d3q3YNtFxcXLB48WKkp6cjPT0djz/+OIKCgnDkyBEIITBhwgScPn0amzZtQkZGBtzc3DBmzBhUVlZKZQwaNAirV6/GsWPH8J///AdCCPj6+qK2tlZKExwcjMzMTCQkJCAhIQGZmZlQq9XS9draWowdOxaVlZXYu3cvYmNjERcXh9dee01KU1FRAR8fHyiVShw4cAArVqxAdHQ0li1b1jaNRUREZCCt3X6n/iBdd9xkeDs7OyxduhQjRoyAu7s7srOz0bdvXwB1AZGDgwOWLFmCF154ocH8v//+O/r3748//vgDPXv2xLFjx+Dh4YHU1FTprYPU1FSoVCocP34c7u7u2LZtGwIDA5Gfnw+lUgkAiI2NRWhoKEpKSmBjY4OYmBhERkaiuLhYWuV28eLFWLFiBc6dO9fsVWc5GZ6IiJqjLSfDu3//pl4mw58IXszvt5vcMZPha2trERsbi8rKSqhUKmkvIwsLCymNqakpzM3NG10Po7KyEqtXr0aPHj3g6uoKoG6DSYVCofVq59ChQ6FQKKRNJlNSUuDp6SkFWUDdJpRVVVU4ePCglMbb21trKwE/Pz8UFBQgNzdXP41ARETUDlq9z+FfB+lq90ArKysLHTt2hFwux4wZMxAfHw8PDw88+OCDcHNzQ2RkJEpLS1FdXY3FixejqKgIhYWFWmV89tln6NixIzp27IiEhAQkJSXB3NwcQN0Gkw4ODjr3dXBwkJbpb2gTSltbW5ibmzeZpv5zU5tVVlVV6exkTkREdCepC5RaO0ervZ/iztTugZa7uzsyMzORmpqKl156CSEhITh69CjMzMwQFxeHkydPws7ODlZWVkhOTkZAQABMTU21ypgyZQoyMjKwa9cu9O7dG5MmTcK1a9ek6w0N6928yeTtpKkfdW1q2DAqKkprF/P6njYiIiK697V7oGVubo5evXph8ODBiIqKQv/+/fHxxx8DqJvonpmZibKyMhQWFiIhIQEXL15Ejx49tMpQKBTo3bs3HnvsMfz00084fvw44uPjAdRtMFlcXKxz3wsXLkg9Ug1tQllaWoqampom05SUlABAk5tVRkZGory8XDry8/Nb0jxEREQGx7cODafdA62bCSGk+Vn1FAoF7O3tkZOTg/T0dAQFBTW7DJVKhfLycuzfv1+6npaWhvLycmmTSZVKhezsbK0hycTERMjlcgwaNEhKs3v3bq0lHxITE6FUKtG9e/dG6yKXy6XlKwy1ozkREVFrCD0dpKtdA6158+Zhz549yM3NRVZWFt566y0kJydjypQpAIANGzYgOTlZWuLBx8cHEyZMgK+vLwDg9OnTiIqKwsGDB5GXl4eUlBRMmjQJlpaWeOKJJwAAffr0gb+/P8LCwpCamorU1FSEhYUhMDAQ7u7uAABfX194eHhArVYjIyMDO3bswNy5cxEWFiYFRsHBwZDL5QgNDUV2djbi4+OxaNEiRERENPuNQyIiIjIu7boyfHFxMdRqNQoLC6FQKODl5YWEhAT4+PgAAAoLCxEREYHi4mI4Oztj6tSpmD9/vpTfwsICe/bswfLly1FaWgpHR0c89thj2Ldvn9YE+HXr1iE8PFwK0MaPH4+VK1dK101NTbFlyxbMnDkTw4cPh6WlJYKDgxEdHS2lUSgUSEpKwqxZszB48GDY2toiIiJC2gSTiIjobsWV4Q3njltH617HdbSIiKg52nIdrfu/mQdTK4tbZ2hC7dVrOB2yiN9vN+Feh0RERMZOH5PZ2aPVoDtuMjwRERHRvYI9WkREREZOHyu7cyJSwxhoERERGTlOhjccDh0SERERGQh7tIiIiIydkLV+Mjt7tBrEQIuIiMjIcY6W4XDokIiIiMhA2KNFRERk7PSxWSF7tBrEQIuIiMjI8a1Dw+HQIREREZGBsEeLiIiIOPRnIAy0iIiIjByHDg2HgRYREZGx42R4g+EcLSIiIiIDYY8WERGR0ZP9dbS2DLoZAy0iIiJjx6FDg+HQIREREZGBsEeLiIjI2LFHy2DYo0VERGTshEw/Rwvs3r0b48aNg1KphEwmw88//yxdq6mpwRtvvIF+/frB2toaSqUSU6dORUFBQZNlrlmzBjKZTOe4du3a7bSKXjDQIiIiojZXWVmJ/v37Y+XKlTrXrl69ikOHDmH+/Pk4dOgQNm7ciJMnT2L8+PG3LNfGxgaFhYVah4WFhSEeoVk4dEhERGTkhKg7WltGSwQEBCAgIKDBawqFAklJSVrnVqxYgUceeQR5eXm47777Gi1XJpPBycmpZZUxIPZoERERGTuhp8OAysvLIZPJ0Llz5ybTXblyBW5ubnBxcUFgYCAyMjIMW7FbYKBFREREelNRUaF1VFVVtbrMa9eu4c0330RwcDBsbGwaTffggw9izZo12Lx5M9avXw8LCwsMHz4cOTk5ra7D7WKgRUREZOz0OBne1dUVCoVCOqKiolpVtZqaGjzzzDPQaDT47LPPmkw7dOhQ/POf/0T//v0xYsQI/Pjjj3jggQewYsWKVtWhNThHi4iIyMjJRN3R2jIAID8/X6vXSS6X33aZNTU1mDRpEs6cOYPffvutyd6shpiYmODhhx9u1x4tBlpERETGTo/raNnY2LQ4IGpIfZCVk5ODnTt3okuXLi2vkhDIzMxEv379Wl2f28VAi4iIiNrclStX8Mcff0ifz5w5g8zMTNjZ2UGpVOIf//gHDh06hF9//RW1tbUoKioCANjZ2cHc3BwAMHXqVHTr1k0anlywYAGGDh2K3r17o6KiAp988gkyMzPx6aeftv0D/oWBFhERkbG7jQVHGyyjBdLT0zFq1Cjpc0REBAAgJCQE7777LjZv3gwAeOihh7Ty7dy5EyNHjgQA5OXlwcTk7+nmZWVlePHFF1FUVASFQoEBAwZg9+7deOSRR5qsyyeffNLseoeHhzc7LQDIhGjtyhnUEhUVFVAoFCgvL9dL1yoREd2b2uL7ov4ersveg4ll6xb11Px5DfkR8+/K77cePXpofb5w4QKuXr0qLSVRVlYGKysrODg44PTp0y0qm28dEhERkVE7c+aMdLz//vt46KGHcOzYMVy6dAmXLl3CsWPHMHDgQLz33nstLpuBFhERkbG7CxYsbSvz58/HihUr4O7uLp1zd3fHRx99hLfffrvF5bVroBUTEwMvLy/pDQWVSoVt27ZJ14uLixEaGgqlUgkrKyv4+/trvaJ56dIlvPzyy3B3d4eVlRXuu+8+hIeHo7y8XOs+paWlUKvV0poearUaZWVlWmny8vIwbtw4WFtbo2vXrggPD0d1dbVWmqysLHh7e8PS0hLdunXDwoULwZFXIiK66zHQkhQWFqKmpkbnfG1tLYqLi1tcXrsGWi4uLli8eDHS09ORnp6Oxx9/HEFBQThy5AiEEJgwYQJOnz6NTZs2ISMjA25ubhgzZgwqKysBAAUFBSgoKEB0dDSysrKwZs0aJCQkYNq0aVr3CQ4ORmZmJhISEpCQkIDMzEyo1Wrpem1tLcaOHYvKykrs3bsXsbGxiIuLw2uvvSalqaiogI+PD5RKJQ4cOIAVK1YgOjoay5Yta5vGIiIiIoMbPXo0wsLCkJ6eLnWmpKenY/r06RgzZkyLy7vjJsPb2dlh6dKlGDFiBNzd3ZGdnY2+ffsCqAuIHBwcsGTJErzwwgsN5t+wYQP++c9/orKyEh06dMCxY8fg4eGB1NRUDBkyBACQmpoKlUqF48ePw93dHdu2bUNgYCDy8/OhVCoBALGxsQgNDUVJSQlsbGwQExODyMhIFBcXS4uvLV68GCtWrMC5c+cgkzXvbQtOhiciouZo08nwS/+ffibDv/72Xf/9duHCBYSEhCAhIQFmZmYAgOvXr8PPzw9r1qyBg4NDi8q7Y+Zo1dbWIjY2FpWVlVCpVNLeSBYWf//gTU1NYW5ujr179zZaTv0PuEOHupUrUlJSoFAopCALqFuiX6FQYN++fVIaT09PKcgCAD8/P1RVVeHgwYNSGm9vb60Vbv38/FBQUIDc3NzWNwAREVE7qV8ZvrXHvcDe3h5bt27F8ePHsWHDBvz44484duwYtm7d2uIgC7gD1tHKysqCSqXCtWvX0LFjR8THx8PDwwM1NTVwc3NDZGQkVq1aBWtrayxbtgxFRUUoLCxssKyLFy/ivffew/Tp06VzRUVFDTaMg4ODtPhZUVERHB0dta7b2trC3NxcK0337t210tTnKSoq0nk1tF5VVZXWhpoVFRW3aBEiIiJqbw888AAeeOCBVpfT7oGWu7s7MjMzUVZWhri4OISEhGDXrl3w8PBAXFwcpk2bBjs7O5iammLMmDEICAhosJyKigqMHTsWHh4eeOedd7SuNTSsJ4TQOn87aepHXZsaNoyKisKCBQsavU5ERNTu9LgFz73g3Llz2Lx5M/Ly8nRejGvp3OwWB1qhoaF4/vnn8dhjj7U0a4PMzc3Rq1cvAMDgwYNx4MABfPzxx1i1ahUGDRqEzMxMlJeXo7q6Gvb29hgyZAgGDx6sVcbly5fh7+8v9YjVj6kCgJOTU4NvCVy4cEHqkXJyckJaWprW9dLSUtTU1Gilqe/dqldSUgIAOr1hN4qMjJRWuwXqAkJXV9dbtgsRERG1vR07dmD8+PHo0aMHTpw4AU9PT+Tm5kIIgYEDB7a4vBbP0bp8+TJ8fX3Ru3dvLFq0COfPn2/xTZsihNAaagMAhUIBe3t75OTkID09HUFBQdK1iooK+Pr6wtzcHJs3b9aa0wUAKpUK5eXl2L9/v3QuLS0N5eXlGDZsmJQmOztba0gyMTERcrkcgwYNktLs3r1bK7JNTEyEUqnUGVK8kVwul5av0NdGm0RERPokgx7maLX3Q+hJZGQkXnvtNWRnZ8PCwgJxcXHIz8+Ht7c3Jk6c2OLyWhxoxcXF4fz585g9ezY2bNiA7t27IyAgAD/99FOD6040Zd68edizZw9yc3ORlZWFt956C8nJyZgyZQqAujcIk5OTpSUefHx8MGHCBPj6+gL4O+irrKzEV199hYqKChQVFaGoqAi1tbUAgD59+sDf3x9hYWFITU1FamoqwsLCEBgYKC1G5uvrCw8PD6jVamRkZGDHjh2YO3cuwsLCpMAoODgYcrkcoaGhyM7ORnx8PBYtWoSIiIhmv3FIREREd7Zjx44hJCQEANChQwf8+eef6NixIxYuXIglS5a0uLzbeuuwS5cueOWVV5CRkYH9+/ejV69eUKvVUCqVmDNnjtaiok0pLi6GWq2Gu7s7Ro8ejbS0NCQkJMDHxwdA3aJharUaDz74IMLDw6FWq7F+/Xop/8GDB5GWloasrCz06tULzs7O0pGfny+lW7duHfr16wdfX1/4+vrCy8sL3333nXTd1NQUW7ZsgYWFBYYPH45JkyZhwoQJiI6OltIoFAokJSXh3LlzGDx4MGbOnImIiAitYUEiIqK7Uv2m0q097gHW1tbSyJpSqcSpU6eka//73/9aXF6r1tEqLCzEt99+i6+//hrnz5/H008/jcLCQuzcuRMffPAB5syZc7tF37O4jhYRETVHW66j5Rb1PkwsWrmO1rVrOBv51l3//TZhwgSMHTsWYWFh+L//+z/Ex8cjNDQUGzduhK2tLbZv396i8lo8Gb6mpgabN2/G6tWrkZiYCC8vL8yZMwdTpkxBp06dANQt9vnSSy8x0CIiIqK7yrJly3DlyhUAwLvvvosrV67ghx9+QK9evfDRRx+1uLwWB1rOzs7QaDR49tlnsX//fjz00EM6afz8/NC5c+cWV4aIiIjaAZd3kNx///3Sn62srPDZZ5+1qrwWB1offfQRJk6cqPN2341sbW1x5syZVlWMiIiI2oY+Vna/V1aGB4CysjL89NNPOHXqFF5//XXY2dnh0KFDcHR0RLdu3VpUVosDrRs3YyYiIiK6l/z+++8YM2YMFAoFcnNzERYWBjs7O8THx+Ps2bP49ttvW1TeHbPXIREREbUToafjHhAREYHQ0FDk5ORojd4FBARg9+7dLS6v3bfgISIionbGOVqSAwcOYNWqVTrnu3XrprNDTHOwR4uIiIjoLxYWFqioqNA5f+LECdjb27e4PAZaRERERq7V2+/oYTL9nSIoKAgLFy6UdruRyWTIy8vDm2++iaeffrrF5THQIiIiMnZcGV4SHR2NCxcuwMHBAX/++Se8vb3Rq1cvdOzYEe+//36Ly+McLSIiImPHOVoSGxsb7N27Fzt37sTBgweh0WgwcOBAjBkz5rbKY6BFREREdIMdO3Zgx44dKCkpgUajwfHjx/H9998DAL7++usWlcVAi4iIyMhxwdK/LViwAAsXLsTgwYPh7OwMmax1Q6IMtIiIiIwdhw4ln3/+OdasWaO3Bdo5GZ6IiIjoL9XV1Rg2bJjeymOgRUREZOz0sbTDPdKj9cILL0jzsfSBQ4dERETGzsiHDiMiIqQ/azQafPHFF9i+fTu8vLxgZmamlXbZsmUtKpuBFhERERm1jIwMrc8PPfQQACA7O1vr/O1MjGegRUREZOyMvEdr586dBiubgRYREZGR4/IOhsPJ8EREREQGwkCLiIiI2tzu3bsxbtw4KJVKyGQy/Pzzz1rXhRB49913oVQqYWlpiZEjR+LIkSO3LDcuLg4eHh6Qy+Xw8PBAfHy8gZ6geRhoERERGTuhp6MFKisr0b9/f6xcubLB6x988AGWLVuGlStX4sCBA3BycoKPjw8uX77caJkpKSmYPHky1Go1Dh8+DLVajUmTJiEtLa1lldMjmRCCo6ptqKKiAgqFAuXl5bCxsWnv6hAR0R2qLb4v6u/R681FMLWwaFVZtdeu4Y/F826rvjKZDPHx8ZgwYQKAut4spVKJV199FW+88QYAoKqqCo6OjliyZAmmT5/eYDmTJ09GRUUFtm3bJp3z9/eHra0t1q9ff3sP1krs0SIiIiK9qaio0DqqqqpaXMaZM2dQVFQEX19f6ZxcLoe3tzf27dvXaL6UlBStPADg5+fXZB5DY6BFREREehs2dHV1hUKhkI6oqKgWV6WoqAgA4OjoqHXe0dFRutZYvpbmMTQu70BERGTs9LiOVn5+vtbQoVwuv+0ib14gVAhxy0VDbyePITHQIiIiIr2xsbFp9ZwyJycnAHU9VM7OztL5kpISnR6rm/Pd3Ht1qzyGxqFDIiIiI9faDaX1seDpjXr06AEnJyckJSVJ56qrq7Fr1y4MGzas0XwqlUorDwAkJiY2mcfQ2KNFRERk7NphC54rV67gjz/+kD6fOXMGmZmZsLOzw3333YdXX30VixYtQu/evdG7d28sWrQIVlZWCA4OlvJMnToV3bp1k+aBvfLKK3jsscewZMkSBAUFYdOmTdi+fTv27t3byoe7fQy0iIiIqM2lp6dj1KhR0ueIiAgAQEhICNasWYP/+7//w59//omZM2eitLQUQ4YMQWJiIjp16iTlycvLg4nJ34Nzw4YNQ2xsLN5++23Mnz8fPXv2xA8//IAhQ4a03YPdhOtotTGuo0VERM3RlutoPTB3EUzlrVxHq+oaTkbf3jpa9zL2aBERERm7dhg6NBbtOhk+JiYGXl5e0hsKKpVKazXX4uJihIaGQqlUwsrKCv7+/sjJydEq44svvsDIkSNhY2MDmUyGsrIynfuUlpZCrVZLa3qo1WqddHl5eRg3bhysra3RtWtXhIeHo7q6WitNVlYWvL29YWlpiW7dumHhwoVghyARERE1pl0DLRcXFyxevBjp6elIT0/H448/jqCgIBw5cgRCCEyYMAGnT5/Gpk2bkJGRATc3N4wZMwaVlZVSGVevXoW/vz/mzZvX6H2Cg4ORmZmJhIQEJCQkIDMzE2q1WrpeW1uLsWPHorKyEnv37kVsbCzi4uLw2muvSWkqKirg4+MDpVKJAwcOYMWKFYiOjsayZcsM0zhERERtpR32OjQWd9wcLTs7OyxduhQjRoyAu7s7srOz0bdvXwB1AZGDgwOWLFmCF154QStfcnIyRo0ahdLSUnTu3Fk6f+zYMXh4eCA1NVWaDJeamgqVSoXjx4/D3d0d27ZtQ2BgIPLz86FUKgEAsbGxCA0NRUlJCWxsbBATE4PIyEgUFxdLi68tXrwYK1aswLlz55q9GBrnaBERUXO05Rwt9zn6maN14iPO0brZHbOOVm1tLWJjY1FZWQmVSiXtjWRxwyaXpqamMDc3b9FrmikpKVAoFFpvHAwdOhQKhULa+yglJQWenp5SkAXU7Y1UVVWFgwcPSmm8vb21Vrj18/NDQUEBcnNzb+uZiYiI7gjs0TKYdg+0srKy0LFjR8jlcsyYMQPx8fHw8PDAgw8+CDc3N0RGRqK0tBTV1dVYvHgxioqKUFhY2Ozyi4qK4ODgoHPewcFBWj22ob2RbG1tYW5u3mSa+s9N7aFUVVWls8EmERERGYd2D7Tc3d2RmZmJ1NRUvPTSSwgJCcHRo0dhZmaGuLg4nDx5EnZ2drCyskJycjICAgJgamraons0NKx3895Ht5OmftS1qWHDqKgorc01XV1dW1R3IiIig2OPlsG0e6Blbm6OXr16YfDgwYiKikL//v3x8ccfAwAGDRqEzMxMlJWVobCwEAkJCbh48SJ69OjR7PKdnJxQXFysc/7ChQtSj1RDeyOVlpaipqamyTQlJSUAdHcXv1FkZCTKy8ulIz8/v9l1JyIiagt32hY895J2D7RuJoSQ5mfVUygUsLe3R05ODtLT0xEUFNTs8lQqFcrLy7F//37pXFpaGsrLy6W9j1QqFbKzs7WGJBMTEyGXyzFo0CApze7du7WWfEhMTIRSqUT37t0bvb9cLpeWr9DHRptERER092jXQGvevHnYs2cPcnNzkZWVhbfeegvJycmYMmUKAGDDhg1ITk6Wlnjw8fHBhAkT4OvrK5VRVFSEzMxMab+krKwsZGZm4tKlSwCAPn36wN/fH2FhYUhNTUVqairCwsIQGBgId3d3AICvry88PDygVquRkZGBHTt2YO7cuQgLC5MCo+DgYMjlcoSGhiI7Oxvx8fFYtGgRIiIimv3GIRER0R2JQ4cG064rwxcXF0OtVqOwsBAKhQJeXl5ISEiAj48PAKCwsBAREREoLi6Gs7Mzpk6divnz52uV8fnnn2PBggXS58ceewwAsHr1aoSGhgIA1q1bh/DwcClAGz9+PFauXCnlMTU1xZYtWzBz5kwMHz4clpaWCA4ORnR0tJRGoVAgKSkJs2bNwuDBg2Fra4uIiAhpbyYiIqK7lT6G/jh02LA7bh2tex3X0SIiouZoy3W0+szWzzpax1ZyHa2bca9DIiIiY8e9Dg2GgRYREZGxY6BlMHfcW4dERERE9wr2aBERERk52V9Ha8sgXQy0iIiIjB2HDg2GgRYREZGR4/IOhsM5WkREREQGwh4tIiIiY8ehQ4NhoEVEREQMlAyEQ4dEREREBsIeLSIiIiPHyfCGw0CLiIjI2HGOlsFw6JCIiIjIQNijRUREZOQ4dGg4DLSIiIiMHYcODYZDh0REREQGwh4tIiIiI8ehQ8NhoEVERGTsOHRoMAy0iIiIjB0DLYPhHC0iIiIiA2GgRUREZOTq52i19miu7t27QyaT6RyzZs1qMH1ycnKD6Y8fP66nFjAcDh0SEREZuzYeOjxw4ABqa2ulz9nZ2fDx8cHEiRObzHfixAnY2NhIn+3t7VtczbbGQIuIiIja1M0B0uLFi9GzZ094e3s3mc/BwQGdO3c2YM30j0OHRERERk4mhF4OAKioqNA6qqqqmrx3dXU11q5di+effx4ymazJtAMGDICzszNGjx6NnTt36u35DYmBFhERkbETejoAuLq6QqFQSEdUVFSTt/75559RVlaG0NDQRtM4Ozvjiy++QFxcHDZu3Ah3d3eMHj0au3fvvv1nbiMcOiQiIiK9yc/P15pHJZfLm0z/1VdfISAgAEqlstE07u7ucHd3lz6rVCrk5+cjOjoajz32WOsrbUAMtIiIiIycPleGt7Gx0Qq0mnL27Fls374dGzdubPH9hg4dirVr17Y4X1tjoEVERGTs2mnB0tWrV8PBwQFjx45tcd6MjAw4Ozu3/KZtjIEWERERtTmNRoPVq1cjJCQEHTpohyORkZE4f/48vv32WwDA8uXL0b17d/Tt21eaPB8XF4e4uLj2qHqLMNAiIiIycu2xqfT27duRl5eH559/XudaYWEh8vLypM/V1dWYO3cuzp8/D0tLS/Tt2xdbtmzBE0880bpKtwGZEIK7E7WhiooKKBQKlJeXN3sMm4iIjE9bfF/U32PgM+/D1NyiVWXVVl/Dodi3+P12E/ZoERERGbn26NEyFu26jlZMTAy8vLykNxRUKhW2bdsmXS8uLkZoaCiUSiWsrKzg7++PnJwcrTKqqqrw8ssvo2vXrrC2tsb48eNx7tw5rTSlpaVQq9XSmh5qtRplZWVaafLy8jBu3DhYW1uja9euCA8PR3V1tVaarKwseHt7w9LSEt26dcPChQvBDkEiIiJqTLsGWi4uLli8eDHS09ORnp6Oxx9/HEFBQThy5AiEEJgwYQJOnz6NTZs2ISMjA25ubhgzZgwqKyulMl599VXEx8cjNjYWe/fuxZUrVxAYGKi1h1JwcDAyMzORkJCAhIQEZGZmQq1WS9dra2sxduxYVFZWYu/evYiNjUVcXBxee+01KU1FRQV8fHygVCpx4MABrFixAtHR0Vi2bFnbNBYREZGh6HHBUtJ2x83RsrOzw9KlSzFixAi4u7sjOzsbffv2BVAXEDk4OGDJkiV44YUXUF5eDnt7e3z33XeYPHkyAKCgoACurq7YunUr/Pz8cOzYMXh4eCA1NRVDhgwBAKSmpkKlUuH48eNwd3fHtm3bEBgYiPz8fGnBtNjYWISGhqKkpAQ2NjaIiYlBZGQkiouLpcXXFi9ejBUrVuDcuXO33DagHudoERFRc7TlHK1Bk95HB7PWzdG6XnMNB3/kHK2b3TFb8NTW1iI2NhaVlZVQqVTS3kgWFn//4E1NTWFubo69e/cCAA4ePIiamhr4+vpKaZRKJTw9PbFv3z4AQEpKChQKhRRkAXWLnCkUCq00np6eWqvS+vn5oaqqCgcPHpTSeHt7a61w6+fnh4KCAuTm5uq5NYiIiOhe0O6BVlZWFjp27Ai5XI4ZM2YgPj4eHh4eePDBB+Hm5obIyEiUlpaiuroaixcvRlFREQoLCwEARUVFMDc3h62trVaZjo6OKCoqktI4ODjo3NfBwUErjaOjo9Z1W1tbmJubN5mm/nN9moZUVVXpbLBJRER0RxFCPwfpaPdAy93dHZmZmUhNTcVLL72EkJAQHD16FGZmZoiLi8PJkydhZ2cHKysrJCcnIyAgAKampk2WKYTQGspraFhPH2nqR12bGjaMiorS2lzT1dW1yboTERG1tfq3Dlt7kK52D7TMzc3Rq1cvDB48GFFRUejfvz8+/vhjAMCgQYOQmZmJsrIyFBYWIiEhARcvXkSPHj0AAE5OTqiurkZpaalWmSUlJVJvk5OTE4qLi3Xue+HCBa00N/dKlZaWoqampsk0JSUlAKDT03WjyMhIlJeXS0d+fn6z24aIiIjubu0eaN1MCCHNz6qnUChgb2+PnJwcpKenIygoCEBdIGZmZoakpCQpbWFhIbKzszFs2DAAdTt8l5eXY//+/VKatLQ0lJeXa6XJzs6WhiQBIDExEXK5HIMGDZLS7N69W2vJh8TERCiVSnTv3r3R55HL5dLyFS3ZaJOIiKjN8K1Dg2nXBUvnzZuHgIAAuLq64vLly4iNjUVycjISEhIAABs2bIC9vT3uu+8+ZGVl4ZVXXsGECROkye8KhQLTpk3Da6+9hi5dusDOzg5z585Fv379MGbMGABAnz594O/vj7CwMKxatQoA8OKLLyIwMBDu7u4AAF9fX3h4eECtVmPp0qW4dOkS5s6di7CwMCkwCg4OxoIFCxAaGop58+YhJycHixYtwr/+9a9mv3FIRER0J5Jp6o7WlkG62jXQKi4uhlqtRmFhIRQKBby8vJCQkAAfHx8Adb1TERERKC4uhrOzM6ZOnYr58+drlfHRRx+hQ4cOmDRpEv7880+MHj0aa9as0ZrHtW7dOoSHh0sB2vjx47Fy5UrpuqmpKbZs2YKZM2di+PDhsLS0RHBwMKKjo6U0CoUCSUlJmDVrFgYPHgxbW1tEREQgIiLCkE1EREREd7E7bh2tex3X0SIiouZoy3W0Hp7w//SyjtaBn9/m99tNuNchERGRkeNeh4bDQIuIiMjY6WMdLA6QNeiOe+uQiIiI6F7BHi0iIiIjx6FDw2GgRUREZOz0sQ4WA60GceiQiIiIyEDYo0VERGTkOHRoOAy0iIiIjB3fOjQYDh0SERERGQh7tIiIiIwchw4Nh4EWERGRseNbhwbDoUMiIiIiA2GPFhERkZHj0KHhMNAiIiIydhpRd7S2DNLBQIuIiMjYcY6WwXCOFhEREZGBsEeLiIjIyMmghzlaeqnJvYeBFhERkbHjyvAGw6FDIiIiIgNhjxYREZGR4/IOhsMeLSIiImMn9HQ007vvvguZTKZ1ODk5NZln165dGDRoECwsLHD//ffj888/b9kzthP2aBEREVGb69u3L7Zv3y59NjU1bTTtmTNn8MQTTyAsLAxr167Ff//7X8ycORP29vZ4+umn26K6t42BFhERkZGTCQFZKyeztzR/hw4dbtmLVe/zzz/Hfffdh+XLlwMA+vTpg/T0dERHR9/xgRaHDomIiIydRk9HC+Tk5ECpVKJHjx545plncPr06UbTpqSkwNfXV+ucn58f0tPTUVNT07IbtzEGWkRERKQ3FRUVWkdVVZVOmiFDhuDbb7/Ff/7zH3z55ZcoKirCsGHDcPHixQbLLCoqgqOjo9Y5R0dHXL9+Hf/73/8M8hz6wkCLiIjIyNUPHbb2AABXV1coFArpiIqK0rlfQEAAnn76afTr1w9jxozBli1bAADffPNN43WUaS+JKv66383n7zSco0VERGTs9LjXYX5+PmxsbKTTcrn8llmtra3Rr18/5OTkNHjdyckJRUVFWudKSkrQoUMHdOnS5fbr3AYYaBERERk7Pa4Mb2NjoxVoNUdVVRWOHTuGESNGNHhdpVLhl19+0TqXmJiIwYMHw8zM7Pbq20Y4dEhERERtau7cudi1axfOnDmDtLQ0/OMf/0BFRQVCQkIAAJGRkZg6daqUfsaMGTh79iwiIiJw7NgxfP311/jqq68wd+7c9nqEZmOPFhERkZFr65Xhz507h2effRb/+9//YG9vj6FDhyI1NRVubm4AgMLCQuTl5Unpe/Toga1bt2LOnDn49NNPoVQq8cknn9zxSzsADLSIiIiojTeVjo2NbfL6mjVrdM55e3vj0KFDLa1Vu+PQIREREZGBtGugFRMTAy8vL2ninEqlwrZt26TrV65cwezZs+Hi4gJLS0v06dMHMTExWmWcOnUKTz75JOzt7WFjY4NJkyahuLhYK01paSnUarX0qqlarUZZWZlWmry8PIwbNw7W1tbo2rUrwsPDUV1drZUmKysL3t7esLS0RLdu3bBw4ULp9VIiIqK7lUyjn4N0tWug5eLigsWLFyM9PR3p6el4/PHHERQUhCNHjgAA5syZg4SEBKxduxbHjh3DnDlz8PLLL2PTpk0AgMrKSvj6+kImk+G3337Df//7X1RXV2PcuHHQaP7+iQcHByMzMxMJCQlISEhAZmYm1Gq1dL22thZjx45FZWUl9u7di9jYWMTFxeG1116T0lRUVMDHxwdKpRIHDhzAihUrEB0djWXLlrVRaxERERlI/dBhaw/SIRN3WJeMnZ0dli5dimnTpsHT0xOTJ0/G/PnzpeuDBg3CE088gffeew+JiYkICAhAaWmp9CppaWkp7OzskJSUhDFjxuDYsWPw8PBAamoqhgwZAgBITU2FSqXC8ePH4e7ujm3btiEwMBD5+flQKpUA6saPQ0NDUVJSAhsbG8TExCAyMhLFxcXSmiCLFy/GihUrcO7cuWYvmFZRUQGFQoHy8vIWv/5KRETGoy2+L+rvMfKRt9Chg0Wryrp+/RqS97/P77eb3DFztGpraxEbG4vKykqoVCoAwKOPPorNmzfj/PnzEEJg586dOHnyJPz8/ADUrbshk8m0FkOzsLCAiYkJ9u7dC6BufySFQiEFWQAwdOhQKBQK7Nu3T0rj6ekpBVlA3R5KVVVVOHjwoJTG29tb615+fn4oKChAbm6uYRqFiIioLQg9HaSj3QOtrKwsdOzYEXK5HDNmzEB8fDw8PDwAAJ988gk8PDzg4uICc3Nz+Pv747PPPsOjjz4KoC5gsra2xhtvvIGrV6+isrISr7/+OjQaDQoLCwHU7Y/k4OCgc18HBwdpldmG9lCytbWFubl5k2nqP9+8Wu2NqqqqdPZ9IiIiupPocwse0tbugZa7uzsyMzORmpqKl156CSEhITh69CiAukArNTUVmzdvxsGDB/Hhhx9i5syZ2L59OwDA3t4eGzZswC+//IKOHTtKXawDBw6EqampdI+GhvWEEFrnbydNc/ZZioqK0trzydXVtTnNQkRERPeAdl9Hy9zcHL169QIADB48GAcOHMDHH3+M5cuXY968eYiPj8fYsWMBAF5eXsjMzER0dDTGjBkDAPD19cWpU6fwv//9Dx06dEDnzp3h5OSEHj16AKjbH+nmtxAB4MKFC1KPlJOTE9LS0rSul5aWoqamRitNQ/ssAdDp6bpRZGQkIiIipM8VFRUMtoiI6M7SxutoGZN279G6mRACVVVVqKmpQU1NDUxMtKtoamqq9UZhva5du6Jz58747bffUFJSgvHjxwOo2x+pvLwc+/fvl9KmpaWhvLwcw4YNk9JkZ2dLw41A3R5KcrkcgwYNktLs3r1ba8mHxMREKJVKdO/evdHnkcvl0vIVt7P/ExERkcEJAJpWHoyzGtSuPVrz5s1DQEAAXF1dcfnyZcTGxiI5ORkJCQmwsbGBt7c3Xn/9dVhaWsLNzQ27du3Ct99+q7WkwurVq9GnTx/Y29sjJSUFr7zyCubMmQN3d3cAQJ8+feDv74+wsDCsWrUKAPDiiy8iMDBQSuPr6wsPDw+o1WosXboUly5dwty5cxEWFiYFRsHBwViwYAFCQ0Mxb9485OTkYNGiRfjXv/7V7DcOiYiI7kT6mGPFOVoNa9dAq7i4GGq1GoWFhVAoFPDy8kJCQgJ8fHwA1C2xEBkZiSlTpuDSpUtwc3PD+++/jxkzZkhlnDhxApGRkbh06RK6d++Ot956C3PmzNG6z7p16xAeHg5fX18AwPjx47Fy5UrpuqmpKbZs2YKZM2di+PDhsLS0RHBwMKKjo6U0CoUCSUlJmDVrFgYPHgxbW1tERERoDQsSERER3eiOW0frXsd1tIiIqDnach2txx96Ex1M5bfO0ITrtVX4LXMxv99u0u6T4YmIiKidcTK8wdxxk+GJiIiI7hXs0SIiIjJ2GgCtfa+Lm0o3iIEWERGRkeNbh4bDoUMiIiIiA2GPFhERkbHjZHiDYaBFRERk7BhoGQyHDomIiIgMhD1aRERExo49WgbDQIuIiMjYcXkHg2GgRUREZOS4vIPhcI4WERERkYGwR4uIiMjYcY6WwTDQIiIiMnYaAchaGShpGGg1hEOHRERERAbCHi0iIiJjx6FDg2GgRUREZPT0EGiBgVZDOHRIREREZCDs0SIiIjJ2HDo0GAZaRERExk4j0OqhP7512CAOHRIREREZCAMtIiIiYyc0+jmaKSoqCg8//DA6deoEBwcHTJgwASdOnGgyT3JyMmQymc5x/Pjx1j69QTHQIiIiMnb1c7RaezTTrl27MGvWLKSmpiIpKQnXr1+Hr68vKisrb5n3xIkTKCwslI7evXu35skNjnO0iIiIjF0bz9FKSEjQ+rx69Wo4ODjg4MGDeOyxx5rM6+DggM6dO99ODdsFe7SIiIhIbyoqKrSOqqqqW+YpLy8HANjZ2d0y7YABA+Ds7IzRo0dj586dra6voTHQIiIiMnZ6HDp0dXWFQqGQjqioqFvcWiAiIgKPPvooPD09G03n7OyML774AnFxcdi4cSPc3d0xevRo7N69W69NoW8cOiQiIjJ2AnpYR6vuP/n5+bCxsZFOy+XyJrPNnj0bv//+O/bu3dtkOnd3d7i7u0ufVSoV8vPzER0dfcvhxvbEHi0iIiLSGxsbG62jqUDr5ZdfxubNm7Fz5064uLi0+F5Dhw5FTk5Oa6prcOzRIiIiMnZtvDK8EAIvv/wy4uPjkZycjB49etzWLTMyMuDs7HxbedsKAy0iIiJjp9EAaP46WI2X0TyzZs3C999/j02bNqFTp04oKioCACgUClhaWgIAIiMjcf78eXz77bcAgOXLl6N79+7o27cvqqursXbtWsTFxSEuLq519TYwBlpERETUpmJiYgAAI0eO1Dq/evVqhIaGAgAKCwuRl5cnXauursbcuXNx/vx5WFpaom/fvtiyZQueeOKJtqr2bZEJwV0g21JFRQUUCgXKy8u1JgsSERHdqC2+L+rvMcZ+GjqYmLeqrOuaamy/8BW/327SrpPhY2Ji4OXlJU2YU6lU2LZtm3T9ypUrmD17NlxcXGBpaYk+ffpIUXC9oqIiqNVqODk5wdraGgMHDsRPP/2klaa0tBRqtVp61VStVqOsrEwrTV5eHsaNGwdra2t07doV4eHhqK6u1kqTlZUFb29vWFpaolu3bli4cCEYpxIR0V2vjVeGNybtOnTo4uKCxYsXo1evXgCAb775BkFBQcjIyEDfvn0xZ84c7Ny5E2vXrkX37t2RmJiImTNnQqlUIigoCACgVqtRXl6OzZs3o2vXrvj+++8xefJkpKenY8CAAQCA4OBgnDt3TlqJ9sUXX4RarcYvv/wCAKitrcXYsWNhb2+PvXv34uLFiwgJCYEQAitWrABQF/X7+Phg1KhROHDgAE6ePInQ0FBYW1vjtddea+umIyIiorvAHTd0aGdnh6VLl2LatGnw9PTE5MmTMX/+fOn6oEGD8MQTT+C9994DAHTs2BExMTFQq9VSmi5duuCDDz7AtGnTcOzYMXh4eCA1NRVDhgwBAKSmpkKlUuH48eNwd3fHtm3bEBgYiPz8fCiVSgBAbGwsQkNDUVJSAhsbG8TExCAyMhLFxcXSq6qLFy/GihUrcO7cOchksmY9H4cOiYioOdp06NDuOf0MHV5aze+3m9wx62jV1tYiNjYWlZWVUKlUAIBHH30Umzdvxvnz5yGEwM6dO3Hy5En4+flJ+R599FH88MMPuHTpEjQaDWJjY1FVVSVNsEtJSYFCoZCCLKBu3Q2FQoF9+/ZJaTw9PaUgCwD8/PxQVVWFgwcPSmm8vb211gPx8/NDQUEBcnNzDdUsREREBieERi8H6Wr3tw6zsrKgUqlw7do1dOzYEfHx8fDw8AAAfPLJJwgLC4OLiws6dOgAExMT/Pvf/8ajjz4q5f/hhx8wefJkdOnSBR06dICVlRXi4+PRs2dPAHVzuBwcHHTu6+DgIL1OWlRUBEdHR63rtra2MDc310rTvXt3rTT1eYqKihpdA6Sqqkprn6eKioqWNA8REZHhCdGiTaEbLYN0tHuPlru7OzIzM5GamoqXXnoJISEhOHr0KIC6QCs1NRWbN2/GwYMH8eGHH2LmzJnYvn27lP/tt99GaWkptm/fjvT0dERERGDixInIysqS0jQ0rCeE0Dp/O2nqR12bGjaMiorS2vPJ1dX1Vk1CRERE94h279EyNzeXJsMPHjwYBw4cwMcff4zly5dj3rx5iI+Px9ixYwEAXl5eyMzMRHR0NMaMGYNTp05h5cqVyM7ORt++fQEA/fv3x549e/Dpp5/i888/h5OTE4qLi3Xue+HCBalHysnJCWlpaVrXS0tLUVNTo5WmvnerXklJCQDo9IbdKDIyEhEREdLniooKBltERHRnEQLSZoWtKoNu1u49WjcTQqCqqgo1NTWoqamBiYl2FU1NTaH5a/XZq1evAkCTaVQqFcrLy7F//37pelpaGsrLyzFs2DApTXZ2NgoLC6U0iYmJkMvlGDRokJRm9+7dWks+JCYmQqlU6gwp3kgul+vs+0RERHRH0Wj0c5COdg205s2bhz179iA3NxdZWVl46623kJycjClTpsDGxgbe3t54/fXXkZycjDNnzmDNmjX49ttv8eSTTwIAHnzwQfTq1QvTp0/H/v37cerUKXz44YdISkrChAkTAAB9+vSBv78/wsLCkJqaitTUVISFhSEwMFDaBdzX1xceHh5Qq9XIyMjAjh07MHfuXISFhUmBUXBwMORyOUJDQ5GdnY34+HgsWrQIERERzX7jkIiIiIxLuw4dFhcXQ61Wo7CwEAqFAl5eXkhISICPjw+AuiUWIiMjMWXKFFy6dAlubm54//33MWPGDACAmZkZtm7dijfffBPjxo3DlStX0KtXL3zzzTdaS/KvW7cO4eHh8PX1BQCMHz8eK1eulK6bmppiy5YtmDlzJoYPHw5LS0sEBwcjOjpaSqNQKJCUlIRZs2Zh8ODBsLW1RUREhNawIBER0V2JQ4cGc8eto3Wv4zpaRETUHG25jtbjVs+gg6yV62iJavx2NZbfbze54+ZoEREREd0r2v2tQyIiImpnHDo0GAZaRERExk4jABkDLUPg0CERERGRgbBHi4iIyNgJAaCV62CxR6tBDLSIiIiMnNAIiFYOHXIRg4Yx0CIiIjJ2QoPW92hxZfiGcI4WERERkYGwR4uIiMjIcejQcBhoERERGTsOHRoMA602Vh/xj3g+GiZyi7qTMkDIAGEKaDoAwkQmndctAJAJAVkttPJCBmhMZRAmAEwAYfL3+RvLqj8vpbv5ugx1a6ncmPevfFr3MwE05jf8C0j293Hzv4pkQla3Dp6m7gYyALLrgEwjg0xT90z16+RpZRWNtMEtyKplkNUCJrWoKx83POcNz3rdUkBjDmjkAsJU+zmEibih7YRWPp01/W4sXPz9X9l1mfS8ja4DKLvh0s3tXt+WWudu+FxfR5mA7K8/y268kQyQ3fwMf9W3fm1CARmgkUFoZH//jm3keW6ut1QHEwGZqYCJiYCJiaauPjfc18REwNRUQHZDHW7+sZrI6vKamtSlMfnrhjJZXT5ZfZoby7jp79nN100aaHQNZND89XwaIUOtxgS1Qgbx13Gz+nvcWIf6e5maaKQ/199PdsP1unw6RTaog0wDE5lGegYL0xqYQNQdMgEzk9q/0giY4O90pn/9GQBM//rL3kFWCxMImMpuuAYBE5kGplK7amB6w5dqfVk3lmMCDcxkN6T567r5X798TG5KX88UAjJoYHrD/f6ux43nNFo/I920f7er6U3nZABMb2jbG+fAmN74579+ANrX/84ou+EHdON5k5tm1ZjKGr5m0sQvKFNZ62fmVFypa9u26Cm6jppWr1d6HTX6qcw9hoFWG7t8+TIA4Pe499q5JkREdDe4fPkyFAqFQco2NzeHk5MT9hZt1Ut5Tk5OMDdv3Z6J9xpuKt3GNBoNCgoK0KlTJ61/TRlSRUUFXF1dkZ+fb9QbfbId/sa2qMN2qMN2qHOntYMQApcvX4ZSqYSJieHeXbt27Rqqq6v1Upa5uTksLCz0Uta9gj1abczExAQuLi7tcm8bG5s74pdHe2M7/I1tUYftUIftUOdOagdD9WTdyMLCgsGRAXF5ByIiIiIDYaBFREREZCAMtIyAXC7HO++8A7lc3t5VaVdsh7+xLeqwHeqwHeqwHcgQOBmeiIiIyEDYo0VERERkIAy0iIiIiAyEgRYRERGRgTDQIiIiIjIQBlp3gN27d2PcuHFQKpWQyWT4+eefta5v3LgRfn5+6Nq1K2QyGTIzMxstSwiBgICABsspLS2FWq2GQqGAQqGAWq1GWVmZVpq8vDyMGzcO1tbW6Nq1K8LDw3VWDM7KyoK3tzcsLS3RrVs3LFy4UC97cemrHVJSUvD444/D2toanTt3xsiRI/Hnn38aVTsUFRVBrVbDyckJ1tbWGDhwIH766SetNHd6OwBNt0VNTQ3eeOMN9OvXD9bW1lAqlZg6dSoKCgq0yqiqqsLLL7+Mrl27wtraGuPHj8e5c+fuqrZobTtcunQJL7/8Mtzd3WFlZYX77rsP4eHhKC8vN6p2uNHd/LuS7i4MtO4AlZWV6N+/P1auXNno9eHDh2Px4sW3LGv58uWNbu0THByMzMxMJCQkICEhAZmZmVCr1dL12tpajB07FpWVldi7dy9iY2MRFxeH1157TUpTUVEBHx8fKJVKHDhwACtWrEB0dDSWLVvWwqdu+Dlb2w4pKSnw9/eHr68v9u/fjwMHDmD27Nla21cYQzuo1WqcOHECmzdvRlZWFp566ilMnjwZGRkZd0071D9rY21x9epVHDp0CPPnz8ehQ4ewceNGnDx5EuPHj9dK9+qrryI+Ph6xsbHYu3cvrly5gsDAQNTW1kpp7vS2aG07FBQUoKCgANHR0cjKysKaNWuQkJCAadOmaZV1r7fDje7m35V0lxF0RwEg4uPjG7x25swZAUBkZGQ0eD0zM1O4uLiIwsJCnXKOHj0qAIjU1FTpXEpKigAgjh8/LoQQYuvWrcLExEScP39eSrN+/Xohl8tFeXm5EEKIzz77TCgUCnHt2jUpTVRUlFAqlUKj0dzmU+u63XYYMmSIePvttxst11jawdraWnz77bda5+zs7MS///1vIcTd1w5CNN0W9fbv3y8AiLNnzwohhCgrKxNmZmYiNjZWSnP+/HlhYmIiEhIShBB3X1vcTjs05McffxTm5uaipqZGCGFc7XAv/a6kOx97tO4RV69exbPPPouVK1fCyclJ53pKSgoUCgWGDBkinRs6dCgUCgX27dsnpfH09IRSqZTS+Pn5oaqqCgcPHpTSeHt7ay3o5+fnh4KCAuTm5hro6ZqnpKQEaWlpcHBwwLBhw+Do6Ahvb2/s3btXSmMM7QAAjz76KH744QdcunQJGo0GsbGxqKqqwsiRIwHcu+1QXl4OmUyGzp07AwAOHjyImpoa+Pr6SmmUSiU8PT21nvNea4ub26GxNDY2NujQoW7LW2NpB/6upLbGQOseMWfOHAwbNgxBQUENXi8qKoKDg4POeQcHBxQVFUlpHB0dta7b2trC3Ny8yTT1n+vTtJfTp08DAN59912EhYUhISEBAwcOxOjRo5GTkwPAONoBAH744Qdcv34dXbp0gVwux/Tp0xEfH4+ePXsCuDfb4dq1a3jzzTcRHBwsbQhcVFQEc3Nz2Nra6tTxxme4l9qioXa42cWLF/Hee+9h+vTp0jljaQf+rqS21qG9K0Ctt3nzZvz2229a828a0tB8BCGE1vnbSSP+mtzZ2HyHtqLRaAAA06dPx3PPPQcAGDBgAHbs2IGvv/4aUVFRAO79dgCAt99+G6Wlpdi+fTu6du2Kn3/+GRMnTsSePXvQr18/APdWO9TU1OCZZ56BRqPBZ599dsv0+njO5qRp67ZoTjtUVFRg7Nix8PDwwDvvvKN17V5vB/6upPbAHq17wG+//YZTp06hc+fO6NChgzQU8PTTT0tDRU5OTiguLtbJe+HCBelfWU5OTjr/0iotLUVNTU2TaUpKSgBA519vbc3Z2RkA4OHhoXW+T58+yMvLA2Ac7XDq1CmsXLkSX3/9NUaPHo3+/fvjnXfeweDBg/Hpp58CuLfaoaamBpMmTcKZM2eQlJSk1Xvh5OSE6upqlJaW6tTxxme4F9qiqXaod/nyZfj7+6Njx46Ij4+HmZmZdM0Y2oG/K6k9MNC6B7z55pv4/fffkZmZKR0A8NFHH2H16tUAAJVKhfLycuzfv1/Kl5aWhvLycgwbNkxKk52djcLCQilNYmIi5HI5Bg0aJKXZvXu31mvMiYmJUCqV6N69u4GftGndu3eHUqnEiRMntM6fPHkSbm5uAIyjHa5evQoAWm9aAoCpqanU63evtEP9l2pOTg62b9+OLl26aF0fNGgQzMzMkJSUJJ0rLCxEdna21nPe7W1xq3YA6nqyfH19YW5ujs2bN8PCwkLrujG0A39XUrto48n31IDLly+LjIwMkZGRIQCIZcuWiYyMDOlNmYsXL4qMjAyxZcsWAUDExsaKjIwMUVhY2GiZaOCNHH9/f+Hl5SVSUlJESkqK6NevnwgMDJSuX79+XXh6eorRo0eLQ4cOie3btwsXFxcxe/ZsKU1ZWZlwdHQUzz77rMjKyhIbN24UNjY2Ijo6+o5oh48++kjY2NiIDRs2iJycHPH2228LCwsL8ccffxhNO1RXV4tevXqJESNGiLS0NPHHH3+I6OhoIZPJxJYtW+6adrhVW9TU1Ijx48cLFxcXkZmZKQoLC6WjqqpKKmPGjBnCxcVFbN++XRw6dEg8/vjjon///uL69et3TVu0th0qKirEkCFDRL9+/cQff/yhlcaY2qEhd+PvSrq7MNC6A+zcuVMA0DlCQkKEEEKsXr26wevvvPNOo2U29Mvj4sWLYsqUKaJTp06iU6dOYsqUKaK0tFQrzdmzZ8XYsWOFpaWlsLOzE7Nnz9Z6PVkIIX7//XcxYsQIIZfLhZOTk3j33Xf18rqyvtohKipKuLi4CCsrK6FSqcSePXuMrh1OnjwpnnrqKeHg4CCsrKyEl5eXznIPd3o73Kot6pe3aOjYuXOnVMaff/4pZs+eLezs7ISlpaUIDAwUeXl5d1VbtLYdGssPQJw5c8Zo2qEhd+PvSrq7yITgMrVEREREhsA5WkREREQGwkCLiIiIyEAYaBEREREZCAMtIiIiIgNhoEVERERkIAy0iIiIiAyEgRYRERGRgTDQIiIiIjIQBlpEREREBsJAi4iIiMhAGGgRUbu4cOECnJycsGjRIulcWloazM3NkZiY2I41IyLSH+51SETtZuvWrZgwYQL27duHBx98EAMGDMDYsWOxfPny9q4aEZFeMNAionY1a9YsbN++HQ8//DAOHz6MAwcOwMLCor2rRUSkFwy0iKhd/fnnn/D09ER+fj7S09Ph5eXV3lUiItIbztEionZ1+vRpFBQUQKPR4OzZs+1dHSIivWKPFhG1m+rqajzyyCN46KGH8OCDD2LZsmXIysqCo6Nje1eNiEgvGGgRUbt5/fXX8dNPP+Hw4cPo2LEjRo0ahU6dOuHXX39t76oREekFhw6JqF0kJydj+fLl+O6772BjYwMTExN899132Lt3L2JiYtq7ekREesEeLSIiIiIDYY8WERERkYEw0CIiIiIyEAZaRERERAbCQIuIiIjIQBhoERERERkIAy0iIiIiA2GgRURERGQgDLSIiIiIDISBFhEREZGBMNAiIiIiMhAGWkREREQGwkCLiIiIyED+P3Tcd9RqDhHgAAAAAElFTkSuQmCC",[m
[31m-      "text/plain": [[m
[31m-       "<Figure size 640x480 with 2 Axes>"[m
[31m-      ][m
[31m-     },[m
[31m-     "metadata": {},[m
[31m-     "output_type": "display_data"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "MF6_Mdl_AoI['chd_merged']['head'].isel(time=0, layer=0).plot.imshow(cmap='viridis')"[m
    ][m
[36m@@ -29299,7 +901,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 43,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f977772d",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29321,7 +923,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 44,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "dfadb000",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29340,7 +942,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 45,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "8e4be448",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29351,7 +953,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 54,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "c1a52b72",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29361,7 +963,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 47,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "802caf67",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29373,7 +975,7 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 55,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "682653d8",[m
    "metadata": {},[m
    "outputs": [],[m
[36m@@ -29391,142 +993,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 52,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "7e0bc60d",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "text/html": [[m
[31m-       "<div>\n",[m
[31m-       "<style scoped>\n",[m
[31m-       "    .dataframe tbody tr th:only-of-type {\n",[m
[31m-       "        vertical-align: middle;\n",[m
[31m-       "    }\n",[m
[31m-       "\n",[m
[31m-       "    .dataframe tbody tr th {\n",[m
[31m-       "        vertical-align: top;\n",[m
[31m-       "    }\n",[m
[31m-       "\n",[m
[31m-       "    .dataframe thead th {\n",[m
[31m-       "        text-align: right;\n",[m
[31m-       "    }\n",[m
[31m-       "</style>\n",[m
[31m-       "<table border=\"1\" class=\"dataframe\">\n",[m
[31m-       "  <thead>\n",[m
[31m-       "    <tr style=\"text-align: right;\">\n",[m
[31m-       "      <th></th>\n",[m
[31m-       "      <th>exec_count</th>\n",[m
[31m-       "      <th>seconds</th>\n",[m
[31m-       "      <th>label</th>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "  </thead>\n",[m
[31m-       "  <tbody>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>0</th>\n",[m
[31m-       "      <td>18</td>\n",[m
[31m-       "      <td>6.044033e+01</td>\n",[m
[31m-       "      <td>Sim_MF6 = mf6.Modflow6Simulation.from_imod5_da...</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>1</th>\n",[m
[31m-       "      <td>49</td>\n",[m
[31m-       "      <td>1.717024e+01</td>\n",[m
[31m-       "      <td>metamod.write(directory=d_Pa['Pa_MdlN'], modfl...</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>2</th>\n",[m
[31m-       "      <td>51</td>\n",[m
[31m-       "      <td>1.656268e+01</td>\n",[m
[31m-       "      <td>PRJ_, PRJ_OBS = UIM.o_PRJ_with_OBS(Pa_PRJ)</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>3</th>\n",[m
[31m-       "      <td>11</td>\n",[m
[31m-       "      <td>1.079746e+01</td>\n",[m
[31m-       "      <td>PRJ_, PRJ_OBS = UIM.o_PRJ_with_OBS(Pa_PRJ)</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>4</th>\n",[m
[31m-       "      <td>26</td>\n",[m
[31m-       "      <td>8.888007e+00</td>\n",[m
[31m-       "      <td>Sim_MF6_AoI = Sim_MF6.clip_box(x_min=Xmin, x_m...</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>...</th>\n",[m
[31m-       "      <td>...</td>\n",[m
[31m-       "      <td>...</td>\n",[m
[31m-       "      <td>...</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>59</th>\n",[m
[31m-       "      <td>8</td>\n",[m
[31m-       "      <td>1.033500e-03</td>\n",[m
[31m-       "      <td>MdlN = 'NBr32'</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>60</th>\n",[m
[31m-       "      <td>36</td>\n",[m
[31m-       "      <td>1.015500e-03</td>\n",[m
[31m-       "      <td>MF6_Mdl_AoI = Sim_MF6_AoI['imported_model']</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>61</th>\n",[m
[31m-       "      <td>14</td>\n",[m
[31m-       "      <td>8.548000e-04</td>\n",[m
[31m-       "      <td>BND = PRJ_regrid['bnd']['ibound']</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>62</th>\n",[m
[31m-       "      <td>4</td>\n",[m
[31m-       "      <td>8.496000e-04</td>\n",[m
[31m-       "      <td>import matplotlib.pyplot as plt</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "    <tr>\n",[m
[31m-       "      <th>63</th>\n",[m
[31m-       "      <td>2</td>\n",[m
[31m-       "      <td>-5.999900e-07</td>\n",[m
[31m-       "      <td># Put this in the FIRST cell and run it once</td>\n",[m
[31m-       "    </tr>\n",[m
[31m-       "  </tbody>\n",[m
[31m-       "</table>\n",[m
[31m-       "<p>64 rows Ã— 3 columns</p>\n",[m
[31m-       "</div>"[m
[31m-      ],[m
[31m-      "text/plain": [[m
[31m-       "    exec_count       seconds  \\\n",[m
[31m-       "0           18  6.044033e+01   \n",[m
[31m-       "1           49  1.717024e+01   \n",[m
[31m-       "2           51  1.656268e+01   \n",[m
[31m-       "3           11  1.079746e+01   \n",[m
[31m-       "4           26  8.888007e+00   \n",[m
[31m-       "..         ...           ...   \n",[m
[31m-       "59           8  1.033500e-03   \n",[m
[31m-       "60          36  1.015500e-03   \n",[m
[31m-       "61          14  8.548000e-04   \n",[m
[31m-       "62           4  8.496000e-04   \n",[m
[31m-       "63           2 -5.999900e-07   \n",[m
[31m-       "\n",[m
[31m-       "                                                label  \n",[m
[31m-       "0   Sim_MF6 = mf6.Modflow6Simulation.from_imod5_da...  \n",[m
[31m-       "1   metamod.write(directory=d_Pa['Pa_MdlN'], modfl...  \n",[m
[31m-       "2          PRJ_, PRJ_OBS = UIM.o_PRJ_with_OBS(Pa_PRJ)  \n",[m
[31m-       "3          PRJ_, PRJ_OBS = UIM.o_PRJ_with_OBS(Pa_PRJ)  \n",[m
[31m-       "4   Sim_MF6_AoI = Sim_MF6.clip_box(x_min=Xmin, x_m...  \n",[m
[31m-       "..                                                ...  \n",[m
[31m-       "59                                     MdlN = 'NBr32'  \n",[m
[31m-       "60        MF6_Mdl_AoI = Sim_MF6_AoI['imported_model']  \n",[m
[31m-       "61                  BND = PRJ_regrid['bnd']['ibound']  \n",[m
[31m-       "62                    import matplotlib.pyplot as plt  \n",[m
[31m-       "63       # Put this in the FIRST cell and run it once  \n",[m
[31m-       "\n",[m
[31m-       "[64 rows x 3 columns]"[m
[31m-      ][m
[31m-     },[m
[31m-     "metadata": {},[m
[31m-     "output_type": "display_data"[m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "t = show_cell_times()"[m
    ][m
[36m@@ -29541,75 +1011,10 @@[m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 61,[m
[32m+[m[32m   "execution_count": null,[m
    "id": "f067378d",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "ðŸš€ Starting coupled model execution...\n",[m
[31m-      "Model directory: C:/OD/WS_Mdl\\models/NBr\\Sim/NBr32\n",[m
[31m-      "\n",[m
[31m-      "ðŸ“ Checking written model files:\n",[m
[31m-      "  - exchanges\n",[m
[31m-      "  - imod_coupler.toml\n",[m
[31m-      "  - metaswap\n",[m
[31m-      "  - modflow6\n",[m
[31m-      "\n",[m
[31m-      "ðŸŽ¯ Found TOML configuration file: imod_coupler.toml\n",[m
[31m-      "âœ… Found iMOD coupler: C:\\OD\\WS_Mdl\\software\\iMOD5\\bin\\iMOD_coupler\\imodc.exe\n",[m
[31m-      "ðŸ”„ Executing: C:\\OD\\WS_Mdl\\software\\iMOD5\\bin\\iMOD_coupler\\imodc.exe C:/OD/WS_Mdl\\models/NBr\\Sim/NBr32\\imod_coupler.toml\n",[m
[31m-      "Return code: 1\n",[m
[31m-      "STDERR:\n",[m
[31m-      "iMOD Coupler: \u001b[1miMOD Coupler 0.11.0-dev\u001b[0m\n",[m
[31m-      "iMOD Coupler: \u001b[31m\u001b[1miMOD Coupler run failed with: \u001b[0m\n",[m
[31m-      "\u001b[33m\u001b[1mTraceback (most recent call last):\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m57\u001b[0m, in \u001b[35m<module>\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "> File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m26\u001b[0m, in \u001b[35mmain\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m45\u001b[0m, in \u001b[35mrun_coupler\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\drivers\\\u001b[0m\u001b[32m\u001b[1mdriver.py\u001b[0m\", line \u001b[33m70\u001b[0m, in \u001b[35mget_driver\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\drivers\\metamod\\\u001b[0m\u001b[32m\u001b[1mconfig.py\u001b[0m\", line \u001b[33m89\u001b[0m, in \u001b[35m__init__\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mpydantic\\\u001b[0m\u001b[32m\u001b[1mmain.py\u001b[0m\", line \u001b[33m341\u001b[0m, in \u001b[35mpydantic.main.BaseModel.__init__\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "\u001b[31m\u001b[1mpydantic.error_wrappers.ValidationError\u001b[0m:\u001b[1m 1 validation error for MetaModConfig\n",[m
[31m-      "coupling -> 0 -> enable_sprinkling\n",[m
[31m-      "  field required (type=value_error.missing)\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "âŒ Model execution failed with return code 1\n",[m
[31m-      "Return code: 1\n",[m
[31m-      "STDERR:\n",[m
[31m-      "iMOD Coupler: \u001b[1miMOD Coupler 0.11.0-dev\u001b[0m\n",[m
[31m-      "iMOD Coupler: \u001b[31m\u001b[1miMOD Coupler run failed with: \u001b[0m\n",[m
[31m-      "\u001b[33m\u001b[1mTraceback (most recent call last):\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m57\u001b[0m, in \u001b[35m<module>\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "> File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m26\u001b[0m, in \u001b[35mmain\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\\u001b[0m\u001b[32m\u001b[1m__main__.py\u001b[0m\", line \u001b[33m45\u001b[0m, in \u001b[35mrun_coupler\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\drivers\\\u001b[0m\u001b[32m\u001b[1mdriver.py\u001b[0m\", line \u001b[33m70\u001b[0m, in \u001b[35mget_driver\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mimod_coupler\\drivers\\metamod\\\u001b[0m\u001b[32m\u001b[1mconfig.py\u001b[0m\", line \u001b[33m89\u001b[0m, in \u001b[35m__init__\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "  File \"\u001b[32mpydantic\\\u001b[0m\u001b[32m\u001b[1mmain.py\u001b[0m\", line \u001b[33m341\u001b[0m, in \u001b[35mpydantic.main.BaseModel.__init__\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "\u001b[31m\u001b[1mpydantic.error_wrappers.ValidationError\u001b[0m:\u001b[1m 1 validation error for MetaModConfig\n",[m
[31m-      "coupling -> 0 -> enable_sprinkling\n",[m
[31m-      "  field required (type=value_error.missing)\u001b[0m\n",[m
[31m-      "\n",[m
[31m-      "âŒ Model execution failed with return code 1\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
     "# Execute the coupled model\n",[m
     "print(\"ðŸš€ Starting coupled model execution...\")\n",[m
[1mdiff --git a/code/WS_Mdl/utils.py b/code/WS_Mdl/utils.py[m
[1mindex af0583f..a810be3 100644[m
[1m--- a/code/WS_Mdl/utils.py[m
[1m+++ b/code/WS_Mdl/utils.py[m
[36m@@ -10,6 +10,7 @@[m [mfrom io import StringIO[m
 from multiprocessing import Pool, cpu_count[m
 from os import listdir as LD[m
 from os.path import basename as PBN[m
[32m+[m[32mfrom os.path import dirname as PDN[m
 from os.path import join as PJ[m
 from pathlib import Path[m
 [m
[36m@@ -151,6 +152,7 @@[m [mdef get_MdlN_Pa(MdlN: str, MdlN_B=None, verbose=False):[m
 [m
         d_Pa['Sim'] = PJ(d_Pa['Pa_Mdl'], 'Sim')  # Sim folder[m
         d_Pa['Pa_MdlN'] = PJ(d_Pa['Pa_Mdl'], f'Sim/{MdlN}')[m
[32m+[m[32m        d_Pa['TOML'] = PJ(d_Pa['Pa_MdlN'], 'imod_coupler.toml')[m
         d_Pa['LST_Sim'] = PJ(d_Pa['Pa_MdlN'], 'mfsim.lst')  # Sim LST file[m
         d_Pa['LST_Mdl'] = PJ(d_Pa['Pa_MdlN'], f'GWF_1/{MdlN}.lst')  # Mdl LST file[m
         d_Pa['NAM_Sim'] = PJ(d_Pa['Pa_MdlN'], 'MFSIM.NAM')  # Sim LST file[m
[36m@@ -923,9 +925,8 @@[m [mdef freeze_pixi_env(MdlN: str):[m
 [m
         # Commit with timestamp[m
         now = DT.now().strftime('%Y-%m-%d %H:%M:%S')[m
[31m-        commit_msg = f'{MdlN} env snapshot - {now}'[m
[32m+[m[32m        commit_msg = f'#auto {MdlN} env snapshot - {now}'[m
         run_cmd(['git', 'commit', '-m', commit_msg])[m
[31m-        print(f"ðŸŸ¢ðŸŸ¢ðŸŸ¢ Committed changes with message: '{commit_msg}'")[m
 [m
         # Get the commit hash of the just-created commit[m
         commit_hash = run_cmd(['git', 'rev-parse', 'HEAD'], capture=True).stdout.strip()[m
[36m@@ -940,6 +941,8 @@[m [mdef freeze_pixi_env(MdlN: str):[m
             tag = '-'[m
             print('âšªï¸ No tag found for this commit. Only the hash will be recorded.')[m
 [m
[32m+[m[32m        print(f"ðŸŸ¢ðŸŸ¢ðŸŸ¢ Committed changes with message: '{commit_msg}'")[m
[32m+[m
         return commit_hash, tag[m
 [m
     except sp.CalledProcessError as e:[m
[36m@@ -947,6 +950,21 @@[m [mdef freeze_pixi_env(MdlN: str):[m
         sys.exit(1)[m
 [m
 [m
[32m+[m[32mdef Mdl_Prep(MdlN: str):[m
[32m+[m[32m    set_verbose(False)[m
[32m+[m
[32m+[m[32m    # Load paths and variables from PRJ & INI[m
[32m+[m[32m    d_Pa = get_MdlN_Pa(MdlN)[m
[32m+[m[32m    Pa_PRJ = d_Pa['PRJ'][m
[32m+[m[32m    Dir_PRJ = PDN(Pa_PRJ)[m
[32m+[m[32m    d_INI = INI_to_d(d_Pa['INI'])[m
[32m+[m[32m    Xmin, Ymin, Xmax, Ymax = [float(i) for i in d_INI['WINDOW'].split(',')][m
[32m+[m[32m    SP_date_1st, SP_date_last = [[m
[32m+[m[32m        DT.strftime(DT.strptime(d_INI[f'{i}'], '%Y%m%d'), '%Y-%m-%d') for i in ['SDATE', 'EDATE'][m
[32m+[m[32m    ][m
[32m+[m[32m    dx = dy = float(d_INI['CELLSIZE'])[m
[32m+[m
[32m+[m
 # --------------------------------------------------------------------------------[m
 [m
 [m
[1mdiff --git a/code/WS_Mdl/utils_imod.py b/code/WS_Mdl/utils_imod.py[m
[1mindex 1188812..3421626 100644[m
[1m--- a/code/WS_Mdl/utils_imod.py[m
[1m+++ b/code/WS_Mdl/utils_imod.py[m
[36m@@ -7,6 +7,7 @@[m [mfrom os.path import basename as PBN[m
 from os.path import dirname as PDN[m
 from os.path import exists as PE[m
 from os.path import join as PJ[m
[32m+[m[32mfrom datetime import datetime as DT[m
 [m
 import imod[m
 [m
[36m@@ -16,8 +17,10 @@[m [mimport pandas as pd[m
 import xarray as xr[m
 from filelock import FileLock as FL[m
 from imod import mf6[m
[32m+[m[32mfrom imod import msw[m
 from tqdm import tqdm  # Track progress of the loop[m
 [m
[32m+[m[32mfrom WS_Mdl import utils as U[m
 from .utils import ([m
     INI_to_d,[m
     Mdl_Dmns_from_INI,[m
[36m@@ -35,7 +38,7 @@[m [mcustom_characters = {[m
     'positive': 'ðŸŸ¢',[m
     'no action required': 'âšªï¸',[m
     'already done': 'âš«ï¸',[m
[31m-}[m
[32m+[m[32m} # Rule for using multiple e.g. ðŸŸ¢ðŸŸ¢ðŸŸ¢. Use 2 when a function returns an object. Use 3 for more impactful functions that save a file, or complete a longer process, like commiting git changes. In all other cases use 1.[m
 [m
 [m
 # PRJ related --------------------------------------------------------------------[m
[36m@@ -135,7 +138,7 @@[m [mdef PRJ_to_DF(MdlN):[m
             DF.loc[f'{Pkg_name.upper()}'] = '-'[m
             DF.loc[f'{Pkg_name.upper()}', 'active'] = f'Failed to read package: {e}'[m
             vprint('ðŸŸ¡')[m
[31m-    vprint('ðŸŸ¢ðŸŸ¢ðŸŸ¢')[m
[32m+[m[32m    vprint('ðŸŸ¢ðŸŸ¢')[m
     vprint(f' {"-" * 100}')[m
 [m
     DF['package'] = DF['package'].str.replace('(', '').str.replace(')', '').str.upper()[m
[36m@@ -189,6 +192,7 @@[m [mdef o_PRJ_with_OBS(Pa_PRJ):[m
     PRJ = imod.prj.open_projectfile_data(Pa_PRJ_temp)  # Load the PRJ file without OBS[m
     os.remove(Pa_PRJ_temp)  # Delete temp PRJ file as it's not needed anymore.[m
 [m
[32m+[m[32m    vprint(f'ðŸŸ¢ðŸŸ¢ - PRJ loaded from {Pa_PRJ}')[m
     return PRJ, l_OBS_Lns[m
 [m
 [m
[36m@@ -267,7 +271,7 @@[m [mdef regrid_PRJ(PRJ, MdlN: str = None, x_CeCes=None, y_CeCes=None, method='linear[m
             # Handle top-level data[m
             PRJ_regridded[key] = regrid_DA(data, x_CeCes, y_CeCes, dx, dy, key, method)[m
 [m
[31m-    vprint('ðŸŸ¢ðŸŸ¢ðŸŸ¢ - Regridding complete.')[m
[32m+[m[32m    vprint('ðŸŸ¢ðŸŸ¢ðŸŸ¢ - PRJ has been regridded successfully!')[m
     return PRJ_regridded[m
 [m
 [m
[36m@@ -385,6 +389,326 @@[m [mdef mete_grid_Cvt_to_AbsPa(Pa_PRJ: str, PRJ: dict = None):[m
 [m
 # --------------------------------------------------------------------------------[m
 [m
[32m+[m[32m# Mdl related -----------------------------------------------------------------[m
[32m+[m
[32m+[m[32mdef Mdl_Prep(MdlN: str):[m
[32m+[m
[32m+[m
[32m+[m[32m    # Load paths and variables from PRJ & INI[m
[32m+[m[32m    d_Pa = get_MdlN_Pa(MdlN)[m
[32m+[m[32m    Pa_PRJ = d_Pa['PRJ'][m
[32m+[m[32m    Dir_PRJ = PDN(Pa_PRJ)[m
[32m+[m[32m    d_INI = INI_to_d(d_Pa['INI'])[m
[32m+[m[32m    Xmin, Ymin, Xmax, Ymax = [float(i) for i in d_INI['WINDOW'].split(',')][m
[32m+[m[32m    SP_date_1st, SP_date_last = [[m
[32m+[m[32m        DT.strftime(DT.strptime(d_INI[f'{i}'], '%Y%m%d'), '%Y-%m-%d') for i in ['SDATE', 'EDATE'][m
[32m+[m[32m    ][m
[32m+[m[32m    dx = dy = float(d_INI['CELLSIZE'])[m
[32m+[m
[32m+[m
[32m+[m[32m    # Load PRJ & regrid it to Mdl Aa[m
[32m+[m[32m    PRJ_, PRJ_OBS = o_PRJ_with_OBS(Pa_PRJ)[m
[32m+[m[32m    PRJ, period_data = PRJ_[0], PRJ_[1][m
[32m+[m[32m    PRJ_regrid = regrid_PRJ(PRJ, MdlN) # Using original PRJ to load MF6 Mdl gives warnings (and it's very slow). Regridding works much better though.[m
[32m+[m
[32m+[m[32m    # Set outer boundaries to -1. Otherwise CHD won't be loaded properly.[m
[32m+[m[32m    BND = PRJ_regrid['bnd']['ibound'][m
[32m+[m[32m    BND.loc[:, [BND.y[0], BND.y[-1]], :] = -1  # Top and bottom rows[m
[32m+[m[32m    BND.loc[:, :, [BND.x[0], BND.x[-1]]] = -1  # Left and right columns[m
[32m+[m[32m    vprint("ðŸŸ¢ - Boundary conditions set successfully!")[m
[32m+[m[41m    [m
[32m+[m[32m    # Load MF6 Simulation[m
[32m+[m[32m    times = pd.date_range(SP_date_1st, SP_date_last, freq='D')[m
[32m+[m[32m    Sim_MF6 = mf6.Modflow6Simulation.from_imod5_data(PRJ_regrid, period_data, times) # It can be further sped up by multi-processing, but this is not implemented yet.[m
[32m+[m[32m    vprint("ðŸŸ¢ - MF6 Simulation loaded successfully!")[m
[32m+[m[32m    Sim_MF6[f'{MdlN}'] = Sim_MF6.pop('imported_model')  # Rename imported_model to MdlN.[m
[32m+[m[41m    [m
[32m+[m[32m    # Pass the Sim components to objects.[m
[32m+[m[32m    MF6_Mdl = Sim_MF6[f'{MdlN}'][m
[32m+[m[32m    MF6_Mdl["oc"] = mf6.OutputControl(save_head="last", save_budget="last")[m
[32m+[m[32m    Sim_MF6["ims"] = mf6_solution_moderate_settings() # Mimic iMOD5's "Moderate" settings.[m
[32m+[m[32m    MF6_DIS = Sim_MF6[f'{MdlN}']["dis"][m
[32m+[m
[32m+[m[32m    # Load MSW[m
[32m+[m[32m    PRJ_MSW = {'cap': PRJ_regrid.copy()['cap'], 'extra': PRJ_regrid.copy()['extra']} # Isolate MSW keys from PRJ.[m
[32m+[m[32m    PRJ_MSW['extra']['paths'][2][0] = mete_grid_Cvt_to_AbsPa(Pa_PRJ, PRJ) ## Fix mete_grid.inp relative paths. Replace the mete_grid.inp path in the PRJ_MSW_for_MSW dictionary[m
[32m+[m[32m    MSW_Mdl = msw.MetaSwapModel.from_imod5_data(PRJ_MSW, MF6_DIS, times) # Load MSW model from PRJ[m
[32m+[m[32m    vprint("ðŸŸ¢ - MSW Simulation loaded successfully!")[m
[32m+[m
[32m+[m[32m    # Clip models[m
[32m+[m[32m    Sim_MF6_AoI = Sim_MF6.clip_box(x_min=Xmin, x_max=Xmax, y_min=Ymin, y_max=Ymax)[m
[32m+[m[32m    MF6_Mdl_AoI = Sim_MF6_AoI[f'{MdlN}'][m
[32m+[m[32m    MSW_Mdl_AoI = MSW_Mdl.clip_box(x_min=Xmin, x_max=Xmax, y_min=Ymin, y_max=Ymax) # clip_box doesn't clip the packages I clipped beforehand, but it clips non raster-like packages like WEL and removes packages that are not in the AoI.[m
[32m+[m[32m    print(f"MF6 Model AoI DIS shape: {MF6_Mdl_AoI['dis'].dataset.sizes}")[m
[32m+[m[32m    print(f"MSW Model AoI grid shape: {MSW_Mdl_AoI['grid'].dataset.sizes}")[m
[32m+[m[32m    print("ðŸŸ¢ Both models successfully clipped to Area of Interest with compatible discretization!")[m
[32m+[m
[32m+[m[32m    MF6_Mdl_AoI['dis'].dataset.equals(MF6_Mdl['dis'].dataset)[m
[32m+[m
[32m+[m[32m    # Sense check code to ensure the AoI models are correct exists in imod_python_init_NBr32.ipynb[m
[32m+[m
[32m+[m[32m    # Load models into memory[m
[32m+[m[32m    for pkg in MF6_Mdl_AoI.values():[m
[32m+[m[32m        pkg.dataset.load()[m
[32m+[m
[32m+[m[32m    for pkg in MSW_Mdl_AoI.values():[m
[32m+[m[32m        pkg.dataset.load()[m
[32m+[m
[32m+[m[32m    # Cleanup[m
[32m+[m[41m    [m
[32m+[m[32m    # MF6[m
[32m+[m[32m    # Create mask from current regridded model (not the old one)[m
[32m+[m[32m    mask = MF6_Mdl_AoI.domain #666 mask needs to be checked and potentially updated with -1 values at the edge of the Mdl Aa.[m
[32m+[m[32m    Sim_MF6_AoI.mask_all_models(mask)[m
[32m+[m[32m    DIS_AoI = MF6_Mdl_AoI["dis"][m
[32m+[m[41m    [m
[32m+[m[32m    ### Check if the packages are the same[m
[32m+[m[32m    MF6_Mdl_AoI = Sim_MF6_AoI[f'{MdlN}'][m
[32m+[m[32m    # Compare the keys of both models[m
[32m+[m[32m    keys_equal = MF6_Mdl.keys() == MF6_Mdl_AoI.keys()[m
[32m+[m[32m    print(f"Are the keys identical? {keys_equal}")[m
[32m+[m[32m    print()[m
[32m+[m
[32m+[m[32m    # Get the actual keys for detailed comparison[m
[32m+[m[32m    original_keys = set(MF6_Mdl.keys())[m
[32m+[m[32m    aoi_keys = set(MF6_Mdl_AoI.keys())[m
[32m+[m
[32m+[m[32m    print("=== DETAILED KEY COMPARISON ===")[m
[32m+[m[32m    print(f"Original model has {len(original_keys)} packages:")[m
[32m+[m[32m    for key in sorted(original_keys):[m
[32m+[m[32m        print(f"  - {key}")[m
[32m+[m
[32m+[m[32m    print(f"\nAoI model has {len(aoi_keys)} packages:")[m
[32m+[m[32m    for key in sorted(aoi_keys):[m
[32m+[m[32m        print(f"  - {key}")[m
[32m+[m
[32m+[m[32m    # Find differences[m
[32m+[m[32m    missing_in_aoi = original_keys - aoi_keys[m
[32m+[m[32m    extra_in_aoi = aoi_keys - original_keys[m
[32m+[m[32m    common_keys = original_keys & aoi_keys[m
[32m+[m
[32m+[m[32m    print(f"\n=== DIFFERENCES ===")[m
[32m+[m[32m    if missing_in_aoi:[m
[32m+[m[32m        print(f"Packages REMOVED in AoI model ({len(missing_in_aoi)}):")[m
[32m+[m[32m        for key in sorted(missing_in_aoi):[m
[32m+[m[32m            print(f"  âŒ {key}")[m
[32m+[m[32m            # Try to understand why it was removed[m
[32m+[m[32m            try:[m
[32m+[m[32m                pkg = MF6_Mdl[key][m
[32m+[m[32m                if hasattr(pkg, 'dataset') and hasattr(pkg.dataset, 'sizes'):[m
[32m+[m[32m                    print(f"     Size in original: {dict(pkg.dataset.sizes)}")[m
[32m+[m[32m            except:[m
[32m+[m[32m                pass[m
[32m+[m[32m    else:[m
[32m+[m[32m        print("âœ… No packages removed in AoI model")[m
[32m+[m
[32m+[m[32m    if extra_in_aoi:[m
[32m+[m[32m        print(f"\nPackages ADDED in AoI model ({len(extra_in_aoi)}):")[m
[32m+[m[32m        for key in sorted(extra_in_aoi):[m
[32m+[m[32m            print(f"  âž• {key}")[m
[32m+[m[32m    else:[m
[32m+[m[32m        print("âœ… No packages added in AoI model")[m
[32m+[m
[32m+[m[32m    print(f"\nCommon packages: {len(common_keys)}/{len(original_keys)} ({100*len(common_keys)/len(original_keys):.1f}%)")[m
[32m+[m
[32m+[m[32m    # Show why packages might be missing[m
[32m+[m[32m    if missing_in_aoi:[m
[32m+[m[32m        print(f"\n=== WHY PACKAGES WERE REMOVED ===")[m
[32m+[m[32m        print("Packages are typically removed from AoI models when:")[m
[32m+[m[32m        print("1. They have no data within the clipped boundary")[m
[32m+[m[32m        print("2. All their stress points/cells fall outside the AoI")[m
[32m+[m[32m        print("3. The clip_box() method filters out empty packages" \[m
[32m+[m[32m        "")[m
[32m+[m[32m        print("\nThis is normal behavior and indicates successful spatial filtering!")[m
[32m+[m[32m    # Analyze the data content of common packages[m
[32m+[m[32m    print("=== PACKAGE DATA COMPARISON ===")[m
[32m+[m[32m    print("Comparing spatial dimensions and data ranges for common packages:\n")[m
[32m+[m
[32m+[m[32m    for key in sorted(common_keys):[m
[32m+[m[32m        print(f"ðŸ“¦ {key}:")[m
[32m+[m[32m        try:[m
[32m+[m[32m            orig_pkg = MF6_Mdl[key][m[41m [m
[32m+[m[32m            aoi_pkg = MF6_Mdl_AoI[key][m
[32m+[m[41m            [m
[32m+[m[32m            # Compare dataset sizes[m
[32m+[m[32m            if hasattr(orig_pkg, 'dataset') and hasattr(aoi_pkg, 'dataset'):[m
[32m+[m[32m                orig_sizes = dict(orig_pkg.dataset.sizes)[m
[32m+[m[32m                aoi_sizes = dict(aoi_pkg.dataset.sizes)[m
[32m+[m[41m                [m
[32m+[m[32m                print(f"   Original sizes: {orig_sizes}")[m
[32m+[m[32m                print(f"   AoI sizes:      {aoi_sizes}")[m
[32m+[m[41m                [m
[32m+[m[32m                # Calculate reduction ratios[m
[32m+[m[32m                for dim in ['x', 'y']:[m
[32m+[m[32m                    if dim in orig_sizes and dim in aoi_sizes:[m
[32m+[m[32m                        reduction = aoi_sizes[dim] / orig_sizes[dim][m
[32m+[m[32m                        print(f"   {dim} reduction: {reduction:.3f} ({aoi_sizes[dim]}/{orig_sizes[dim]} cells)")[m
[32m+[m[41m                [m
[32m+[m[32m                # Check if data values are the same (for first few values)[m
[32m+[m[32m                if hasattr(orig_pkg.dataset, 'data_vars') and hasattr(aoi_pkg.dataset, 'data_vars'):[m
[32m+[m[32m                    common_vars = set(orig_pkg.dataset.data_vars) & set(aoi_pkg.dataset.data_vars)[m
[32m+[m[32m                    if common_vars:[m
[32m+[m[32m                        var = list(common_vars)[0]  # Check first variable[m
[32m+[m[32m                        orig_data = orig_pkg.dataset[var][m
[32m+[m[32m                        aoi_data = aoi_pkg.dataset[var][m
[32m+[m[41m                        [m
[32m+[m[32m                        # Check if AoI data is a subset of original[m
[32m+[m[32m                        if 'x' in orig_data.dims and 'y' in orig_data.dims:[m
[32m+[m[32m                            print(f"   Variable '{var}': Data appears to be spatially clipped âœ“")[m
[32m+[m[32m                        else:[m
[32m+[m[32m                            print(f"   Variable '{var}': Non-spatial data")[m
[32m+[m[32m            else:[m
[32m+[m[32m                print("   No dataset attributes to compare")[m
[32m+[m[41m                [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print(f"   âš ï¸  Error comparing {key}: {e}")[m
[32m+[m[41m        [m
[32m+[m[32m        print()  # Empty line for readability[m
[32m+[m[32m    # Compare coordinate bounds to verify clipping worked correctly[m
[32m+[m[32m    print("=== COORDINATE BOUNDS COMPARISON ===")[m
[32m+[m[32m    print(f"Target clipping bounds: X({Xmin:.1f}, {Xmax:.1f}), Y({Ymin:.1f}, {Ymax:.1f})")[m
[32m+[m[32m    print()[m
[32m+[m
[32m+[m[32m    # Check DIS package bounds (most reliable for spatial extent)[m
[32m+[m[32m    if 'dis' in common_keys:[m
[32m+[m[32m        try:[m
[32m+[m[32m            orig_dis = MF6_Mdl['dis'][m
[32m+[m[32m            aoi_dis = MF6_Mdl_AoI['dis'][m
[32m+[m[41m            [m
[32m+[m[32m            # Original bounds[m
[32m+[m[32m            orig_x_min, orig_x_max = float(orig_dis.dataset.x.min()), float(orig_dis.dataset.x.max())[m
[32m+[m[32m            orig_y_min, orig_y_max = float(orig_dis.dataset.y.min()), float(orig_dis.dataset.y.max())[m
[32m+[m[41m            [m
[32m+[m[32m            # AoI bounds[m[41m  [m
[32m+[m[32m            aoi_x_min, aoi_x_max = float(aoi_dis.dataset.x.min()), float(aoi_dis.dataset.x.max())[m
[32m+[m[32m            aoi_y_min, aoi_y_max = float(aoi_dis.dataset.y.min()), float(aoi_dis.dataset.y.max())[m
[32m+[m[41m            [m
[32m+[m[32m            print("Original model bounds:")[m
[32m+[m[32m            print(f"   X: {orig_x_min:.1f} to {orig_x_max:.1f} (range: {orig_x_max-orig_x_min:.1f})")[m
[32m+[m[32m            print(f"   Y: {orig_y_min:.1f} to {orig_y_max:.1f} (range: {orig_y_max-orig_y_min:.1f})")[m
[32m+[m[41m            [m
[32m+[m[32m            print("\nAoI model bounds:")[m
[32m+[m[32m            print(f"   X: {aoi_x_min:.1f} to {aoi_x_max:.1f} (range: {aoi_x_max-aoi_x_min:.1f})")[m
[32m+[m[32m            print(f"   Y: {aoi_y_min:.1f} to {aoi_y_max:.1f} (range: {aoi_y_max-aoi_y_min:.1f})")[m
[32m+[m[41m            [m
[32m+[m[32m            # Verify clipping worked as expected[m
[32m+[m[32m            x_within_bounds = (aoi_x_min >= Xmin-dx) and (aoi_x_max <= Xmax+dx)[m
[32m+[m[32m            y_within_bounds = (aoi_y_min >= Ymin-dy) and (aoi_y_max <= Ymax+dy)[m
[32m+[m[41m            [m
[32m+[m[32m            print(f"\nClipping verification:")[m
[32m+[m[32m            print(f"   X bounds within target: {'âœ“' if x_within_bounds else 'âœ—'}")[m
[32m+[m[32m            print(f"   Y bounds within target: {'âœ“' if y_within_bounds else 'âœ—'}")[m
[32m+[m[41m            [m
[32m+[m[32m            if x_within_bounds and y_within_bounds:[m
[32m+[m[32m                print("   ðŸŽ‰ Clipping successful!")[m
[32m+[m[32m            else:[m
[32m+[m[32m                print("   âš ï¸  Clipping may not have worked as expected")[m
[32m+[m[41m                [m
[32m+[m[32m            # Calculate area reduction[m
[32m+[m[32m            orig_area = (orig_x_max - orig_x_min) * (orig_y_max - orig_y_min)[m
[32m+[m[32m            aoi_area = (aoi_x_max - aoi_x_min) * (aoi_y_max - aoi_y_min)[m
[32m+[m[32m            area_ratio = aoi_area / orig_area[m
[32m+[m[41m            [m
[32m+[m[32m            print(f"\nArea reduction:")[m
[32m+[m[32m            print(f"   Original area: {orig_area:,.0f} mÂ²")[m
[32m+[m[32m            print(f"   AoI area: {aoi_area:,.0f} mÂ²")[m[41m [m
[32m+[m[32m            print(f"   Ratio: {area_ratio:.4f} ({area_ratio*100:.2f}%)")[m
[32m+[m[41m            [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print(f"Error comparing DIS bounds: {e}")[m
[32m+[m[32m    else:[m
[32m+[m[32m        print("DIS package not found in common keys - cannot compare bounds")[m
[32m+[m[32m    # Print the names of common packages[m
[32m+[m[32m    print("=== COMMON PACKAGES ===")[m
[32m+[m[32m    print(f"These {len(common_keys)} packages are present in both models:")[m
[32m+[m[32m    for i, key in enumerate(sorted(common_keys), 1):[m
[32m+[m[32m        print(f"{i:2d}. {key}")[m
[32m+[m[32m    MF6_Mdl_AoI.keys()[m
[32m+[m[32m    MF6_Mdl['chd_merged']['head'].isel(time=0, layer=0).isel(x=range(0,10), y=range(0,10)).plot.imshow(cmap='viridis')[m
[32m+[m[32m    MF6_Mdl_AoI['chd_merged']['head'].isel(time=0, layer=0).plot.imshow(cmap='viridis')[m
[32m+[m[32m    Seems like CHD has finally been applied correctly![m
[32m+[m[32m    This is ok. The only missing package is one of the WEL packages, which has no items in the model area.[m
[32m+[m[32m    ### Cleanup MF6[m
[32m+[m[32m    try:[m
[32m+[m[32m        for Pkg in [i for i in MF6_Mdl_AoI.keys() if ('riv' in i.lower()) or ('drn' in i.lower())]:[m
[32m+[m[32m            MF6_Mdl_AoI[Pkg].cleanup(DIS_AoI)[m
[32m+[m[32m    except:[m
[32m+[m[32m        print('Failed to cleanup packaes. Proceeding without cleanup. Fingers crossed!')[m
[32m+[m[32m    ### MSW[m
[32m+[m[32m    # Cleanup MetaSWAP[m
[32m+[m[32m    MSW_Mdl_AoI["grid"].dataset["rootzone_depth"] = MSW_Mdl_AoI["grid"].dataset["rootzone_depth"].fillna(1.0)[m
[32m+[m[32m    ## Couple[m
[32m+[m[32m    metamod_coupling = primod.MetaModDriverCoupling(mf6_model=f'{MdlN}', mf6_recharge_package="msw-rch", mf6_wel_package="msw-sprinkling")[m
[32m+[m[32m    metamod = primod.MetaMod(MSW_Mdl_AoI, Sim_MF6_AoI, coupling_list=[metamod_coupling])[m
[32m+[m[32m    os.makedirs(d_Pa['Pa_MdlN'], exist_ok=True) # Create simulation directory if it doesn't exist[m
[32m+[m[32m    # Those can be changed to relative paths.[m
[32m+[m[32m    Pa_MF6_DLL = r"C:\OD\WS_Mdl\software\iMOD5\bin\iMOD_coupler\libmf6.dll"[m
[32m+[m[32m    Pa_MSW_DLL = r"C:\OD\WS_Mdl\software\iMOD5\bin\iMOD_coupler\MetaSWAP.dll"[m
[32m+[m[32m    metamod.write(directory=d_Pa['Pa_MdlN'], modflow6_dll=Pa_MF6_DLL, metaswap_dll=Pa_MSW_DLL, metaswap_dll_dependency=PDN(Pa_MF6_DLL))[m
[32m+[m[32m    # Review execution times per cell[m
[32m+[m[32m    t = show_cell_times()[m
[32m+[m[32m    # Execute model[m
[32m+[m[32m    # Execute the coupled model[m
[32m+[m[32m    print("ðŸš€ Starting coupled model execution...")[m
[32m+[m[32m    print(f"Model directory: {d_Pa['Pa_MdlN']}")[m
[32m+[m
[32m+[m[32m    # Check what files were written[m
[32m+[m[32m    print("\nðŸ“ Checking written model files:")[m
[32m+[m[32m    if PE(d_Pa['Pa_MdlN']):[m
[32m+[m[32m        model_files = LD(d_Pa['Pa_MdlN'])[m
[32m+[m[32m        for file in sorted(model_files):[m
[32m+[m[32m            print(f"  - {file}")[m
[32m+[m[41m        [m
[32m+[m[32m        # Look for the main execution file (usually .toml or similar)[m
[32m+[m[32m        toml_files = [f for f in model_files if f.endswith('.toml')][m
[32m+[m[32m        if toml_files:[m
[32m+[m[32m            print(f"\nðŸŽ¯ Found TOML configuration file: {toml_files[0]}")[m
[32m+[m[32m            main_toml = PJ(d_Pa['Pa_MdlN'], toml_files[0])[m
[32m+[m[41m            [m
[32m+[m[32m            # Since we have the DLL paths, we can try to execute using the iMOD coupler[m
[32m+[m[32m            # The iMOD coupler typically needs the .toml file as input[m
[32m+[m[32m            coupler_exe = PJ(PDN(Pa_MF6_DLL), "imodc.exe")[m
[32m+[m[41m            [m
[32m+[m[32m            if PE(coupler_exe):[m
[32m+[m[32m                print(f"âœ… Found iMOD coupler: {coupler_exe}")[m
[32m+[m[32m                print(f"ðŸ”„ Executing: {coupler_exe} {main_toml}")[m
[32m+[m[41m                [m
[32m+[m[32m                # Execute the model (this will take some time)[m
[32m+[m[32m                import subprocess[m
[32m+[m[32m                try:[m
[32m+[m[32m                    result = subprocess.run([coupler_exe, main_toml],[m[41m [m
[32m+[m[32m                                        cwd=d_Pa['Pa_MdlN'],[m[41m [m
[32m+[m[32m                                        capture_output=True,[m[41m [m
[32m+[m[32m                                        text=True,[m
[32m+[m[32m                                        timeout=3600)  # 1 hour timeout[m
[32m+[m[41m                    [m
[32m+[m[32m                    print(f"Return code: {result.returncode}")[m
[32m+[m[32m                    if result.stdout:[m
[32m+[m[32m                        print("STDOUT:")[m
[32m+[m[32m                        print(result.stdout)[m
[32m+[m[32m                    if result.stderr:[m
[32m+[m[32m                        print("STDERR:")[m
[32m+[m[32m                        print(result.stderr)[m
[32m+[m[41m                        [m
[32m+[m[32m                    if result.returncode == 0:[m
[32m+[m[32m                        print("âœ… Model execution completed successfully!")[m
[32m+[m[32m                    else:[m
[32m+[m[32m                        print(f"âŒ Model execution failed with return code {result.returncode}")[m
[32m+[m[41m                        [m
[32m+[m[32m                except subprocess.TimeoutExpired:[m
[32m+[m[32m                    print("â° Model execution timed out after 1 hour")[m
[32m+[m[32m                except Exception as e:[m
[32m+[m[32m                    print(f"âŒ Error executing model: {e}")[m
[32m+[m[32m            else:[m
[32m+[m[32m                print(f"âŒ iMOD coupler not found at: {coupler_exe}")[m
[32m+[m[32m                print("You may need to execute the model manually using the iMOD coupler")[m
[32m+[m[32m        else:[m
[32m+[m[32m            print("âŒ No TOML configuration file found")[m
[32m+[m[32m    else:[m
[32m+[m[32m        print(f"âŒ Model directory not found: {d_Pa['Pa_MdlN']}")[m
[32m+[m[41m        [m
[32m+[m
[32m+[m[32m# --------------------------------------------------------------------------------[m
 [m
 # PrSimP related -----------------------------------------------------------------[m
 def add_OBS(MdlN: str, Opt: str = 'BEGIN OPTIONS\nEND OPTIONS'):[m
[36m@@ -660,7 +984,7 @@[m [mdef xr_clip_Mdl_Aa([m
     elif l_L is not None or Lmin is not None or Lmax is not None:[m
         vprint(f"Warning: Layer subsetting requested but dimension '{L_dim}' not found in data")[m
 [m
[31m-    vprint('ðŸŸ¢ðŸŸ¢ðŸŸ¢ - Successfully clipped xarray data to model area')[m
[32m+[m[32m    vprint('ðŸŸ¢ðŸŸ¢ - Successfully clipped xarray data to model area')[m
     return clipped[m
 [m
 [m
[1mdiff --git a/models/NBr/code/snakemake/Nbr32.smk b/models/NBr/code/snakemake/Nbr32.smk[m
[1mindex ed387b6..308a373 100644[m
[1m--- a/models/NBr/code/snakemake/Nbr32.smk[m
[1m+++ b/models/NBr/code/snakemake/Nbr32.smk[m
[36m@@ -1,5 +1,5 @@[m
 # --- Imports ---[m
[31m-from WS_Mdl.utils import Up_log, Pa_WS, INI_to_d, get_elapsed_time_str, get_MdlN_paths[m
[32m+[m[32mfrom WS_Mdl.utils import Up_log, Pa_WS, INI_to_d, get_elapsed_time_str[m
 import WS_Mdl.utils as U[m
 import WS_Mdl.utils_imod as UIM[m
 import WS_Mdl.geo as G[m
[36m@@ -19,39 +19,35 @@[m [mfrom filelock import FileLock as FL[m
 # --- Variables ---[m
 [m
 ## Options[m
[31m-MdlN        =   "Nbr32"[m
[31m-Mdl         =   ''.join([i for i in MdlN if i.isalpha()])[m
[32m+[m[32mMdlN        =   "NBr32"[m
 #MdlN_SFR_OBS_Src =   'NBr25'[m
 PP_rules       =   "(L == 1)"[m
 #MdlN_B          =   U.get_MdlN_paths(MdlN)['MdlN_B'][m
 [m
 [m
 ## Paths[m
[31m-Pa_Mdl          =   PJ(Pa_WS, f'models/{Mdl}') [m
[32m+[m[32mMdl             =   U.get_Mdl(MdlN)[m
[32m+[m[32md_Pa            =   U.get_MdlN_Pa(MdlN)[m
[32m+[m[32mPa_Mdl          =   d_Pa['Pa_Mdl'][m
 workdir:            Pa_Mdl[m
[31m-Pa_Smk          =   PJ(Pa_Mdl, 'code/snakemake')[m
[31m-Pa_temp         =   PJ(Pa_Smk, 'temp')[m
[31m-Pa_Sim          =   PJ(Pa_Mdl, 'Sim')[m
[32m+[m[32mPa_temp         =   d_Pa['Smk_temp'][m
[32m+[m[32mPa_Sim          =   d_Pa['Sim'][m
 Pa_MdlN         =   PJ(Pa_Sim, f'{MdlN}')[m
[31m-Pa_BAT_RUN      =   PJ(Pa_MdlN, 'RUN.BAT')[m
[32m+[m[32m#Pa_BAT_RUN      =   PJ(Pa_MdlN, 'RUN.BAT')[m
 Pa_OBS, Pa_NAM  =   [PJ(Pa_MdlN, 'GWF_1', i) for i in [f'MODELINPUT/{MdlN}.OBS6', f'{MdlN}.NAM']][m
[31m-Pa_SFR_Src, Pa_SFR_Dst  =   PJ(Pa_Mdl, f"In/SFR/{MdlN}/{MdlN}.SFR6"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.SFR6")[m
[31m-Pa_SFR_OBS_Src, Pa_SFR_OBS_Dst  =   PJ(Pa_Mdl, f"In/OBS/SFR/{MdlN_SFR_OBS_Src}/{MdlN_SFR_OBS_Src}.SFR.OBS6"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.SFR.OBS6")[m
[32m+[m[32m#Pa_SFR_Src, Pa_SFR_Dst  =   PJ(Pa_Mdl, f"In/SFR/{MdlN}/{MdlN}.SFR6"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.SFR6")[m
[32m+[m[32m#Pa_SFR_OBS_Src, Pa_SFR_OBS_Dst  =   PJ(Pa_Mdl, f"In/OBS/SFR/{MdlN_SFR_OBS_Src}/{MdlN_SFR_OBS_Src}.SFR.OBS6"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.SFR.OBS6")[m
 Pa_HED, Pa_CBC  =   [PJ(Pa_MdlN, 'GWF_1/MODELOUTPUT', i) for i in ['HEAD/HEAD.HED', 'BUDGET/BUDGET.CBC']][m
[31m-Pa_MVR_Src, Pa_MVR_Dst  =   PJ(Pa_Mdl, f"In/MVR/{MdlN}/{MdlN}.MVR"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.MVR")[m
[31m-Pa_DRN                  =   PJ(Pa_MdlN, 'GWF_1/MODELINPUT/NBR30_SYS1.DRN6')[m
[31m-[m
[31m-git_hash = shell("git rev-parse HEAD", read=True).strip()[m
[31m-git_tag  = shell("git describe --tags --exact-match", read=True, allow_error=True).strip() or "no_tag"[m
[32m+[m[32m#Pa_MVR_Src, Pa_MVR_Dst  =   PJ(Pa_Mdl, f"In/MVR/{MdlN}/{MdlN}.MVR"), PJ(Pa_MdlN, f"GWF_1/MODELINPUT/{MdlN}.MVR")[m
 [m
 ## Temp files (for completion validation)[m
[31m-log_Init           =   f"{Pa_Smk}/temp/Log_init_{MdlN}"[m
[31m-log_Sim            =   f"{Pa_Smk}/temp/Log_Sim_{MdlN}"[m
[31m-log_PRJ_to_TIF     =   f"{Pa_Smk}/temp/Log_PRJ_to_TIF_{MdlN}"[m
[31m-log_GXG            =   f"{Pa_Smk}/temp/Log_GXG_{MdlN}"[m
[31m-log_Up_MM          =   f"{Pa_Smk}/temp/Log_Up_MM_{MdlN}"[m
[31m-log_freeze_env     =   f"{Pa_Smk}/temp/Log_freeze_env_{MdlN}"[m
[31m-log_MVR_OPTIONS    =   f"{Pa_Smk}/temp/Log_MVR_OPTIONS{MdlN}"[m
[32m+[m[32mlog_Init           =   f"{Pa_temp}/Log_init_{MdlN}"[m
[32m+[m[32mlog_Sim            =   f"{Pa_temp}/Log_Sim_{MdlN}"[m
[32m+[m[32mlog_PRJ_to_TIF     =   f"{Pa_temp}/Log_PRJ_to_TIF_{MdlN}"[m
[32m+[m[32mlog_GXG            =   f"{Pa_temp}/Log_GXG_{MdlN}"[m
[32m+[m[32mlog_Up_MM          =   f"{Pa_temp}/Log_Up_MM_{MdlN}"[m
[32m+[m[32mlog_freeze_env     =   f"{Pa_temp}/Log_freeze_env_{MdlN}"[m
[32m+[m[32mlog_MVR_OPTIONS    =   f"{Pa_temp}/Log_MVR_OPTIONS{MdlN}"[m
 [m
 [m
 # --- Rules ---[m
[36m@@ -64,90 +60,100 @@[m [monerror: fail[m
 [m
 rule all: # Final rule[m
     input:[m
[31m-        log_Sim,[m
[31m-        log_Up_MM[m
[32m+[m[32m        # log_Sim,[m
[32m+[m[32m        # log_Up_MM,[m
[32m+[m[32m        log_Init,[m
         log_freeze_env[m
         [m
 ## -- PrP --[m
[31m-rule log_Init: # Sets status to running, and writes other info about therun. Has to complete before anything else.[m
[32m+[m[32mrule log_Init: # Sets status to running, and writes other info about the Sim. Has to complete before anything else.[m
     output:[m
         temp(log_Init)[m
     run:[m
         import socket[m
         device = socket.gethostname()[m
[31m-        d_INI = INI_to_d(get_MdlN_paths(MdlN)['INI'])[m
[32m+[m[32m        d_INI = INI_to_d(d_Pa['INI'])[m
         Up_log(MdlN, {  'End Status':       'Running',[m
                         'PrP start DT':     DT.now().strftime("%Y-%m-%d %H:%M:%S"),[m
[31m-                        "Sim device name":  device,[m
[32m+[m[32m                        'Sim device name':  device,[m
                         'Sim Dir':          Pa_Sim,[m
                         '1st SP date':      DT.strptime(d_INI['SDATE'], "%Y%m%d").strftime("%Y-%m-%d"),[m
                         'last SP date':     DT.strptime(d_INI['EDATE'], "%Y%m%d").strftime("%Y-%m-%d")})[m
         pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
 [m
[31m-rule Mdl_Prep: # Prepares Sim Ins (from Ins) via BAT file.[m
[32m+[m[32mrule freeze_pixi_env:[m
[32m+[m[32m    output:[m
[32m+[m[32m        temp(log_freeze_env)[m
[32m+[m[32m    run:[m
[32m+[m[32m        git_hash, git_tag = U.freeze_pixi_env(MdlN)[m
[32m+[m[32m        Up_log(MdlN, {  'Git hash': git_hash,[m
[32m+[m[32m                        'Git tag': git_tag}) # Log git info[m
[32m+[m[32m        pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
[32m+[m
[32m+[m[32mrule iMP_Mdl_Prep: # Prepares Sim Ins (from Ins) via iMOD python. iMOD python still uses an INI and a PRJ file.[m
     input:[m
         log_Init,[m
[31m-        BAT = f"code/Mdl_Prep/Mdl_Prep_{MdlN}.bat",[m
[31m-        INI = f"code/Mdl_Prep/Mdl_Prep_{MdlN}.ini",[m
[31m-        PRJ = f"In/PRJ/{MdlN}.prj"[m
[32m+[m[32m        BAT = d_Pa['BAT'],[m
[32m+[m[32m        INI = d_Pa['INI'],[m
[32m+[m[32m        PRJ = d_Pa['PRJ'][m
     output:[m
         Pa_BAT_RUN[m
     shell:[m
         "call {input.BAT}"[m
     ## Mdl_Prep Ins (mainly the PRJ) point to a lot of other files. Technically, all of them should be in the Ins of this rule. Practically, they don't need to be. That is because Ins from previous Sims aren't meant to be edited, as they're stamped with a MdlN. If one of the Ins that is new for this run is changed, then the script that edits that In Fi should be part of this snakemake file too.[m
 [m
[31m-## -- PrSimP --[m
[31m-rule add_OBS:[m
[31m-    input:[m
[31m-        Pa_BAT_RUN[m
[31m-    output:[m
[31m-        Pa_OBS[m
[31m-    run:[m
[31m-        UIM.add_OBS(MdlN, "BEGIN OPTIONS\n\tDIGITS 6\nEND OPTIONS")[m
[31m-[m
[31m-## -- Sim ---[m
[31m-rule Sim: # Runs the simulation via BAT file.[m
[31m-    input:[m
[31m-        Pa_OBS[m
[31m-    output:[m
[31m-        temp(log_Sim)[m
[31m-    run:[m
[31m-        os.chdir(Pa_MdlN) # Change directory to the model folder.[m
[31m-        DT_Sim_Start = DT.now()[m
[31m-        Up_log(MdlN, {  'Sim start DT'  :   DT_Sim_Start.strftime("%Y-%m-%d %H:%M:%S")})[m
[31m-        shell(Pa_BAT_RUN)[m
[31m-        pathlib.Path(output[0]).touch() [m
[31m-        Up_log(MdlN, {  'Sim end DT'    :   DT.now().strftime("%Y-%m-%d %H:%M:%S"),[m
[31m-                        'Sim Dur'       :   get_elapsed_time_str(DT_Sim_Start),[m
[31m-                        'End Status'    :   'Completed'})[m
[31m-[m
[31m-## -- PoP ---[m
[31m-rule PRJ_to_TIF:[m
[31m-    input:[m
[31m-        log_Sim[m
[31m-    output:[m
[31m-        temp(log_PRJ_to_TIF)[m
[31m-    run:[m
[31m-        G.PRJ_to_TIF(MdlN)[m
[31m-        pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
[31m-[m
[31m-rule GXG:[m
[31m-    input:[m
[31m-        log_Sim[m
[31m-    output:[m
[31m-        temp(log_GXG)[m
[31m-    run:[m
[31m-        G.HD_IDF_GXG_to_TIF(MdlN, rules=PP_rules)[m
[31m-        pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
[31m-[m
[31m-rule Up_MM:[m
[31m-    input:[m
[31m-        log_PRJ_to_TIF,[m
[31m-        log_GXG[m
[31m-    output:[m
[31m-        log_Up_MM[m
[31m-    run:[m
[31m-        G.Up_MM(MdlN, MdlN_MM_B=MdlN_MM_B)     # Update MM [m
[31m-        Up_log(MdlN, {  'PoP end DT':   DT.now().strftime("%Y-%m-%d %H:%M:%S"),[m
[31m-                        'End Status':   'PoPed'}) # Update log[m
[31m-        pathlib.Path(output[0]).touch()     # Create the file to mark the rule as done.[m
\ No newline at end of file[m
[32m+[m[32m# ## -- PrSimP --[m
[32m+[m[32m# rule add_OBS:[m
[32m+[m[32m#     input:[m
[32m+[m[32m#         Pa_BAT_RUN[m
[32m+[m[32m#     output:[m
[32m+[m[32m#         Pa_OBS[m
[32m+[m[32m#     run:[m
[32m+[m[32m#         UIM.add_OBS(MdlN, "BEGIN OPTIONS\n\tDIGITS 6\nEND OPTIONS")[m
[32m+[m
[32m+[m[32m# ## -- Sim ---[m
[32m+[m[32m# rule Sim: # Runs the simulation via BAT file.[m
[32m+[m[32m#     input:[m
[32m+[m[32m#         Pa_OBS[m
[32m+[m[32m#     output:[m
[32m+[m[32m#         temp(log_Sim)[m
[32m+[m[32m#     run:[m
[32m+[m[32m#         os.chdir(Pa_MdlN) # Change directory to the model folder.[m
[32m+[m[32m#         DT_Sim_Start = DT.now()[m
[32m+[m[32m#         Up_log(MdlN, {  'Sim start DT'  :   DT_Sim_Start.strftime("%Y-%m-%d %H:%M:%S")})[m
[32m+[m[32m#         shell(Pa_BAT_RUN)[m
[32m+[m[32m#         pathlib.Path(output[0]).touch()[m[41m [m
[32m+[m[32m#         Up_log(MdlN, {  'Sim end DT'    :   DT.now().strftime("%Y-%m-%d %H:%M:%S"),[m
[32m+[m[32m#                         'Sim Dur'       :   get_elapsed_time_str(DT_Sim_Start),[m
[32m+[m[32m#                         'End Status'    :   'Completed'})[m
[32m+[m
[32m+[m[32m# ## -- PoP ---[m
[32m+[m[32m# rule PRJ_to_TIF:[m
[32m+[m[32m#     input:[m
[32m+[m[32m#         log_Sim[m
[32m+[m[32m#     output:[m
[32m+[m[32m#         temp(log_PRJ_to_TIF)[m
[32m+[m[32m#     run:[m
[32m+[m[32m#         G.PRJ_to_TIF(MdlN)[m
[32m+[m[32m#         pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
[32m+[m
[32m+[m[32m# rule GXG:[m
[32m+[m[32m#     input:[m
[32m+[m[32m#         log_Sim[m
[32m+[m[32m#     output:[m
[32m+[m[32m#         temp(log_GXG)[m
[32m+[m[32m#     run:[m
[32m+[m[32m#         G.HD_IDF_GXG_to_TIF(MdlN, rules=PP_rules)[m
[32m+[m[32m#         pathlib.Path(output[0]).touch() # Create the file to mark the rule as done.[m
[32m+[m
[32m+[m[32m# rule Up_MM:[m
[32m+[m[32m#     input:[m
[32m+[m[32m#         log_PRJ_to_TIF,[m
[32m+[m[32m#         log_GXG[m
[32m+[m[32m#     output:[m
[32m+[m[32m#         log_Up_MM[m
[32m+[m[32m#     run:[m
[32m+[m[32m#         G.Up_MM(MdlN, MdlN_MM_B=MdlN_MM_B)     # Update MM[m[41m [m
[32m+[m[32m#         Up_log(MdlN, {  'PoP end DT':   DT.now().strftime("%Y-%m-%d %H:%M:%S"),[m
[32m+[m[32m#                         'End Status':   'PoPed'}) # Update log[m
[32m+[m[32m#         pathlib.Path(output[0]).touch()     # Create the file to mark the rule as done.[m
\ No newline at end of file[m
